<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风的影子</title>
  <subtitle>小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muleimulei.github.io/"/>
  <updated>2017-08-23T12:00:57.934Z</updated>
  <id>https://muleimulei.github.io/</id>
  
  <author>
    <name>穆蕾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>html重绘与重排</title>
    <link href="https://muleimulei.github.io/2017/08/23/HTML5/html%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/"/>
    <id>https://muleimulei.github.io/2017/08/23/HTML5/html重绘与重排/</id>
    <published>2017-08-23T11:31:32.986Z</published>
    <updated>2017-08-23T12:00:57.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>html重绘与重排</p>
</blockquote>
<a id="more"></a>
<p>浏览器从下载文档到显示文档的过程是个复杂的过程，这里包含了重绘和重排。各家浏览器引擎的工作原理略有差别，但也有一定规则。文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一颗用于渲染的树。渲染树的每个节点都有大小和边距属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树并不包含隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要一次遍历就可以完成。但table及其内部元素除外，他可能需要多次计算才能确定好其在渲染树的属性，通常要花3倍于同等元素时的时间。这也就是为什么我们需要避免使用table做布局的一个原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;html重绘与重排&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML5" scheme="https://muleimulei.github.io/categories/HTML5/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中的top，clientTop，scrollTop，offsetTop的讲解</title>
    <link href="https://muleimulei.github.io/2017/08/23/JavaScript/JavaScript%E7%9A%84top%E5%92%8CclientTop%E5%92%8CscrollTop%E5%92%8CoffsetTop%E7%9A%84%E8%AE%B2%E8%A7%A3/"/>
    <id>https://muleimulei.github.io/2017/08/23/JavaScript/JavaScript的top和clientTop和scrollTop和offsetTop的讲解/</id>
    <published>2017-08-23T08:49:23.306Z</published>
    <updated>2017-08-23T11:29:42.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>JavaScript中的top，clientTop，scrollTop，offsetTop的讲解</p>
</blockquote>
<a id="more"></a>
<p><img src="/assets/segment/layout.jpg" alt=""></p>
<p>scrollWidth：对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大<br>clientWidth: 对象内容的可视区的宽度，不包括滚动条等边线，会随对象显示大小的变化而变化<br>offsetWidth: 对象整体的实际宽度，包含滚动条等边线，会随对象显示大小的变化而变化<br>offsetHeight：clientHeight + 滚动条 + 边框<br>clientHeight: 内容可视区域的高度，不包含滚动条 toppadding + bottompadding + height<br>scrollHeight: 元素padding加上元素内容的高度，这个高度与滚动条无关，是元素的实际高度：toppadding + bottompadding + 内容height<br>offsetLeft：获取对象相对于版面或由offsetParent属性指定的父坐标的计算左侧位置<br>offsetTop：获取对象相对于版面或由offsetTop属性指定的父坐标的计算顶端位置<br>event.clientX：相对于文档的水平坐标<br>event.clientY：相对于文档的垂直坐标<br>event.offsetX：相对容器的水平坐标<br>event.offsetY：相对容器的垂直坐标</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;JavaScript中的top，clientTop，scrollTop，offsetTop的讲解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>getBoundingClientRect用法</title>
    <link href="https://muleimulei.github.io/2017/08/23/JavaScript/getBoundingClientRect%E7%94%A8%E6%B3%95/"/>
    <id>https://muleimulei.github.io/2017/08/23/JavaScript/getBoundingClientRect用法/</id>
    <published>2017-08-23T07:38:27.128Z</published>
    <updated>2017-08-23T07:59:41.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>getBoundingClientRect用法</p>
</blockquote>
<a id="more"></a>
<p>getBoundingClientRect用于获取某个元素相对于视窗的位置集合。集合中有top，right，bottom，left等属性。</p>
<ol>
<li>语法：rectObject = object.getBoundingClientRect()</li>
<li><p>返回值类型：TextRectangle对象，每个矩形具有整数性质表示的矩形，以像素为单位。</p>
<ul>
<li>rectObject.top：元素上边到视窗上边的距离</li>
<li>rectObject.right：元素右边到视窗左边的距离</li>
<li>rectObject.bottom：元素下边到视窗上边的距离</li>
<li><p>rectObject.left：元素左边到视窗左边的距离</p>
<p><img src="data:image/jpeg;base64,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ZwAAAAAAOEJJTQPtAAAAAAAQAGADEgABAAIAYAMSAAEAAjhCSU0EJgAAAAAADgAAAAAAAAAAAAA/gAAAOEJJTQQNAAAAAAAEAAAAHjhCSU0EGQAAAAAABAAAAB44QklNA/MAAAAAAAkAAAAAAAAAAAEAOEJJTScQAAAAAAAKAAEAAAAAAAAAAjhCSU0D9QAAAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+AAAAAAAcAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAA4QklNBAAAAAAAAAIAADhCSU0EAgAAAAAACgAAAAAAAAAAAAA4QklNBDAAAAAAAAUBAQEBAQA4QklNBC0AAAAAAAYAAQAAAAY4QklNBAgAAAAAABAAAAABAAACQAAAAkAAAAAAOEJJTQQeAAAAAAAEAAAAADhCSU0EGgAAAAADWQAAAAYAAAAAAAAAAAAAAO4AAADwAAAAEgBRAFFiKlb+ADIAMAAxADUAMAA0ADIANgAyADEAMQA5ADAAOQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAA8AAAAO4AAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAG51bGwAAAACAAAABmJvdW5kc09iamMAAAABAAAAAAAAUmN0MQAAAAQAAAAAVG9wIGxvbmcAAAAAAAAAAExlZnRsb25nAAAAAAAAAABCdG9tbG9uZwAAAO4AAAAAUmdodGxvbmcAAADwAAAABnNsaWNlc1ZsTHMAAAABT2JqYwAAAAEAAAAAAAVzbGljZQAAABIAAAAHc2xpY2VJRGxvbmcAAAAAAAAAB2dyb3VwSURsb25nAAAAAAAAAAZvcmlnaW5lbnVtAAAADEVTbGljZU9yaWdpbgAAAA1hdXRvR2VuZXJhdGVkAAAAAFR5cGVlbnVtAAAACkVTbGljZVR5cGUAAAAASW1nIAAAAAZib3VuZHNPYmpjAAAA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UmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE1LTA0LTI2VDIxOjE5OjExKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNS0wNC0yNlQyMTozMTo1OSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxNS0wNC0yNlQyMTozMTo1OSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0NBN0E5MDExOEVDRTQxMThDNDI4M0NDQzg2REVENjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0JBN0E5MDExOEVDRTQxMThDNDI4M0NDQzg2REVENjkiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpDQkE3QTkwMTE4RUNFNDExOEM0MjgzQ0NDODZERUQ2OSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6Q0JBN0E5MDExOEVDRTQxMThDNDI4M0NDQzg2REVENjkiIHN0RXZ0OndoZW49IjIwMTUtMDQtMjZUMjE6MTk6MTErMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gaW1hZ2UvcG5nIHRvIGltYWdlL2pwZWciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOkNDQTdBOTAxMThFQ0U0MTE4QzQyODNDQ0M4NkRFRDY5IiBzdEV2dDp3aGVuPSIyMDE1LTA0LTI2VDIxOjMxOjU5KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/iDFhJQ0NfUFJPRklMRQABAQAADEhMaW5vAhAAAG1udHJSR0IgWFlaIAfOAAIACQAGADEAAGFjc3BNU0ZUAAAAAElFQyBzUkdCAAAAAAAAAAAAAAAAAAD21gABAAAAANMtSFAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEWNwcnQAAAFQAAAAM2Rlc2MAAAGEAAAAbHd0cHQAAAHwAAAAFGJrcHQAAAIEAAAAFHJYWVoAAAIYAAAAFGdYWVoAAAIsAAAAFGJYWVoAAAJAAAAAFGRtbmQAAAJUAAAAcGRtZGQAAALEAAAAiHZ1ZWQAAANMAAAAhnZpZXcAAAPUAAAAJGx1bWkAAAP4AAAAFG1lYXMAAAQMAAAAJHRlY2gAAAQwAAAADHJUUkMAAAQ8AAAIDGdUUkMAAAQ8AAAIDGJUUkMAAAQ8AAAIDHRleHQAAAAAQ29weXJpZ2h0IChjKSAxOTk4IEhld2xldHQtUGFja2FyZCBDb21wYW55AABkZXNjAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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" alt=""></p>
</li>
</ul>
</li>
<li><p>width和height</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rectWidth = rectObject.right - rectObject.left,</div><div class="line">    rectHeight = rectObject.bottom - rectObject.top</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;getBoundingClientRect用法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS3的display:table</title>
    <link href="https://muleimulei.github.io/2017/08/20/CSS3/css%E7%9A%84display%E4%B8%BAtable/"/>
    <id>https://muleimulei.github.io/2017/08/20/CSS3/css的display为table/</id>
    <published>2017-08-20T06:37:56.681Z</published>
    <updated>2017-08-20T14:51:12.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>CSS3的display:table</p>
</blockquote>
<a id="more"></a>
<h2 id="两种类型的表格布局"><a href="#两种类型的表格布局" class="headerlink" title="两种类型的表格布局"></a>两种类型的表格布局</h2><ol>
<li><p>HTML Table:HTML Table是指使用原生的table标签。</p>
</li>
<li><p>CSS Table:CSS Table是指用CSS属性模仿HTML 表格的模型。</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">table &#123; display: table &#125;</div><div class="line">tr &#123; display: table-row &#125;</div><div class="line">thead &#123; display: table-header-group &#125;</div><div class="line">tbody &#123; display: table-row-group &#125;</div><div class="line">tfoot &#123; display: table-footer-group &#125;</div><div class="line">col &#123; display: table-column &#125;</div><div class="line">colgroup &#123; display: table-column-group &#125;</div><div class="line">td, th &#123; display: table-cell &#125;</div><div class="line">caption &#123; display: table-caption &#125;</div></pre></td></tr></table></figure>
<p>显而易见HTML Table使用标签table，tr、td等标签，就是使用CSS Table的相关属性来实现的。</p>
<p>table：指定对象作为块元素级的表格。</p>
<p>inline-table：指定对象作为内联元素级的表格。</p>
<p>table-caption：指定对象作为表格标题。</p>
<p>table-cell：指定对象作为表格单元格。</p>
<p>table-row：指定对象作为表格行。</p>
<p>table-row-group：指定对象作为表格行组。</p>
<p>table-column：指定对象作为表格列。</p>
<p>table-column-group：指定对象作为表格列组显示。</p>
<p>table-header-group：指定对象作为表格标题组。</p>
<p>table-footer-group：指定对象作为表格脚注组。</p>
<h2 id="动态垂直居中对齐"><a href="#动态垂直居中对齐" class="headerlink" title="动态垂直居中对齐"></a>动态垂直居中对齐</h2><div class="wrapper"><br>    <button>添加</button><br>    <div class="box"><br>        <p>Hello World</p><br>        <p>Hello World</p><br>    </div><br></div>

<style>
    .wrapper{
        height: 300px;
        width: 100%;
        background: #105B63;
        display: table;
        position: relative;
        color: white;
    }
    .wrapper > button{
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 5px 10px;
        display: inline-block;
        background: #BD4932;
        outline: none;
        border: 2px solid #db9e36;
        color: #FFD34E;
        border-radius: 10px;
        box-shadow: 0 2px 3px rgba(0, 0, 0, .5);
        cursor: pointer;
    }
    .wrapper > button:active{
        border-color: #FFFAD5;
        color: #FFFAD5;
    }
    .wrapper  div.box{
        display: table-cell;
        text-align: center;
        vertical-align: middle;
    }
</style>

<h2 id="动态水平居中对齐"><a href="#动态水平居中对齐" class="headerlink" title="动态水平居中对齐"></a>动态水平居中对齐</h2><p>为了让元素动态水平居中对齐，可以设置元素为<code>display: inline-block</code>。然后在该元素的外面包裹层设置<code>text-align: center</code>。这里的文本对齐缺点是有副作用的。外层包裹层的所有子元素继承了<code>text-align: center</code>，造成潜在的覆盖。</p>
<div id="wrapper2"><br>    <h1>动态水平居中对齐</h1><br>    <h2>使用<span class="orange">display: table</span></h2><br>    <nav role="navigation" class="nav-table"><br>        <ul><li><a href="#">Home</a></li><li><a href="#">About</a></li><li><a href="#">Client</a></li><li><a href="#">Contact Us</a></li></ul><br>    </nav><br>    <h2>使用 <span class="orange">display: inline-block</span></h2><br>    <nav role="navigation" class="nav-inline-block"><br>      <ul><li><a href="#">Home</a></li><li><a href="#">About</a></li><li><a href="#">Clients</a></li><li><a href="#">Contact Us</a></li></ul><br>    </nav><br></div>

<style>
    #wrapper2{
        width: 100%;
        text-align: center;
        color: #FFFAD5;
        background: #FFD34E;
        text-shadow: 0 1px 1px rgba(0, 0, 0, .2);
    }
    #wrapper2 .orange{
        color: #BD4932;
    }
    #wrapper2 .nav-table{
        display: table;
        margin: auto;
    }
    #wrapper2 .nav-inline-block{
        display: inline-block;
    }
    #wrapper2 ul{
        margin: 0;
        padding: 0;
    }
    #wrapper2 ul li{
        float: left;
        background: #bd4932;
        list-style: none;
    }
    #wrapper2 ul li a{
        display: block;
        padding: .5em 1em;
        color: #FFFAD5;
    }
</style>


<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>css Table布局可以让一个元素表现上不像一个表格。只要将元素的display属性从table-cell切换到block，我们就能够将元素堆叠起来，你可以根据屏幕的可视区域改变元素的堆叠的顺序。</p>
<div id="wrapper3"><div class="box box1"></div><div class="box box2"></div><div class="box box3"></div></div>

<style>
    #wrapper3{
        width: 100%;
        display: table;
        min-height: 300px;
    }
    #wrapper3 .box{
        display: table-cell;
        text-align: center;
        vertical-align:middle;
        line-height: 13em;
    }
    #wrapper3 .box1{
        background: #BD4932;
    }
    #wrapper3 .box2{
        background: #105B63;
    }
    #wrapper3 .box3{
        background: #FFFAD5;
    }
</style>

<h2 id="动态高度的页脚贴在页面底部"><a href="#动态高度的页脚贴在页面底部" class="headerlink" title="动态高度的页脚贴在页面底部"></a>动态高度的页脚贴在页面底部</h2><p>页脚动态贴在底部需要满足以下两个条件：</p>
<ul>
<li>当主体的内容高度不超过可视区域高度的时候，页脚贴在页面底部。</li>
<li>当主体的内容高度超过可视区域高度的时候，页脚将按正常布局。</li>
</ul>
<div id="wrapper4"><button class="btn1">添加内容到主体区域</button><button class="btn2">添加内容到底部</button><div class="maincontent">这里是主体区域</div><div class="foot">这里是底部</div></div>

<style>
    #wrapper4{
        width: 100%;
        height: 400px;
        background: #FFFAD5;
        display: table;
        color: #BD4932;
        position: relative;
    }
    #wrapper4 .maincontent{
        height: 100%;
        text-align: center;
    }
    #wrapper4 button{
        position: absolute;
        padding: 5px 10px;
        display: inline-block;
        background: #BD4932;
        outline: none;
        border: 2px solid #db9e36;
        color: #FFD34E;
        border-radius: 10px;
        box-shadow: 0 2px 3px rgba(0, 0, 0, .5);
        cursor: pointer;
    }
    #wrapper4 button:active{
        border-color: #FFFAD5;
        color: #FFFAD5;
    }
    #wrapper4 .btn2{
        top: 60px;
    }
    #wrapper4 .foot{
        height: 1px;
        display: table-row;
        background: #105B63;
        color: #FFFAD5;
    }
</style>

<script>
    document.querySelector("#wrapper4 .btn1").addEventListener("click", function(){
    var element = document.createElement("div");
    element.innerHTML = "<p>额外添加的行</p><p>额外添加的行</p><p>额外添加的行</p>";
  document.querySelector(".maincontent").appendChild(element);
});

document.querySelector("#wrapper4 .btn2").addEventListener("click", function(){
    var element = document.createElement("div");
    element.innerHTML = "<p>额外添加到底部的行</p><p>额外添加到底部的行</p><p>额外添加到底部的行</p>";
  document.querySelector(".foot").appendChild(element);
});
</script>

<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><ul>
<li>具有中心内容主体和固定宽度的侧边栏</li>
<li>在源代码中，允许中心内容主体列出现在第一个节点位置</li>
<li>允许任何一列的高度最高</li>
</ul>
<div id="wrapper5"><div class="header">头部</div><div class="maincontent"><div class="box sidebarr">左边栏</div><div class="box content">主体内容</div><div class="box sidebarr">右侧栏</div></div><div class="foot">页脚底部</div></div>

<style>
    #wrapper5{
        width: 100%;
        height: 300px;
        background: #FFFAD5;
        display: table;
        text-align: center;
        position: relative;
    }
    #wrapper5 button{
        position: absolute;
        padding: 5px 10px;
        display: inline-block;
        background: #BD4932;
        outline: none;
        border: 2px solid #db9e36;
        color: #FFD34E;
        border-radius: 10px;
        box-shadow: 0 2px 3px rgba(0, 0, 0, .5);
        cursor: pointer;
    }
    #wrapper5 .header{
        display: table-row;
        height: 2px;
        background: #FFD34E;
    }
    #wrapper5 .maincontent{
        display: table;
        height: 100%;
        width: 100%;
    }
    #wrapper5 .maincontent .box{
        display: table-cell;
    }
    #wrapper5 .maincontent .sidebarr{
        width: 100px;
        background: #BD4932;
    }
    #wrapper5 .foot{
        display: table-row;
        height: 1px;
        background: #105B63;
        color: #FFFAD5;
    }
</style>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;CSS3的display:table&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://muleimulei.github.io/categories/CSS3/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript控制伪元素的方法汇总</title>
    <link href="https://muleimulei.github.io/2017/08/15/JavaScript/JavaScript%E6%8E%A7%E5%88%B6%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://muleimulei.github.io/2017/08/15/JavaScript/JavaScript控制伪元素的方法汇总/</id>
    <published>2017-08-15T11:09:50.598Z</published>
    <updated>2017-08-15T12:11:31.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>javascript控制伪元素的方法汇总</p>
</blockquote>
<a id="more"></a>
<h2 id="为什么不能用JavaScript直接获取伪元素？"><a href="#为什么不能用JavaScript直接获取伪元素？" class="headerlink" title="为什么不能用JavaScript直接获取伪元素？"></a>为什么不能用JavaScript直接获取伪元素？</h2><p>比如::before和::after伪元素，用于在css渲染中向元素的头部或尾部插入内容，它们不受文档约束，也不影响文档本身，只影响最终样式。这些添加的内容不会出现在DOM中，仅仅是在css渲染层加入。事实上，伪元素可以被浏览器渲染，但本身并不是DOM元素。它不存在于文档中，所以JavaScript无法直接操作它。而Jquery的选择器都是基于DOM元素的，因此也并不能直接操作伪元素。</p>
<h2 id="伪元素有哪些？"><a href="#伪元素有哪些？" class="headerlink" title="伪元素有哪些？"></a>伪元素有哪些？</h2><p>伪元素有六个，分别为<code>::after, ::before, ::first-line, ::first-letter, ::selection, ::backdrop</code>。在各大网页中最常用的伪元素：<code>::after, ::before</code>。</p>
<h2 id="获取伪元素的属性值"><a href="#获取伪元素的属性值" class="headerlink" title="获取伪元素的属性值"></a>获取伪元素的属性值</h2><p>获取伪元素的属性值可以使用<code>window.getComputedStyle()</code>方法，获取伪元素的css样式声明对象，然后利用<code>getPropertyValue</code>方法或直接使用键值访问都可以获取对应的属性值。</p>
<p><code>window.getComputedStyle(element, [,[pseudoElement]])</code></p>
<p>参数如下：</p>
<ul>
<li>element:Object  : 伪元素的所在DOM元素</li>
<li>pseudoElement:String   :伪元素类型。可选值有：<code>::after, ::before, ::first-line, ::selection, ::backdrop</code></li>
</ul>
<p>例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// CSS代码</div><div class="line">#myId:before &#123;</div><div class="line">    content: "hello world!";</div><div class="line">    display: block;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background: red;</div><div class="line">&#125;</div><div class="line">// HTML代码</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">// JS代码</div><div class="line">var myIdElement = document.getElementById("myId");</div><div class="line">var beforeStyle = window.getComputedStyle(myIdElement, ":before");</div><div class="line">console.log(beforeStyle); // [CSSStyleDeclaration Object]</div><div class="line">console.log(beforeStyle.width); // 100px</div><div class="line">console.log(beforeStyle.getPropertyValue("width")); // 100px</div><div class="line">console.log(beforeStyle.content); // "hello world!"</div></pre></td></tr></table></figure></p>
<p>备注：</p>
<blockquote>
<ol>
<li>getPropertyValue()和直接使用键值访问，都可以访问CSSStyleDeclaration Object。它们两者的区别有：<ul>
<li>对于float属性，如果使用键值访问，则不能直接使用getComputedStyle(ele, null).float，而应该使用cssFloat与styleFloat</li>
<li>直接使用键值访问，则属性的键需要使用驼峰写法，如<code>style.backgroundColor</code></li>
<li>使用getPropertyValue()方法不必以驼峰书写形式，例如：<code>style.getPropertyValue(‘border-top-color’)</code></li>
</ul>
</li>
<li>伪元素默认是<code>display: inline</code>。如果没有定义display属性，即使在css中显示设置了width的属性值为固定的大小如“100px”,但是最后获取的width值仍为”quto“。这是因为行内元素不能自定义设置宽度。解决办法是给伪元素修改display属性为”block”,”inline-block”或其它。</li>
</ol>
</blockquote>
<h2 id="更改伪元素的格式"><a href="#更改伪元素的格式" class="headerlink" title="更改伪元素的格式"></a>更改伪元素的格式</h2><ol>
<li><p>更换class来实现伪元素属性的更改</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// CSS代码</div><div class="line">.red::before &#123; </div><div class="line">    content: "red"; </div><div class="line">    color: red; </div><div class="line">&#125;</div><div class="line">.green::before &#123; </div><div class="line">    content: "green"; </div><div class="line">    color: green;</div><div class="line">&#125;</div><div class="line">// HTML代码</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>内容内容内容内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">// jQuery代码</div><div class="line">$(".red").removeClass('red').addClass('green');</div></pre></td></tr></table></figure>
</li>
<li><p>使用CSSStyleSheet的insertRule来为伪元素修改样式：<br><code>document.styleSheets[0].addRule(‘.red::before’, ‘color: green’);  //支持IE </code></p>
</li>
<li><p>在<head>标签中插入的内部样式：</head></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>); </div><div class="line"><span class="built_in">document</span>.head.appendChild(style); </div><div class="line">sheet = style.sheet; </div><div class="line">sheet.addRule(<span class="string">'.red::before'</span>,<span class="string">'color: green'</span>); <span class="comment">// 兼容IE浏览器</span></div><div class="line">sheet.insertRule(<span class="string">'.red::before &#123; color: green &#125;'</span>, <span class="number">0</span>); <span class="comment">// 支持非IE的现代浏览器</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="修改伪元素的content的属性值"><a href="#修改伪元素的content的属性值" class="headerlink" title="修改伪元素的content的属性值"></a>修改伪元素的content的属性值</h2><ol>
<li><p>使用CSSStyleSheet的insertRule来为伪元素修改样式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> latestContent = <span class="string">"修改过的内容"</span>;</div><div class="line"><span class="keyword">var</span> formerContent = <span class="built_in">window</span>.getComputedStyle($(<span class="string">'.red'</span>), <span class="string">'::before'</span>).getPropertyValue(<span class="string">'content'</span>); </div><div class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].addRule(<span class="string">'.red::before'</span>,<span class="string">'content: "'</span> + latestContent + <span class="string">'"'</span>); </div><div class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].insertRule(<span class="string">'.red::before &#123; content: "'</span> + latestContent + <span class="string">'" &#125;'</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用DOM元素的data-*属性来更改content的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// CSS代码</div><div class="line">.red::before &#123;</div><div class="line">content: attr(data-attr);</div><div class="line">color: red;</div><div class="line">&#125;</div><div class="line">// HTML代码</div><div class="line">&lt;div class=&quot;red&quot; data-attr=&quot;red&quot;&gt;内容内容内容内容&lt;/div&gt;</div><div class="line">// JacaScript代码</div><div class="line">$(&apos;.red&apos;).attr(&apos;data-attr&apos;, &apos;green&apos;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="before和-after伪元素的常用用法总结"><a href="#before和-after伪元素的常用用法总结" class="headerlink" title="::before和::after伪元素的常用用法总结"></a>::before和::after伪元素的常用用法总结</h2><ol>
<li><p>添加字符串：<br>使用引号包括一段字符串，将会向元素内容中添加字符串。<br><code>a:after { content: “after content”; }</code></p>
</li>
<li><p>使用attr()方法，调用当前元素的属性的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a:after &#123; content: attr(href); &#125;</div><div class="line">a:after &#123; content: attr(data-attr); &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用url方法，引用多媒体文件：<br><code>a::before { content: url(logo.png); }</code></p>
</li>
<li><p>清除浮动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.clear-fix &#123; *overflow: hidden; *zoom: 1; &#125;</div><div class="line">.clear-fix:after &#123; display: table; content: &quot;&quot;; width: 0; clear: both; &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;javascript控制伪元素的方法汇总&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是机器学习</title>
    <link href="https://muleimulei.github.io/2017/08/15/machinelearnng/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://muleimulei.github.io/2017/08/15/machinelearnng/什么是机器学习/</id>
    <published>2017-08-15T00:26:42.328Z</published>
    <updated>2017-08-15T02:48:20.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>什么是机器学习</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>利用计算机从历史数据中找出规律，并把这些规律用到对未来不确定场景的决策</p>
<p>基础知识：</p>
<ol>
<li>概率论</li>
<li>数理统计</li>
</ol>
<h2 id="机器学习的原动力"><a href="#机器学习的原动力" class="headerlink" title="机器学习的原动力"></a>机器学习的原动力</h2><ol>
<li>从历史数据中找出规律，把这些规律用到对未来自动做出决定</li>
<li>用数据代替expert</li>
<li>经济驱动，数据变现</li>
</ol>
<h2 id="机器学习的典型应用"><a href="#机器学习的典型应用" class="headerlink" title="机器学习的典型应用"></a>机器学习的典型应用</h2><p>购物篮分析</p>
<ul>
<li>关联规则<br>用户细分精准营销</li>
<li>聚类<br>信用卡欺诈</li>
<li>决策树<br>互联网广告</li>
<li>ctr预估<br>推荐系统</li>
<li>协同过滤<br>自然语言处理</li>
<li>情感分析</li>
<li>实体识别</li>
</ul>
<p>更多应用</p>
<ul>
<li>语音识别</li>
<li>智慧机器人</li>
<li>个性化医疗</li>
<li>私人虚拟助理</li>
<li>情感分析</li>
<li>手势控制</li>
<li>人脸识别</li>
<li>视频内容自动识别</li>
<li>自动驾驶</li>
<li>机器实时翻译</li>
</ul>
<p>机器学习算法分类</p>
<p>算法分类1：</p>
<ul>
<li>有监督学习：分类算法，回归算法</li>
<li>无监督学习：聚类</li>
<li>半监督学习：强化学习</li>
</ul>
<p>算法分类2：</p>
<ul>
<li>分类与回归</li>
<li>聚类</li>
<li>标注</li>
</ul>
<p>算法分类：</p>
<ul>
<li>生成模型：属于哪一类的概率</li>
<li>判别模型：属于哪一类</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;什么是机器学习&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="machinelearning" scheme="https://muleimulei.github.io/categories/machinelearning/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS3线性渐变</title>
    <link href="https://muleimulei.github.io/2017/08/13/CSS3/CSS3%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98/"/>
    <id>https://muleimulei.github.io/2017/08/13/CSS3/CSS3线性渐变/</id>
    <published>2017-08-13T14:56:30.933Z</published>
    <updated>2017-08-14T08:21:06.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>CSS3线性渐变</p>
</blockquote>
<a id="more"></a>
<p>渐变是从一种颜色逐渐蜕变到另一种颜色。线性渐变就是沿着一根轴线（水平，垂直或某个角度）改变颜色，从起点到终点颜色进行颜色渐变。</p>
<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>创建线性渐变你需要指定渐变的轴线和沿轴线变化的多种颜色，颜色将按与轴线垂直的方向被绘制，多种颜色间将实现渐变平滑过渡。具体语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">linear-gradient(gradient_line, color1, color2, ...);</div></pre></td></tr></table></figure></p>
<p>gradient_line指定了渐变线，后面跟随多种沿轴线变化的颜色</p>
<h1 id="轴线"><a href="#轴线" class="headerlink" title="轴线"></a>轴线</h1><p>轴线可以省略，这时，它使用默认值”to bottom”，指定轴线可以使用两种方式：</p>
<ul>
<li>使用角度<br>  “0 deg”表示垂直向上，然后按顺时针方向增加角度，“90deg”指向右边。</li>
<li>使用常量<br>  to top： 向上   0deg<br>  to right：  向右   90deg<br>  to bottom：  向下  180deg<br>  to left：    向右  270deg</li>
</ul>
<blockquote>
<p>常量可以组合使用，如”to top left”就是到左上角。</p>
</blockquote>
<h1 id="线性渐变的例子"><a href="#线性渐变的例子" class="headerlink" title="线性渐变的例子"></a>线性渐变的例子</h1><ol>
<li><p>垂直渐变<br> <div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#cd6600, #0067cd)"></div><br> css代码：<code>background-image: linear-gradient(#cd6600, #0067cd)</code><br> 你也可以指定轴线，下面的几种方式都可以达到和上面一样的效果</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">background: linear-gradient(to top, #0067cd, #cd6600);</div><div class="line">background: linear-gradient(to bottom, #cd6600, #0067cd);</div><div class="line">background: linear-gradient(180deg, #cd6600, #0067cd);</div><div class="line">background: linear-gradient(to bottom, #cd6600 0%, #0067cd 100%);</div></pre></td></tr></table></figure>
</li>
<li><p>斜角渐变<br> <div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(135deg, #cd6600, #0067cd)"></div><br> css代码：<code>background-image: linear-gradient(135deg, #cd6600, #0067cd)</code><br> 也可以指定负角度，如下：<br> <code>background: linear-gradient(-45deg, #0067cd, #cd6600);</code></p>
</li>
<li><p>多色渐变<br> <div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#6600cd, #cd6600 20%, #00cd66)"></div><br> css代码：<code>background-image: linear-gradient(#6600cd, #cd6600 20%, #00cd66)</code></p>
</li>
<li><p>多色斜角渐变<br> <div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(to top right, #cd6600, white, #0067cd)"></div><br> css代码：<code>linear-gradient(to top right, #cd6600, white, #0067cd)</code></p>
</li>
</ol>
<h2 id="重复线性渐变"><a href="#重复线性渐变" class="headerlink" title="重复线性渐变"></a>重复线性渐变</h2><p>重复线性渐变就是线性渐变的重复版本<strong> repeating-linear-gradient </strong>，当你定义好了你的线性渐变方式后，重复线性渐变会基于轴线不断的重复你的渐变方式，直到占满整个背景。使用重复线性渐变的关键是你需要定义好颜色节点，需要注意的是你定义的最后一种颜色将和第一种颜色相接在一起，处理不当将导致颜色的急剧变化。</p>
<h1 id="重复线性渐变的例子"><a href="#重复线性渐变的例子" class="headerlink" title="重复线性渐变的例子"></a>重复线性渐变的例子</h1><p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(#cd6600, #0067cd 20%, #cd6600 40%)"></div><br>css代码：<code>background-image: repeating-linear-gradient(#cd6600, #0067cd 20%, #cd6600 40%)</code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(90deg, #cd6600, #0067cd 20%, #cd6600 40%)"></div><br>css代码：<code>background-image: repeating-linear-gradient(90deg, #cd6600, #0067cd 20%, #cd6600 40%)</code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(135deg, #cd6600, #0067cd 20%, #cd6600 40%)"></div><br>css代码：<code>background-image: repeating-linear-gradient(135deg, #cd6600, #0067cd 20%, #cd6600 40%)</code></p>
<h1 id="颜色节点"><a href="#颜色节点" class="headerlink" title="颜色节点"></a>颜色节点</h1><p>颜色节点是沿着渐变轴线被放置的点，定义格式如下：<br><code> <color-stop> = <color> [<percentage> | <length>] </length></percentage></color></color-stop></code><br>首先指定颜色，然后指定位置，使用百分比值或者长度值表示。百分比值对应轴线长度的百分比，0%表示起始点，而100%表示结束点；长度值指从轴线的起始点向结束点方向计算的数值。<strong>颜色节点通常放置在起始点和结束点之间，但不是必须的，轴线可以在两个方向上无限扩展，而颜色节点可以放置在线上的任何位置 </strong>。<br>在每个颜色节点，线呈现为颜色节点的颜色。在两个颜色节点之间，线呈现为从一种颜色过渡到另一种颜色过度过程。在第一个颜色节点之前，线呈现为第一个颜色节点的颜色，而在最后一个节点，线呈现为最后一个颜色节点的颜色。</p>
<p>以下步骤定义了处理颜色节点列表的行为，应用这些规则后，所有颜色节点都将有一个明确的位置</p>
<ul>
<li>如果第一个颜色节点没有指定位置，设置它的位置为0%，如果最后一个节点没有指定位置，设置其为100%</li>
<li>如果一个颜色节点的位置小于了在它之前的任意一个颜色节点的位置，设置其位置等于它之前所有的颜色节点位置的最大的位置</li>
<li>如果存在一些颜色节点没有指定位置，那么，为那些相邻的没有指定颜色节点，设置它们的位置使他们平均占据空间。<ul>
<li>如果多个颜色节点有相同的位置，它们产生一个从一个颜色到另一个颜色的急剧的转换。从效果来看，就是从一种颜色突然改变到另一种颜色。</li>
</ul>
</li>
</ul>
<p>例子：</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(red, white 20%, blue)"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(red, white 20%, blue)<br>        相当于<br>        background-image: linear-gradient(red 0%, white 20%, blue 100%)<br>    </code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(red 40%, white, black, blue)"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(red 40%, white, black, blue)<br>        相当于<br>        background-image: linear-gradient(red 40%, white 60%, black 80%, blue 100%)<br>    </code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(red -50%, white, blue)"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(red -50%, white, blue)<br>        相当于<br>        background-image: linear-gradient(red -50%, white 25%, blue 100%)<br>    </code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(red 80px, white 0px, black, blue 100px)"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(red 80px, white 0px, black, blue 100px)<br>        相当于<br>        background-image: linear-gradient(red 80px, white 80px, black 90px, blue 100px)<br>    </code></p>
<h2 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h2><p>在讲解颜色节点时，我们提到“如果多个颜色节点有相同的位置，它们产生一个从一种颜色到另一种颜色的急剧的转换。从效果来看，就是从一种颜色突然改变到另一种颜色。”根据这个定义，我们只需要将多个颜色节点设置到同一个位置，就可以轻易的得到条纹背景效果。</p>
<h1 id="水平条纹背景"><a href="#水平条纹背景" class="headerlink" title="水平条纹背景"></a>水平条纹背景</h1><p>将两种颜色的颜色节点位置设置成一样就可以产生条纹背景，如下：</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#cd6600 50%, #0067cd 50%)"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(#cd6600 50%, #0067cd 50%)<br>    </code><br>利用背景的重复机制，我们可以创造出更多的条纹</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#cd6600 50%, #0067cd 50%);background-size: 100% 20%"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(#cd6600 50%, #0067cd 50%);<br>        background-size: 100% 20%;<br>    </code><br>这样我们就把整个背景划分为了10个条纹，但每个条纹的高度并不一定要一样，只要改变比例就可以做到：</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#cd6600 80%, #0067cd 80%);background-size: 100% 20%"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(#cd6600 80%, #0067cd 80%);<br>        background-size: 100% 20%;<br>    </code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(#cd6600 33.3%, #0067cd 0, #0067cd 66.7%, #00cd66 0);background-size: 100% 20%"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(#cd6600 33.3%, #0067cd 0, #0067cd 66.7%, #00cd66 0);<br>        background-size: 100% 20%;<br>    </code></p>
<p>或者创建分割线效果：</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(rgba(0, 0, 0, .5) 1px , #fff 1px);background-size: 100% 3px"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(rgba(0, 0, 0, .5) 1px , #fff 1px);<br>        background-size: 100% 3px;<br>    </code></p>
<h1 id="垂直条纹背景"><a href="#垂直条纹背景" class="headerlink" title="垂直条纹背景"></a>垂直条纹背景</h1><p>垂直条纹背景类似，只是需要转化一下宽和高的设置方式</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: linear-gradient(to right, #cd6600 50%, #0067cd 0);background-size: 20% 100%"></div><br>    css代码：<br>    <code><br>        background-image: linear-gradient(to right, #cd6600 50%, #0067cd 0);<br>        background-size: 20% 100%;<br>    </code></p>
<p>对角条纹背景</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(60deg, #cd6600, #cd6600 10%, #0067cd 0, #0067cd 20%);"></div><br>    css代码：<br>    <code><br>        background-image: repeating-linear-gradient(60deg, #cd6600, #0067cd 10%, #0067cd 0, #0067cd 20%);<br>    </code></p>
<p>可以指定多种颜色:</p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(60deg, #cd6600, #cd6600 10%, #0067cd 0, #0067cd 0, #0067cd 20%, #00cd66 0, #00cd66 30%);"></div><br>    css代码：<br>    <code><br>        background-image: repeating-linear-gradient(60deg, #cd6600, #cd6600 10%, #0067cd 0, #0067cd 0, #0067cd 20%, #00cd66 0, #00cd66 30%);<br>    </code></p>
<p><div style="margin: 0 auto;width: 200px; height:200px; background-image: repeating-linear-gradient(45deg, rgba(0, 103, 205, .5), rgba(0, 103, 205, .5) 10%, rgba(0, 103, 205, .3) 0, rgba(0, 103, 205, .3) 20%);"></div><br>    css代码：<br>    <code><br>        background-image: repeating-linear-gradient(60deg, #cd6600, #cd6600 10%, #0067cd 0, #0067cd 0, #0067cd 20%, #00cd66 0, #00cd66 30%);<br>    </code></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;CSS3线性渐变&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://muleimulei.github.io/categories/CSS3/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS实现单行，多行文本溢出显示省略号</title>
    <link href="https://muleimulei.github.io/2017/08/13/CSS3/css%E6%8E%A7%E5%88%B6%E6%96%87%E5%AD%97/"/>
    <id>https://muleimulei.github.io/2017/08/13/CSS3/css控制文字/</id>
    <published>2017-08-13T02:52:15.745Z</published>
    <updated>2017-08-13T03:31:39.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>CSS实现单行，多行文本溢出显示省略号</p>
</blockquote>
<a id="more"></a>
<p>实现单行文本的溢出显示省略号使用<code>text-overflow: ellipsis</code>，当然还需要加宽度width属性来兼容部分浏览。</p>
<p>实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">overflow: hidden;</div><div class="line">text-overflow: ellipsis;</div><div class="line">white-space: nowrap;</div></pre></td></tr></table></figure>
<p>但是这个属性只支持单行文本的溢出显示省略号。多行文本溢出显示省略号方法如下：<br>实现方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">display: -webkit-box;</div><div class="line">-webkit-box-orient: vertical;</div><div class="line">-webkit-line-clamp: 3;</div><div class="line">overflow: hidden;</div></pre></td></tr></table></figure></p>
<p>适用范围：<br>因为使用了webkit的css扩展属性，该方法适用于webkit浏览器及移动端；</p>
<p>注：</p>
<ol>
<li>-webkit-line-clamp:  用来限制在一个块元素显示的文本的行数。为了实现该效果，他需要组合其它的webkit属性。常用结合属性;</li>
<li>display: -webkit-box:    必须结合的属性，将对象作为弹性伸缩盒子模型</li>
<li>-webkit-box-orient: 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">p&#123;position: relative; line-height: 20px; max-height: 40px;overflow: hidden;&#125;</div><div class="line">p::after&#123;content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;</div><div class="line">background: -webkit-linear-gradient(left, transparent, #fff 55%);</div><div class="line">background: -o-linear-gradient(right, transparent, #fff 55%);</div><div class="line">background: -moz-linear-gradient(right, transparent, #fff 55%);</div><div class="line">background: linear-gradient(to right, transparent, #fff 55%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>将height设置为line-height的整数倍，防止超出的文字露出</li>
<li>给p::after添加渐变背景可避免文字只显示一半。</li>
<li>由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：<span></span>）；兼容ie8需要将<code>::after</code>替换成<code>:afetr</code>。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;CSS实现单行，多行文本溢出显示省略号&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://muleimulei.github.io/categories/CSS3/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的map常用操作</title>
    <link href="https://muleimulei.github.io/2017/08/12/c%E4%B8%8Ec++/STL%E7%9A%84map%E5%87%BD%E6%95%B0/"/>
    <id>https://muleimulei.github.io/2017/08/12/c与c++/STL的map函数/</id>
    <published>2017-08-12T09:06:56.447Z</published>
    <updated>2017-08-12T09:47:04.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>STL的map常用操作</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>map中的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>(); <span class="comment">// 默认构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&amp; m) <span class="comment">// 拷贝构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end ); <span class="comment">//区间构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end, <span class="keyword">const</span> traits&amp; _compare) <span class="comment">//带比较谓词的构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end, <span class="keyword">const</span> traits&amp; _compare, <span class="keyword">const</span> allocator&amp; all) <span class="comment">//带分配器</span></div></pre></td></tr></table></figure>
</li>
<li><p>数据的插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>第二种插入value_type数据<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三种：用数组方式插入数据，下面举例说明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent[<span class="number">1</span>] =  “student_one”;</div><div class="line">       mapStudent[<span class="number">2</span>] =  “student_two”;</div><div class="line">       mapStudent[<span class="number">3</span>] =  “student_three”;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以用pair来获得是否插入成功：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">Pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;</div><div class="line">       Insert_Pair＝mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       If(Insert_Pair.second == <span class="literal">true</span>)</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Successfully”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Else</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Failure”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Insert_Pair＝mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_two”));</div><div class="line">       If(Insert_Pair.second == <span class="literal">true</span>)</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Successfully”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Else</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Failure”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">&#123;</div><div class="line">       Cout&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>数据的查找（包括判定这个关键字是否在map中出现）<br>在这里我们将体会，map在数据插入时保证有序的好处。<br>要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的<br>map基本用法。<br>这里给出两种数据查找方法<br>第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系<br>，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了<br>第二种：用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，<br>如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器，程序说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, “student_two”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, “student_three”));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</div><div class="line">       iter = mapStudent.find(<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(iter != mapStudent.end())</div><div class="line">        &#123;</div><div class="line">               Cout&lt;&lt;”Find, the value is ”&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">               Cout&lt;&lt;”Do not Find”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数据的删除</p>
</li>
</ol>
<p>这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, “student_two”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, “student_three”));</div><div class="line"><span class="comment">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好</span></div><div class="line">       <span class="comment">//如果要删除1,用迭代器删除</span></div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</div><div class="line">       iter = mapStudent.find(<span class="number">1</span>);</div><div class="line">       mapStudent.erase(iter);</div><div class="line">       <span class="comment">//如果要删除1，用关键字删除</span></div><div class="line">       Int n = mapStudent.erase(<span class="number">1</span>);<span class="comment">//如果删除了会返回1，否则返回0</span></div><div class="line">       <span class="comment">//用迭代器，成片的删除</span></div><div class="line">       <span class="comment">//一下代码把整个map清空</span></div><div class="line">       mapStudent.earse(mapStudent.begin(), mapStudent.end());</div><div class="line">       <span class="comment">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合</span></div><div class="line">       <span class="comment">//自个加上遍历代码，打印输出吧</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>排序<br>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任<br>何问题的，因为上面的关键字是int型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体，涉及<br>到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去。<br>第一种：小于号重载，程序举例<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">Typedef <span class="keyword">struct</span> tagStudentInfo</div><div class="line">&#123;</div><div class="line">       Int      nID;</div><div class="line">       String   strName;</div><div class="line">        Bool <span class="keyword">operator</span> &lt; (tagStudentInfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></div><div class="line">       &#123;</div><div class="line">              <span class="comment">//这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序</span></div><div class="line">              If(nID &lt; _A.nID)  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">              If(nID == _A.nID) <span class="keyword">return</span> strName.compare(_A.strName) &lt; <span class="number">0</span>;</div><div class="line">              Return <span class="literal">false</span>;</div><div class="line">       &#125;</div><div class="line">&#125;StudentInfo, *PStudentInfo;  <span class="comment">//学生信息</span></div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> nSize;</div><div class="line">       <span class="comment">//用学生信息映射分数</span></div><div class="line">       <span class="built_in">map</span>&lt;StudentInfo, <span class="keyword">int</span>&gt;mapStudent;</div><div class="line">    <span class="built_in">map</span>&lt;StudentInfo, <span class="keyword">int</span>&gt;::iterator iter;</div><div class="line">       StudentInfo studentInfo;</div><div class="line">       studentInfo.nID = <span class="number">1</span>;</div><div class="line">       studentInfo.strName = “student_one”;</div><div class="line">       mapStudent.insert(pair&lt;StudentInfo, <span class="keyword">int</span>&gt;(studentInfo, <span class="number">90</span>));</div><div class="line">       studentInfo.nID = <span class="number">2</span>;</div><div class="line">       studentInfo.strName = “student_two”;</div><div class="line">mapStudent.insert(pair&lt;StudentInfo, <span class="keyword">int</span>&gt;(studentInfo, <span class="number">80</span>));</div><div class="line"><span class="keyword">for</span> (iter=mapStudent.begin(); iter!=mapStudent.end(); iter++)</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first.nID&lt;&lt;<span class="built_in">endl</span>&lt;&lt;iter-&gt;first.strName&lt;&lt;<span class="built_in">endl</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;STL的map常用操作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="STL的map常用操作" scheme="https://muleimulei.github.io/tags/STL%E7%9A%84map%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>STL的vector初始化</title>
    <link href="https://muleimulei.github.io/2017/08/12/c%E4%B8%8Ec++/STL%E7%9A%84vector%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://muleimulei.github.io/2017/08/12/c与c++/STL的vector初始化/</id>
    <published>2017-08-12T07:47:20.239Z</published>
    <updated>2017-08-12T08:58:32.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>STL的vector初始化</p>
</blockquote>
<a id="more"></a>
<p>vector是连续内存容器，所以对于插入与删除的时间复杂度是很高的，因为删除或者插入的时候，需要元素的移动，即元素复制拷贝。</p>
<h1 id="使用原则："><a href="#使用原则：" class="headerlink" title="使用原则："></a>使用原则：</h1><ol>
<li>尽量使用vector代替C风格的数组或者CArray；</li>
<li>尽量使用算法代替手工写的循环；</li>
<li>尽量使用vector本身的函数代替其它泛型算法；</li>
</ol>
<h1 id="初始化vector"><a href="#初始化vector" class="headerlink" title="初始化vector"></a>初始化vector</h1><p>填充vector，如果我们想使用原始数组的内容填充vector，例如我们有数组<code>int v[10] = {0,1,1,10,0,0,0,0,3,5}</code></p>
<ul>
<li><p>初始化方式1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">//  初始化size为10可以避免数组动态增长的时候不断的分配内存</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">    v2.push_back(v2[i]);    <span class="comment">//  增加一个元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(&amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>]);   <span class="comment">//  原始数组的元素指针可以作为迭代器来使用</span></div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</div><div class="line">v4.resize(<span class="number">10</span>);</div><div class="line">v4.insert(v4.begin(), &amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>]);</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5(<span class="number">10</span>);</div><div class="line">copy(&amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>], v5.begin());</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>原始数组的元素指针可以作为迭代器来使用,</p>
</blockquote>
<ul>
<li>原则：尽量使用resize来减少不必要的内存分配次数。</li>
<li>原则：尽量使用empty而不是size()==0来判断容器是否为空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">23</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">546</span>,<span class="number">76</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">v.resize(<span class="number">6</span>);</div><div class="line">copy(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">6</span>], v.begin());  <span class="comment">//  将a数组复制到v</span></div><div class="line">v.insert(v.begin(), <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="comment">//  找到所有的23</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = find(v.begin(), v.end(), <span class="number">23</span>);</div><div class="line"><span class="keyword">while</span>(pos!=v.end())&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"**"</span>&lt;&lt;*pos&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    pos = find(pos+<span class="number">1</span>, v.end(), <span class="number">23</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; v.size();i++)&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; v[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;STL的vector初始化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="STL的vector初始化" scheme="https://muleimulei.github.io/tags/STL%E7%9A%84vector%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vuex讲解</title>
    <link href="https://muleimulei.github.io/2017/08/10/Vue/Vuex%E8%AE%B2%E8%A7%A3/"/>
    <id>https://muleimulei.github.io/2017/08/10/Vue/Vuex讲解/</id>
    <published>2017-08-10T09:04:34.336Z</published>
    <updated>2017-08-11T14:39:21.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Vuex讲解</p>
</blockquote>
<a id="more"></a>
<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>Vuex是一个专为Vue.js应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所以组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h1 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="comment">//state</span></div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">count</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//view</span></div><div class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    <span class="comment">//actions</span></div><div class="line">    methods: &#123;</div><div class="line">        increment () &#123;</div><div class="line">            <span class="keyword">this</span>.count++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个状态自管理应用包括以下几个部分：</p>
<ul>
<li>state：驱动应用的数据源</li>
<li>view：以声明方式将state映射到视图</li>
<li>actions：响应在view上的用户输入导致的状态变化。</li>
</ul>
<img src="/assets/segment/vue-flow.png">
<p>但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态</li>
<li>来自不同视图的行为需要变更同一状态</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p>
<p>我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<img src="/assets/segment/vuex.png">
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h1 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h1><p>Vuex使用 <strong>单一状态树</strong>，用一个对象就包含了全部的应用层级状态。至此它便作为一个《《唯一数据源》》而存在。这也意味着，每个应用将仅仅包含一个store实例。单一状态树让我们能够直接的定位任意特定的状态片段，在调试的过程中也能够获得当前应用状态的快照。</p>
<h1 id="在Vue组件中获得Vuex状态"><a href="#在Vue组件中获得Vuex状态" class="headerlink" title="在Vue组件中获得Vuex状态"></a>在Vue组件中获得Vuex状态</h1><p>Vuex通过store选项，提供了一个机制将状态从根组件注入到每一个子组件中（需调用Vue.use(Vuex)）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">    <span class="comment">//  把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件</span></div><div class="line">    store,</div><div class="line">    <span class="attr">component</span>: &#123;Counter&#125;,</div><div class="line">    <span class="attr">template</span>: <span class="string">`</span></div><div class="line">        &lt;div class="app"&gt;</div><div class="line">            &lt;counter&gt;&lt;/counter&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `    </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过在根实例中注册store选项，该store实例会注入到根组件的所以子组件中，且子组件能通过this.$store访问到。counter的实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">        count () &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h1><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。可以使用mapState辅助函数帮助我们生成计算属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    computed: mapState(&#123;</div><div class="line">        <span class="comment">//  箭头函数可使代码更简练</span></div><div class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</div><div class="line">        <span class="comment">//传字符串参数 ‘count’等同于 `state =&gt; state.count`    </span></div><div class="line">        countAlias: <span class="string">'count'</span>,</div><div class="line">        <span class="comment">//为了能够使用this获取局部状态，必须使用常规函数</span></div><div class="line">        countPlusLocalState (state) &#123;</div><div class="line">            <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它—无论哪种方式都不是很理想。<br>Vuex允许我们在store中定义getter（可以认为是store的计算属性）。Getter接受state作为第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">todos</span>: [</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getter</span>: &#123;</div><div class="line">        <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Getter会暴露为store.getters对象:<br><code>store.getters.doneTodos</code></p>
<p>Getters也可以接受其它getters作为第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">    <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">store.getters.doneTodosCount</div></pre></td></tr></table></figure></p>
<p>我们可以很容易地在任何组件中使用它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodosCount () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h1><p>mapGetters 辅助函数仅仅是将store中的getters映射到局部计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">        <span class="comment">//使用对象展开运算符将getters混入computed对象中</span></div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'doneTodosCount'</span>,</div><div class="line">            <span class="string">'anotherGetter'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想将一个getter属性另取一个名字，使用对象形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...mapGetters(&#123;</div><div class="line">    <span class="comment">//  映射 this.doneCount 为 store.getters.doneTodosCount</span></div><div class="line">    doneCount: <span class="string">'doneTodosCount'</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex中的mutations非常类似于事件：每个mutation都有一个字符串的<strong>事件类型</strong>和一个<strong>回调函数</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">count</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mutations</span>: &#123;</div><div class="line">        increment (state) &#123;</div><div class="line">            <span class="comment">//变更状态</span></div><div class="line">            state.count++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不能直接调用一个mutation.handler。这个选项更像是事件注册：“当触发一个类型为increment的mutation时，调用此函数。”要唤醒一个mutation handler，你需要以相应的type调用store.commit方法。<code>store.commit(‘increment’)</code></p>
<h1 id="提交载荷"><a href="#提交载荷" class="headerlink" title="提交载荷"></a>提交载荷</h1><p>你可以向store.commit传入额外的参数，即mutation的载荷：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  ...</span></div><div class="line">mutations: &#123;</div><div class="line">    increment (state, n)&#123;</div><div class="line">        state.count += n</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mutation: &#123;</div><div class="line">    increment (state, payload) &#123;</div><div class="line">        state.count += payload.amount</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="Mutation需遵循Vue的响应规则"><a href="#Mutation需遵循Vue的响应规则" class="headerlink" title="Mutation需遵循Vue的响应规则"></a>Mutation需遵循Vue的响应规则</h1><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li><p>最好提前在你的 store 中初始化好所有所需属性。</p>
</li>
<li><p>当需要在对象上添加新属性时，你应该<br>使用 Vue.set(obj, ‘newProp’, 123), 或者 -<br>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：<code><br>state.obj = { …state.obj, newProp: 123 }</code></p>
</li>
</ol>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Action类似于mutation，不同在于：</p>
<ul>
<li>Action提交的是mutation，而不是直接变更状态</li>
<li>Action可以包含任意异步操作</li>
</ul>
<p>让我们来注册一个简单的action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">count</span>: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mutations</span>: &#123;</div><div class="line">        increment (state) &#123;</div><div class="line">            state.count++</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">actions</span>: &#123;</div><div class="line">        increment (context) &#123;</div><div class="line">            context.commit(<span class="string">'increment'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Action 函数接受一个与store实例具有相同方法的属性的context对象，因此你可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。</p>
<p>实践中，我们会经常用到ES2015的参数解构来简化代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    increment (&#123;commit&#125;) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h1><p>Action通过<code>store.dispatch</code>方法触发：<br><code>store.dispatch(‘increment’)</code>，<strong>mutation必须同步执行，但是我们可以在action内部执行异步操作 </strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    incrementAsync (&#123;commit&#125;) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            commit(<span class="string">'increment'</span>)    </div><div class="line">        &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Actions支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  以载荷形式分发</span></div><div class="line">store.dispatch(<span class="string">'increment'</span>, &#123;</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//以对象形式分发</span></div><div class="line">store.dispatch(&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h1><p>你在组件中使用<code>this.$store.dispatch(‘xxx’)</code>分发action，或者使用<code>mapActions</code>辅助函数将组件的methods映射为<code>store.dispatch</code>调用（需要先在根节点注入store）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    methods: &#123;</div><div class="line">        ...mapActions([</div><div class="line">            <span class="string">'increment'</span> <span class="comment">//  映射this.increment()为this.$store.dispatch('increment')</span></div><div class="line">            add: <span class="string">'increment'</span>    <span class="comment">//  映射this.add() 为this.$store.dispatch('increment')</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="组合Actions"><a href="#组合Actions" class="headerlink" title="组合Actions"></a>组合Actions</h1><p>Action通常是异步的，那么如何知道action什么时候结束呢？更重要的是，我们如何才能组合多个action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白<code>store.dispatch</code>可以处理被触发的action的回调函数返回的Promise，并且store.dispatch仍然返回Promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    actionA (&#123;commit&#125;) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                commit(<span class="string">'someMutation'</span>)</div><div class="line">                resolve()</div><div class="line">            &#125;, <span class="number">1000</span>)    </div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//...    </span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在另外一个action中也可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    actionB (&#123;dispatch, commit&#125;) &#123;</div><div class="line">        <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            commit(<span class="string">'someOtherMutation'</span>)    </div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>由于使用单一状态树，应用的所以状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相对臃肿。</p>
<p>为了解决以上问题，Vuex允许我们将store分割成<strong>模块</strong>，每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块—从上至下进行同样方式分割：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></div></pre></td></tr></table></figure>
<h1 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h1><p>对于模块内部的mutation和getter，接受的第一个参数是<strong>模块的局部状态对象</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，对于模块内部的action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于模块内部的getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块更加自包含或提高可重用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">account</span>: &#123;</div><div class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</div><div class="line">      <span class="comment">// 模块内容（module assets）</span></div><div class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></div><div class="line">      getters: &#123;</div><div class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">actions</span>: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">mutations</span>: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// 嵌套模块</span></div><div class="line">      modules: &#123;</div><div class="line">        <span class="comment">// 继承父模块的命名空间</span></div><div class="line">        myPage: &#123;</div><div class="line">          <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">          <span class="attr">getters</span>: &#123;</div><div class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 进一步嵌套命名空间</span></div><div class="line">        posts: &#123;</div><div class="line">          <span class="attr">namespaced</span>: <span class="literal">true</span>,</div><div class="line">          <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">          <span class="attr">getters</span>: &#123;</div><div class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Vuex讲解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://muleimulei.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>类型化数组</title>
    <link href="https://muleimulei.github.io/2017/08/07/JavaScript/%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <id>https://muleimulei.github.io/2017/08/07/JavaScript/类型化数组/</id>
    <published>2017-08-07T14:41:10.392Z</published>
    <updated>2017-08-10T04:38:17.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>类型化数组</p>
</blockquote>
<a id="more"></a>
<h2 id="类型化数组是JavaScript操作二进制数据的一个接口"><a href="#类型化数组是JavaScript操作二进制数据的一个接口" class="headerlink" title="类型化数组是JavaScript操作二进制数据的一个接口"></a>类型化数组是JavaScript操作二进制数据的一个接口</h2><p>类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。<br><code>var buf = new ArrayBuffer(32)</code>，这段代码生成了一段32字节的内存区域。ArrayBuffer对象的<strong>byteLength属性</strong>，返回所分配的区域区域的字节长度。<code>var buffer = new ArrayBuffer(32); buffer.byteLength</code>,如果分配的内存区域很大，有可能分配失败，所以有必要检查是否分配成功。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(buffer.byteLength===n)&#123;</div><div class="line">    <span class="comment">//success</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//fail</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ArrayBuffer对象有一个slice方法，允许将内存区域的一部分拷贝生成一个新的ArrayBuffer对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> newBuffer = buffer.slice(<span class="number">0</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码拷贝buffer对象的前3个字节，生成一个新的ArrayBuffer对象。slice方法包含两步：第一步先分配一段新内存，第二部是将原来那个ArrayBuffer对象拷贝过去。<br>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号，第二个参数表示拷贝截至的字节序号。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。<br>除了slice方法，ArrayBuffer对象不提供任何直接读取内存的方法，只允许再其上方建立视图，然后通过视图读写。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ol>
<li>视图的生成<br>ArrayBuffer作为内存区域，可以存放多种类型的数据。不同数据有不同的存取方式，这就叫做”视图”。目前，JavaScript提供以下类型的视图：</li>
</ol>
<blockquote>
<p>Int8Array：8位有符号整数，长度1个字节。<br>  Uint8Array：8位无符号整数，长度1个字节。<br>  Int16Array：16位有符号整数，长度2个字节。<br>  Uint16Array：16位无符号整数，长度2个字节。<br>  Int32Array：32位有符号整数，长度4个字节。<br>  Uint32Array：32位无符号整数，长度4个字节。<br>  Float32Array：32位浮点数，长度4个字节。<br>  Float64Array：64位浮点数，长度8个字节。</p>
</blockquote>
<p>每一种视图都有一个BYTE_PER_ELEMENT常数，表示这种数据类型占据的字节数。</p>
<blockquote>
<p>Int8Array.BYTES_PER_ELEMENT // 1<br>  Uint8Array.BYTES_PER_ELEMENT // 1<br>  Int16Array.BYTES_PER_ELEMENT // 2<br>  Uint16Array.BYTES_PER_ELEMENT // 2<br>  Int32Array.BYTES_PER_ELEMENT // 4<br>  Uint32Array.BYTES_PER_ELEMENT // 4<br>  Float32Array.BYTES_PER_ELEMENT // 4<br>  Float64Array.BYTES_PER_ELEMENT // 8</p>
</blockquote>
<ol>
<li>在ArrayBuffer对象之上生成视图<br>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个8字节的ArrayBuffer</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码在一段长度为8个字节的内存之上，生成了三个视图：v1，v2，v3。视图的构造函数可以接受三个参数：</p>
<blockquote>
<p>第一个参数：视图对应的底层ArrayBuffer对象，该参数是必需的。<br>  第二个参数：视图开始的字节序号，默认从0开始。<br>  第三个参数：视图包含的数据个数，默认直到本段内存区域结束。</p>
</blockquote>
<p>因此，v1、v2和v3是重叠：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>
<ol>
<li><p>直接生成<br>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f64a = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">8</span>);</div><div class="line">f64a[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line">f64a[<span class="number">1</span>] = <span class="number">20</span>;</div><div class="line">f64a[<span class="number">2</span>] = f64a[<span class="number">0</span>] + f64a[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
</li>
<li><p>将普通数组转为视图数组<br>将一个数据类型符合要求的普通数组，传入构造函数，也能直接生成视图。<code>var typedArray = new Uint8Array( [ 1, 2, 3, 4 ] );</code>，代码将一个普通的数组，赋值给一个新生成的8位无符号整数的视图数组。视图数组也可以转换回普通数组。<code>var normalArray = Array.apply( [], typedArray );</code></p>
</li>
<li><p>视图的操作<br>建立了视图以后，就可以进行各种操作了。这里需要明确的是，视图其实就是普通数组，语法完全没有什么不同，只不过它直接针对内存进行操作，而且每个成员都有确定的数据类型。所以，视图就被叫做“类型化数组”。</p>
<ul>
<li><p>数组操作<br>普通数组的操作方法和属性，对类型化数组完全适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</div><div class="line"><span class="keyword">var</span> int32View = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int32View.length; i++) &#123;</div><div class="line">  int32View[i] = i*<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int16View = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int16View.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Entry "</span> + i + <span class="string">": "</span> + int16View[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Entry 0: 0</span></div><div class="line"><span class="comment">// Entry 1: 0</span></div><div class="line"><span class="comment">// Entry 2: 2</span></div><div class="line"><span class="comment">// Entry 3: 0</span></div><div class="line"><span class="comment">// Entry 4: 4</span></div><div class="line"><span class="comment">// Entry 5: 0</span></div><div class="line"><span class="comment">// Entry 6: 6</span></div><div class="line"><span class="comment">// Entry 7: 0</span></div></pre></td></tr></table></figure>
<p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。<br>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以类型化数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。<br>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，类型化数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序，下文会详细介绍。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></div><div class="line"><span class="comment">// 计算机采用小端字节序</span></div><div class="line"><span class="keyword">var</span> uInt16View = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer);</div><div class="line"><span class="comment">// 比较运算 </span></div><div class="line"><span class="keyword">if</span> (bufView[<span class="number">0</span>]===<span class="number">258</span>) &#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 赋值运算</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></div></pre></td></tr></table></figure>
<p>总之，与普通数组相比，类型化数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
</li>
<li><p>buffer属性<br>类型化数组的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。<br>var a = new Float32Array(64);<br>var b = new Uint8Array(a.buffer);<br>上面代码的a对象和b对象，对应同一个ArrayBuffer对象，即同一段内存。</p>
</li>
<li>byteLength属性和byteOffset属性<br>byteLength属性返回类型化数组占据的内存长度，单位为字节。byteOffset属性返回类型化数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">v1.byteLength <span class="comment">// 8</span></div><div class="line">v2.byteLength <span class="comment">// 6</span></div><div class="line">v3.byteLength <span class="comment">// 4</span></div><div class="line"></div><div class="line">v1.byteOffset <span class="comment">// 0</span></div><div class="line">v2.byteOffset <span class="comment">// 2</span></div><div class="line">v3.byteOffset <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</div><div class="line">a.length <span class="comment">// 8</span></div><div class="line">a.byteLength <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<ul>
<li>set方法<br>类型化数组的set方法用于复制数组，也就是将一段内容完全复制到另一段内存。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line">b.set(a);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</div><div class="line">b.set(a,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>
<ul>
<li>subarray方法<br>subarray方法是对于类型化数组的一部分，再建立一个新的视图。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = a.subarray(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">a.byteLength <span class="comment">// 16</span></div><div class="line">b.byteLength</div></pre></td></tr></table></figure>
<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>
<ul>
<li>ArrayBuffer与字符串的互相转换<br>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params">buf</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 字符串转为ArrayBuffer对象，参数为字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(str.length*<span class="number">2</span>); <span class="comment">// 每个字符占用2个字节</span></div><div class="line">    <span class="keyword">var</span> bufView = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, strLen=str.length; i&lt;strLen; i++) &#123;</div><div class="line">         bufView[i] = str.charCodeAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h1><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。<br>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种类型化视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。<br>DataView本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。<br><code>DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</code></p>
<blockquote>
<p>getInt8：读取1个字节，返回一个8位整数。<br>  getUint8：读取1个字节，返回一个无符号的8位整数。<br>  getInt16：读取2个字节，返回一个16位整数。<br>  getUint16：读取2个字节，返回一个无符号的16位整数。<br>  getInt32：读取4个字节，返回一个32位整数。<br>  getUint32：读取4个字节，返回一个无符号的32位整数。<br>  getFloat32：读取4个字节，返回一个32位浮点数。<br>  getFloat64：读取8个字节，返回一个64位浮点数。</p>
</blockquote>
<p>这一系列get方法的参数都是一个字节序号，表示从哪个字节开始读取。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 从第1个字节读取一个8位无符号整数</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint8(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 从第2个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">1</span>); </div><div class="line"></div><div class="line"><span class="comment">// 从第4个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。<br>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 小端字节序</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint16(<span class="number">1</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">3</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法写入内存：</p>
<blockquote>
<p>setInt8：写入1个字节的8位整数。<br>setUint8：写入1个字节的8位无符号整数。<br>setInt16：写入2个字节的16位整数。<br>setUint16：写入2个字节的16位无符号整数。<br>setInt32：写入4个字节的32位整数。<br>setUint32：写入4个字节的32位无符号整数。<br>setFloat32：写入4个字节的32位浮点数。<br>setFloat64：写入8个字节的64位浮点数。</p>
</blockquote>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在第1个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">0</span>, <span class="number">25</span>, <span class="literal">false</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第5个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">4</span>, <span class="number">25</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></div><div class="line">dv.setFloat32(<span class="number">8</span>, <span class="number">2.5</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> littleEndian = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line">  <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer).setInt16(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer)[<span class="number">0</span>] === <span class="number">256</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;类型化数组&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="类型化数组" scheme="https://muleimulei.github.io/tags/%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据库安全性</title>
    <link href="https://muleimulei.github.io/2017/08/07/DataBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://muleimulei.github.io/2017/08/07/DataBase/数据库安全性/</id>
    <published>2017-08-07T11:37:04.409Z</published>
    <updated>2017-08-07T13:30:13.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据库安全性</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>数据库的特点之一是由数据库管理系统提供统一的数据保护功能来保护数据的安全可靠和正确有效。数据库的数据保护主要包括数据的安全性和完整性。</p>
</blockquote>
<p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露，更改或破坏</p>
<p>数据库的不安全因素</p>
<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄露</li>
<li>安全环境的脆弱性</li>
</ol>
<p>数据库安全性控制</p>
<ol>
<li>用户身份鉴别</li>
<li>多层存取控制</li>
<li>审计</li>
<li>视图和数据加密</li>
</ol>
<p>存取控制<br><strong>存取控制机制主要包括定义用户权限和合法权限检查两部分，定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统 </strong></p>
<blockquote>
<p>C2级的数据库管理系统支持<strong>自主存取控制</strong>，B1级的数据库管理系统支持<strong>强制存取控制</strong></p>
</blockquote>
<ol>
<li>在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其它用户。因此自主存取控制非常灵活。</li>
<li>在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具体合法许可证的用户才可以存取。强制存取控制因此相对比较严格。</li>
</ol>
<h1 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h1><p>用户权限是由两个要素组成的：数据库对象和操作类型。定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，定义存取权限称为授权。<br>在关系数据库系统中，存取控制的对象不仅有数据本身（基本表中的数据，属性列上的数据），还有数据库模式（包括数据库，基本表，视图和索引的创建等）。</p>
<h1 id="关系数据库系统中的存取权限"><a href="#关系数据库系统中的存取权限" class="headerlink" title="关系数据库系统中的存取权限"></a>关系数据库系统中的存取权限</h1><p>数据类型</p>
<ul>
<li>数据库模式<ol>
<li>模式：<code>CREATE SCHEMA</code></li>
<li>基本表：<code>CREATE TABLE, ALTER TABLE</code></li>
<li>视图：<code>CREATE VIEW</code></li>
<li>索引：<code>CREATE INDEX</code></li>
</ol>
</li>
<li>数据<ol>
<li>基本表和视图：<code>SELECT, INSERT, UPDATE, DELETE, REFERENCES, ALL PRIVILEGES</code></li>
<li>属性列：<code>SELECT, INSERT, UPDATE, REFERENCES, ALL PRIVILEGES</code></li>
</ol>
</li>
</ul>
<h1 id="授权：授予与收回"><a href="#授权：授予与收回" class="headerlink" title="授权：授予与收回"></a>授权：授予与收回</h1><ol>
<li><p>GRANT<br>GRANT语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;权限&gt;，[,&lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</div><div class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</div></pre></td></tr></table></figure>
<p>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的还可以是数据库管理员，也可以是该数据库对象创建者（即属主owner），还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，及全体用户。如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予其它的用户。如果没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(Sno), <span class="keyword">SELECT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</div><div class="line"><span class="keyword">To</span> U4</div><div class="line"></div><div class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</div><div class="line"><span class="keyword">TO</span> U5</div><div class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></div></pre></td></tr></table></figure>
</li>
<li><p>REVOKE<br>REVOKE的一般格式为；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[, &lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt;&lt;对象名&gt; [, &lt;对象类型&gt;&lt;对象名&gt;]...</div><div class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;] ... [<span class="keyword">CASCADE</span>|RESTRICT]</div><div class="line"></div><div class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</div><div class="line"><span class="keyword">FROM</span> U5 <span class="keyword">CASCADE</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>创建数据库模式的权限<br>创建数据库模式一类的数据库对象的授权则由数据库管理员在创建用户时实现，创建用户的一般合适如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &lt;username&gt; [<span class="keyword">WITH</span>] [DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>只有系统的超级用户才有权创建一个新的数据库用户</li>
<li>新创建的数据库用户有三种权限：CONNECT, RESOURCE和DBA</li>
<li>CREATE USER命令中如果没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登陆数据库。由数据库管理员或其它用户授予他应用的权限，根据获得的授权的情况他可以对数据库对象进行权限范围内的操作。</li>
<li>拥有RESOURCE权限的用户能创建基本表和视图，称为所创建对象的属主，但不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把该对象上的存取权限授予其它用户。</li>
<li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户，创建模式，创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</li>
</ul>
<ol>
<li><p>角色</p>
<ul>
<li>角色的创建：<code>CREATE ROLE &lt;角色名&gt;</code></li>
<li><p>给角色授权：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;权限&gt; [, &lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt; 对象名</div><div class="line"><span class="keyword">To</span> &lt;角色&gt; [,&lt;角色&gt;]</div></pre></td></tr></table></figure>
</li>
<li><p>将一个角色授予其它的角色或用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;角色<span class="number">1</span>&gt; [, &lt;角色<span class="number">2</span>&gt;]...</div><div class="line"><span class="keyword">To</span> &lt;角色<span class="number">3</span>&gt; [, &lt;用户<span class="number">1</span>&gt;]...</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</div></pre></td></tr></table></figure>
<p>如果指定了<code>WITH ADMIN OPTION</code>子句，则获得某种权限的角色或用户还可以把这种权限再授予其它的角色</p>
</li>
<li><p>角色权限的收回</p>
<pre><code class="sql"><span class="keyword">REVOKE</span> &lt;权限&gt; [, &lt;权限&gt;]...
<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;
<span class="keyword">FROM</span>  &lt;角色&gt; [,&lt;角色&gt;]
</code></pre>
<p>REVOKE动作的执行者或者角色的创建者，或者拥有在这个角色上的ADMIN OPTION</p>
</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据库安全性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="数据库安全性" scheme="https://muleimulei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>百度音乐API</title>
    <link href="https://muleimulei.github.io/2017/08/06/nodejs/%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90API/"/>
    <id>https://muleimulei.github.io/2017/08/06/nodejs/百度音乐API/</id>
    <published>2017-08-06T10:22:31.277Z</published>
    <updated>2017-08-06T11:42:36.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>百度音乐API</p>
</blockquote>
<a id="more"></a>
<h2 id="百度音乐全接口-会利用使用接口找歌简单又快捷-http-tingapi-ting-baidu-com-v1-restserver-ting"><a href="#百度音乐全接口-会利用使用接口找歌简单又快捷-http-tingapi-ting-baidu-com-v1-restserver-ting" class="headerlink" title="百度音乐全接口 会利用使用接口找歌简单又快捷  http://tingapi.ting.baidu.com/v1/restserver/ting "></a>百度音乐全接口 会利用使用接口找歌简单又快捷 <code> <a href="http://tingapi.ting.baidu.com/v1/restserver/ting" target="_blank" rel="external">http://tingapi.ting.baidu.com/v1/restserver/ting</a> </code></h2><p>获取方式：GET<br>参数：format=json或xml&amp;calback=&amp;from=webapp_music&amp;method=以下不同的参数获得不同的数据<br>PS：format根据开发需要可选择json或xmml，其他参数对应填入，calback是等于空的。</p>
<h1 id="一、获取列表"><a href="#一、获取列表" class="headerlink" title="一、获取列表"></a>一、获取列表</h1><p>例：method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0 </p>
<p>参数： type = 1-新歌榜,2-热歌榜,11-摇滚榜,12-爵士,16-流行,21-欧美金曲榜,22-经典老歌榜,23-情歌对唱榜,24-影视金曲榜,25-网络歌曲榜</p>
<p>size = 10 //返回条目数量</p>
<p>offset = 0 //获取偏移</p>
<h1 id="二、貌似是推广（无用）"><a href="#二、貌似是推广（无用）" class="headerlink" title="二、貌似是推广（无用）"></a>二、貌似是推广（无用）</h1><p>例：method=baidu.ting.adv.showlist&amp;_=1430215999</p>
<p>参数：_ = 1430215999//时间戳</p>
<h1 id="三、搜索"><a href="#三、搜索" class="headerlink" title="三、搜索"></a>三、搜索</h1><p>例：method=baidu.ting.search.catalogSug&amp;query=海阔天空</p>
<p>参数：query = ‘’ //搜索关键字</p>
<h1 id="四、播放"><a href="#四、播放" class="headerlink" title="四、播放"></a>四、播放</h1><p>例：method=baidu.ting.song.play&amp;songid=877578</p>
<p>例：method=baidu.ting.song.playAAC&amp;songid=877578</p>
<p>参数：songid = 877578 //歌曲id</p>
<h1 id="五、LRC歌词"><a href="#五、LRC歌词" class="headerlink" title="五、LRC歌词"></a>五、LRC歌词</h1><p>例：method=baidu.ting.song.lry&amp;songid=877578</p>
<p>参数：songid = 877578 //歌曲id</p>
<h1 id="六、推荐列表"><a href="#六、推荐列表" class="headerlink" title="六、推荐列表"></a>六、推荐列表</h1><p>例：method=baidu.ting.song.getRecommandSongList&amp;song_id=877578&amp;num=5</p>
<p>参数： song_id = 877578</p>
<p>num = 5//返回条目数量</p>
<h1 id="七、下载"><a href="#七、下载" class="headerlink" title="七、下载"></a>七、下载</h1><p>例：method=baidu.ting.song.downWeb&amp;songid=877578&amp;bit=24&amp;_t=1393123213</p>
<p>参数： songid = 877578//歌曲id</p>
<p>bit = 24, 64, 128, 192, 256, 320 ,flac//码率</p>
<p>_t = 1430215999,, //时间戳</p>
<h1 id="八、获取歌手信息"><a href="#八、获取歌手信息" class="headerlink" title="八、获取歌手信息"></a>八、获取歌手信息</h1><p>例：method=baidu.ting.artist.getInfo&amp;tinguid=877578</p>
<p>参数： tinguid = 877578 //歌手ting id</p>
<h1 id="九、获取歌手歌曲列表"><a href="#九、获取歌手歌曲列表" class="headerlink" title="九、获取歌手歌曲列表"></a>九、获取歌手歌曲列表</h1><p>例：method=baidu.ting.artist.getSongList&amp;tinguid=877578&amp;limits=6&amp;use_cluster=1&amp;order=2</p>
<p>参数： tinguid = 877578//歌手ting id</p>
<p>limits = 6//返回条目数量</p>
<p>其他就不用管了</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;百度音乐API&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Node" scheme="https://muleimulei.github.io/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库视图</title>
    <link href="https://muleimulei.github.io/2017/08/05/DataBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE/"/>
    <id>https://muleimulei.github.io/2017/08/05/DataBase/数据库视图/</id>
    <published>2017-08-05T12:27:14.469Z</published>
    <updated>2017-08-05T14:38:54.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据库视图</p>
</blockquote>
<a id="more"></a>
<p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p>
<ol>
<li><p>建立视图<br> sql语言用CREATE VIEW命令建立视图，其一般格式为：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]...)]</div><div class="line"><span class="keyword">AS</span> &lt;子查询&gt;</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</div></pre></td></tr></table></figure>
<p> 其中，子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，取决于具体系统的实现。<strong>WITH CHECK OPTION表示对视图进行UPDATE, INSERT,和DELETE操作时要保证更新，插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</strong>，组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成，但在下列情况下必须明确指定组成视图的所有列名。</p>
<p> 1) 某个目标列不是单纯的属性名，而是聚集函数或列表达式<br> 2) 多表连接时选出了几个同名列作为视图的字段<br> 3) 需要在视图中为某个列启用新的更合适的名字</p>
</li>
</ol>
<blockquote>
<p>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为<strong>行列子集视图</strong><br>还可以用带有聚集函数和group by 子句的查询来定义视图，这种视图称为<strong>分组视图</strong><br>    <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno Gavg)</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</div><div class="line"><span class="keyword">FROM</span> SC</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>删除视图<br> 语句为  <code>DROP VIEW &lt;视图名&gt; [CASCADE]</code> ，视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其它视图，则使用CASCADE级联删除语句把该视图和由它导出的所有视图一起删除。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BT_S <span class="keyword">CASCADE</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>查询视图<br> 关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表，视图等是否存在。如果存在，则从<strong>数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转化成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解</strong></p>
</li>
<li><p>更新视图<br> 更新视图是通过视图来插入（insert），删除（delete）和修改（update）数据。由于视图是不实际存储数据的虚表，因此对视图的更新最终要转化为对基本表的更新。像查询视图一样，对视图的更新操作也是通过视图消解，转化为对基本表的更新操作。<br> 为防止用户通过视图对数据进行增加，删除，修改时，有意无意地对不属于视图范围的基本表数据进行操作，可在定义视图时加上WITH CHECK OPTION子句，这样在视图上增，删，改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。</p>
</li>
<li><p>视图的作用</p>
<ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当利用视图可以更清晰地表达查询</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据库视图&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="数据库视图" scheme="https://muleimulei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>string与stringstream</title>
    <link href="https://muleimulei.github.io/2017/08/05/c%E4%B8%8Ec++/string%E4%B8%8Estringstream/"/>
    <id>https://muleimulei.github.io/2017/08/05/c与c++/string与stringstream/</id>
    <published>2017-08-05T08:05:11.302Z</published>
    <updated>2017-08-05T09:40:56.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>string与stringstream</p>
</blockquote>
<a id="more"></a>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string是c++提供的字符串型，和c的字符串相比，除了有不限长度的优点外，还有其它许多方便的功能。</p>
<p>首先加入<code>#include\<string\> </string\></code>，声明变量可以写成<code>string s;s=”hello”</code>，也可以直接设置其值<code>string s = “TCGS”</code>，如果要取得其中一个字符，和传统的c语言一样是用s[i]取得。比较不一样的是如果s有三个字符，传统c的字符s[3]是0字元，但是c++的string则是只到s[2]这个字符而已。</p>
<p>操作：</p>
<pre><code>- 声明：
    + string：string s
    + 字符阵列：char s[100]
- 取得第i个字符
    + string：s[i]
    + 字符阵列：s[i]
- 字符串长度
    + string：s.length()
    + 字符阵列：strlen(s)
- 读取一行
    + string：getline(cin, s)
    + 字符阵列：gets(s)
- 设成某字符串
    + string：s=&quot;TSS&quot;
    + 字符阵列：strcpy(s, &apos;TSS&apos;)
- 字符串相加
    + string：s = s + &apos;TSS&apos;
    + 字符阵列：strcat(s, &apos;TSS&apos;)
- 字符比较
    + string：s==&apos;TSS&apos;
    + 字符阵列：strcmp(s, &apos;TSS&apos;)
</code></pre><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>stringstream是c++提供的另一个字符串型的串流物件，要使用stringstream，必须先加入这一行：<code>#include<sstream></sstream></code>，stringstream主要是用在将一个字符串分割，可以先用clear()以及str()将指定字符串设定成一开始的内容，再用&gt;&gt;把个别的资料输出，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="built_in">stringstream</span> ss;</div><div class="line"><span class="keyword">int</span> a,b,c;</div><div class="line">getline(<span class="built_in">cin</span>, s);</div><div class="line">ss.clear();</div><div class="line">ss.str(s);</div><div class="line">ss&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div></pre></td></tr></table></figure>
<p>题目：输入的第一行有一个数字N代表接下来N行资料，每一行资料里有不固定个数的整数（最多20个，每行最大200个字符），请你写一个算法将每行的总和打印出来<br>輸入：</p>
<p>3<br>1 2 3<br>20 17 23 54 77 60<br>111 222 333 444 555 666 777 888 999</p>
<p>輸出：</p>
<p>6<br>251<br>4995</p>
<p>程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="built_in">stringstream</span> ss;</div><div class="line"><span class="keyword">int</span> n, i, sum, a;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">getline(<span class="built_in">cin</span>, s); <span class="comment">// 讀取換行</span></div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">&#123;</div><div class="line">    getline(<span class="built_in">cin</span>, s);</div><div class="line">    ss.clear();</div><div class="line">    ss.str(s);</div><div class="line">    sum=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        ss &gt;&gt; a;</div><div class="line">        <span class="keyword">if</span> ( ss.fail() ) <span class="keyword">break</span>;</div><div class="line">        sum+=a;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>常用的方法有size()，find()，substr()方法：</div><div class="line"><span class="built_in">string</span> str = <span class="string">"yutyuyuyussdfas"</span>;</div><div class="line"><span class="keyword">size_t</span> pos = str.find(<span class="string">"ssdf"</span>, <span class="number">3</span>);   <span class="comment">//用if(pos==string::npos)用来判断是否找到字符串</span></div><div class="line"><span class="built_in">string</span> str2 = str.substr(pos, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">//find函数从str的第三个位置查起，找到sddf这个字符串后，返回字符串的位置。而substr函数从pos位置开始，截取5个字符，赋给str2</span></div></pre></td></tr></table></figure>
<p>stringstream是字符串流，可以用来数据切分或者类型转化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">i2s</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len = <span class="number">0</span>)</span></span>&#123;</div><div class="line">    <span class="built_in">stringstream</span> ss;</div><div class="line">    ss &lt;&lt; setw(len) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; i;</div><div class="line">    <span class="keyword">return</span> ss.str();</div><div class="line">&#125;</div><div class="line"><span class="comment">//以i2s(7, 3)形式调用这个函数，返回的结果是字符串007</span></div></pre></td></tr></table></figure></p>
<p>string到int的转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> res = <span class="string">"1000"</span>;</div><div class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">stream&lt;&lt;result;</div><div class="line">stream&gt;&gt;n;</div></pre></td></tr></table></figure></p>
<p>在类型转化中使用模板。to_string()函数将t转化为字符串并写入result中。使用str()成员函数来获取流内部缓存的一份拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_string</span><span class="params">(<span class="built_in">string</span> &amp;result, <span class="keyword">const</span> T &amp;l)</span></span>&#123;</div><div class="line">    <span class="built_in">ostringstream</span> oss; <span class="comment">//创建一个流</span></div><div class="line">    oss&lt;&lt;t; <span class="comment">//把值传递到流中</span></div><div class="line">    result = oss.str(); <span class="comment">//获取转换后的字符并将其写入result</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">to_string(s1, <span class="number">10.5</span>); <span class="comment">//double到string</span></div><div class="line">to_string(s1, <span class="number">123</span>); <span class="comment">//int到string</span></div></pre></td></tr></table></figure>
<p>可以更进一步定义一个通用的转化模板，用于任意类型之间的转换。函数模板convert()含有两个模板参数out_type和in_type，功能是将in_value值转换成out_type类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> out_type, <span class="keyword">class</span> in_value&gt;</div><div class="line"><span class="function">out_type <span class="title">convert</span> <span class="params">(<span class="keyword">const</span> in_value &amp;t)</span></span>&#123;</div><div class="line">    <span class="built_in">stringstream</span> stream;</div><div class="line">    stream &lt;&lt; t; <span class="comment">//向流中传值</span></div><div class="line">    out_type result; <span class="comment">//这里存储转换结果</span></div><div class="line">    stream&gt;&gt;result; <span class="comment">//向result中写入值</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">double</span> d;</div><div class="line"><span class="built_in">string</span> salary;</div><div class="line"><span class="built_in">string</span> s = <span class="string">"23.323"</span>;</div><div class="line">s = convert&lt;<span class="keyword">double</span>&gt;(s);</div><div class="line">salary = convert&lt;<span class="built_in">string</span>&gt;(<span class="number">9000.0</span>);</div></pre></td></tr></table></figure>
<p>在进行多次转换的时候，必须调用stringstream的成员函数clear()函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</div><div class="line">    <span class="keyword">int</span> first, second;</div><div class="line">    stream&lt;&lt; <span class="string">"456"</span>; <span class="comment">//插入字符串</span></div><div class="line">    stream &gt;&gt; first; <span class="comment">//转换成int</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    stream.clear(); <span class="comment">//在进行多次转换前，必须清除stream</span></div><div class="line">    stream &lt;&lt; <span class="literal">true</span>; <span class="comment">//插入bool值</span></div><div class="line">    stream &gt;&gt; second; <span class="comment">//提取出int</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;string与stringstream&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="string与stringstream" scheme="https://muleimulei.github.io/tags/string%E4%B8%8Estringstream/"/>
    
  </entry>
  
  <entry>
    <title>C++的find函数</title>
    <link href="https://muleimulei.github.io/2017/08/05/c%E4%B8%8Ec++/C++%E7%9A%84find/"/>
    <id>https://muleimulei.github.io/2017/08/05/c与c++/C++的find/</id>
    <published>2017-08-05T07:43:47.952Z</published>
    <updated>2017-08-05T08:04:50.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>C++的find函数</p>
</blockquote>
<a id="more"></a>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>#include<algorithm></algorithm></p>
<p>函数实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp;val)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span> (first!=last)&#123;</div><div class="line">        <span class="keyword">if</span>(*first==val) <span class="keyword">return</span> first;</div><div class="line">        ++first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> last;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.push_back(<span class="string">"hello"</span>);</div><div class="line">    m.push_back(<span class="string">"hello2"</span>);</div><div class="line">    m.push_back(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例2<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.insert(<span class="string">"hello"</span>);</div><div class="line">    m.insert(<span class="string">"hello2"</span>);</div><div class="line">    m.insert(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>set，string自身有个find()函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.insert(<span class="string">"hello"</span>);</div><div class="line">    m.insert(<span class="string">"hello2"</span>);</div><div class="line">    m.insert(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">//find函数返回类型 size_type</span></div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i"</span>)</span></span>;  </div><div class="line">    <span class="built_in">string</span> flag;</div><div class="line">    <span class="built_in">string</span>::size_type position;</div><div class="line">    <span class="comment">//find 函数 返回jk 在s 中的下标位置   </span></div><div class="line">    position = s.find(<span class="string">"jk"</span>);  </div><div class="line">    <span class="keyword">if</span> (position != s.npos)  <span class="comment">//如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295，  </span></div><div class="line">     &#123;  </div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"position is : "</span> &lt;&lt; position &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">     &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">     &#123;  </div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found the flag"</span> + flag;  </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;C++的find函数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="C++的find函数" scheme="https://muleimulei.github.io/tags/C-%E7%9A%84find%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL数据定义语句</title>
    <link href="https://muleimulei.github.io/2017/08/04/DataBase/sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/"/>
    <id>https://muleimulei.github.io/2017/08/04/DataBase/sql数据定义语句/</id>
    <published>2017-08-04T10:35:17.613Z</published>
    <updated>2017-08-04T12:30:03.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>SQL数据定义语句</p>
</blockquote>
<a id="more"></a>
<p>关系数据库系统支持三级模式结构，其模式，外模式和内模式中的基本对象有模式，视图和索引等。因此SQL的数据定义功能包括模式定义，表定义，视图和索引的定义。</p>
<h2 id="sql的数据定义语句"><a href="#sql的数据定义语句" class="headerlink" title="sql的数据定义语句"></a>sql的数据定义语句</h2><ol>
<li>模式<ul>
<li>创建：<code>CREATE SCHEMA</code></li>
<li>删除：<code>DROP SCHEMA</code></li>
</ul>
</li>
<li>表<ul>
<li>创建：<code>CREATE TABLE</code></li>
<li>删除：<code>DROP TABLE</code></li>
<li>修改：<code>ALTER TABLE</code></li>
</ul>
</li>
<li>视图<ul>
<li>创建：<code>CREATE VIEW</code></li>
<li>删除：<code>DROP VIEW</code></li>
</ul>
</li>
<li>索引<ul>
<li>创建：<code>CREATE INDEX</code></li>
<li>删除：<code>DROP INDEX</code></li>
<li>修改：<code>ALTER INDEX</code></li>
</ul>
</li>
</ol>
<p><strong>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表，视图和索引等数据库对象。</strong></p>
<h1 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h1><ol>
<li><p>定义模式<br> <code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;<code>，如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;。要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的<code>CREATE SCHEMA<code>的权限。目前，在<code>CREATE SCHEMA<code>中可以接受<code>CREATE TABLE<code>，<code>CREATE VIEW<code>和<code>GRANT<code>，也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表，视图，定义授权。即：<code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [ &lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt; ]<code>;</code></code></code></code></code></code></code></code></code></code></code></code></code></code></p>
</li>
<li><p>删除模式<br> <code>DROP SCHEMA &lt;模式名&gt; <cascade |="" rrestrict=""></cascade></code>，其中cascade和restrict两者必选其一。选择了cascade（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict（限制），表示如果该模式中已经定义了下属的数据库对象（如表，视图等），则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行drop schema语句。</p>
</li>
</ol>
<h1 id="基本表的定义，删除与修改"><a href="#基本表的定义，删除与修改" class="headerlink" title="基本表的定义，删除与修改"></a>基本表的定义，删除与修改</h1><ol>
<li><p>定义基本表<br> 创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语句使用<code>CREATE TABLE</code>语句定义基本表，其基本格式为：</p>
<p> <code></code></p>
<pre><code>CREATE TABLE &lt;表名&gt; (&lt;列名&gt;&lt;数据类型&gt; [列级完整性约束条件]
                    [,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]])
                    ...........
                    [,&lt;表级完整性约束条件&gt;]
</code></pre><p> </p>
<p> 建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。<strong> 如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级 </strong></p>
<p> <code></code></p>
<pre><code>CREATE TABLE SC
(
    Sno CHAR(9),
    Cno CHAR(4),
    Grade SMALLINT,
    PRIMARY KEY (Sno, Cno),  /* 主码由两个属性构成，必须作为表级完整性进行定义 */
    FOREIGN KEY (Sno) REFERENCES Student (Sno), /* 表级完整性约束条件，Sno是外码，被参照表是Student */
    FOREIGN KEY (Cno) REFERENCES Course (Cno) /* 表级完整性约束条件，Cno是外码，被参照表是Course */
)
</code></pre><p> </p>
</li>
<li><p>数据类型</p>
<ul>
<li>CHAR(N)，CHARACTER(N)：长度为n的定长字符串</li>
<li>VARCHAR(N)：最大长度为n的变长字符串</li>
<li>CLOB：字符串大对象</li>
<li>BLOB：二进制大对象</li>
<li>INT，INTEGER：长整数（4字节）</li>
<li>SMALLINT：短整形（2字节）</li>
<li>BIGINT：大整形(8整数)</li>
<li>NUMERIC(p,d)：定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字</li>
<li>DECIMAL(p,d)：同NUMERIC</li>
<li>REAL：取决于机器精度的单精度浮点数</li>
<li>DOUBLE PRECISION：取决于机器精度的双精度浮点数</li>
<li>FLOAT(n)：可选精度的浮点数，精度至少为n位数字</li>
<li>BOOLEAN：逻辑布尔值</li>
<li>DATE：日期，包含年，月，日，格式为yyyy-mm-dd</li>
<li>TIME：时间，包含一日的时，分，秒，格式为HH:MM:SS</li>
<li>TIMESTAMP：时间戳类型</li>
<li>INTERVAL：时间间隔类型</li>
</ul>
</li>
<li><p>修改基本表<br> <code></code></p>
<pre><code>ALTER TABLE &lt;表名&gt;
[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]]
[ADD &lt;表级完整性约束&gt;]
[DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]]
[DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT|CASCADE]]
[ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]
</code></pre><p> </p>
</li>
<li><p>删除基本表<br> <code>DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</code>。</p>
</li>
</ol>
<h1 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h1><ol>
<li><p>建立索引<br> <code></code></p>
<pre><code>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;
ON &lt;表名&gt;(&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt; [&lt;次序&gt;]] ...)
</code></pre><p> </p>
<ul>
<li>UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录</li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
</li>
<li><p>修改索引<br> <code> ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</code></p>
</li>
<li><p>删除索引<br> <code>DROP INDEX &lt;索引名&gt;</code></p>
</li>
</ol>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p><code><br>    SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [, &lt;目标列表达式&gt;] …<br>    FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;] | (<select 语句="">) [AS] &lt;别名&gt;<br>    [WHERE &lt;条件表达式&gt;]<br>    [GROUP BY &lt;列名 1&gt; [HAVING &lt;条件表达式&gt;]]<br>    [ORDER BY &lt;列名 2&gt; [ASC|DESC]]<br></select></code></p>
<blockquote>
<p>%（百分号）：代表任意长度（长度可以为0）的字符串。<br>_(下横线)：代表任意单个字符</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;SQL数据定义语句&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="SQL数据定义语句" scheme="https://muleimulei.github.io/tags/SQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>关系的完整性</title>
    <link href="https://muleimulei.github.io/2017/08/03/DataBase/%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <id>https://muleimulei.github.io/2017/08/03/DataBase/关系的完整性/</id>
    <published>2017-08-03T07:11:26.020Z</published>
    <updated>2017-08-03T08:07:16.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>关系的完整性</p>
</blockquote>
<a id="more"></a>
<p>关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时因该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。</p>
<p><strong> 关系模型中有三类完整性约束：实体完整性，参照完整性和用户定义的完整性 </strong>。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称为关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。</p>
<ol>
<li><p>实体完整性<br>实体完整性规则：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（null value）。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p>实体完整性规则说明如下：</p>
<ol>
<li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li>
<li>现实世界中的实体是可区分的，即他们具有某种唯一性标识。</li>
<li>相应的，关系模型中以主码作为唯一性标识。</li>
<li>主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的主体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性。</li>
</ol>
</li>
</ol>
<blockquote>
<p>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。关系R和S不一定是不同的关系。</p>
</blockquote>
<ol>
<li>参照完整性<br>若属性（属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R与S不一定是不同的关系），则对于R中的每个元组在F上的值必须：<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值。</li>
</ul>
</li>
</ol>
<ol>
<li>用户定义的完整性<br> 任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反应某一具体应用所涉及的数据必须满足的语义要求。<strong> 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需要由应用程序承担这一功能 </strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;关系的完整性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="关系的完整性" scheme="https://muleimulei.github.io/tags/%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>module的加载实现</title>
    <link href="https://muleimulei.github.io/2017/07/31/JavaScript/module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>https://muleimulei.github.io/2017/07/31/JavaScript/module的加载实现/</id>
    <published>2017-07-31T07:37:28.196Z</published>
    <updated>2017-08-03T07:10:50.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>module的加载实现</p>
</blockquote>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><ol>
<li>传统方法</li>
</ol>
<p>在HTML网页中，浏览器通过<code>script</code>标签加载JavaScript脚本<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">//module code</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/JavaScript"</span> <span class="attr">src</span>=<span class="string">"path/to/Module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，由于浏览器的脚本的默认语言是JavaScript，因此<code> type=”application/javascript” </code>可以省略。</p>
<p>默认情况下，浏览器同步加载JavaScript脚本，即渲染引擎遇到script标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>下面有两种异步加载的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"mymodule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"mymodule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>上面代码中，script标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一命令，就会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。</p>
<blockquote>
<p>defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
</blockquote>
<ol>
<li>加载规则</li>
</ol>
<p>浏览器加载ES6模块，也使用script标签，但要加入type=”module”属性。<br><code> <script type="module" src="foo.js"></script> </code>上面代码在网页插入foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。</p>
<p>浏览器对于带有type=”module”的script，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，在执行模块脚本，等同于打开了script标签的defer属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;!-- 等同于 --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>script标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，在恢复渲染。<br><code> <script type="module" src="foo.js" async></script> </code><br>ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span>&gt;</div><div class="line">    <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./util.js'</span></div><div class="line">    <span class="comment">// other code</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>对于外部的模块的脚本，有几点注意。</p>
<blockquote>
<ol>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code></li>
<li>模块之中，可以使用import命令加载其它模块(<strong> .js后缀不可省略，需要提供绝对url与相对url </strong>)，也可以使用export命令输出绝对接口。</li>
<li>模块之中，顶层的this关键字返回undefined，而不是window。也就是说，在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// 句法错误，严格模式禁止删除变量</span></div></pre></td></tr></table></figure>
<p><strong> 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在es6模块之中 </strong></p>
<p><code>const isNotModuleScript = this !== undefined</code></p>
<ol>
<li>ES6模块与CommonJs模块的差异</li>
</ol>
<p>它们有两个重大差异</p>
<ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用。</li>
<li>CommonJs 模块是运行时加载，ES6模块是编译时输出接口</li>
</ul>
<p>第二个差异是因为CommonJs加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">counter</span>: counter,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div><div class="line">上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</div><div class="line"></div><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  get counter() &#123;</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
</blockquote>
<p>export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mod.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</div></pre></td></tr></table></figure></p>
<p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// x.js</div><div class="line">import &#123;c&#125; from &apos;./mod&apos;;</div><div class="line">c.add();</div><div class="line"></div><div class="line">// y.js</div><div class="line">import &#123;c&#125; from &apos;./mod&apos;;</div><div class="line">c.show();</div><div class="line"></div><div class="line">// main.js</div><div class="line">import &apos;./x&apos;;</div><div class="line">import &apos;./y&apos;;</div><div class="line">现在执行main.js，输出的是1。</div><div class="line"></div><div class="line">$ babel-node main.js</div><div class="line">1</div></pre></td></tr></table></figure>
<p>这就证明了x.js和y.js加载的都是C的同一个实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;module的加载实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器加载&quot;&gt;&lt;a href=&quot;#浏览器加载&quot; class=&quot;headerlink&quot; title=&quot;浏览器加载&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="HTML5" scheme="https://muleimulei.github.io/tags/HTML5/"/>
    
  </entry>
  
</feed>
