<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风的影子</title>
  <subtitle>小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muleimulei.github.io/"/>
  <updated>2017-04-04T15:55:11.252Z</updated>
  <id>https://muleimulei.github.io/</id>
  
  <author>
    <name>穆蕾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间片轮转与高响应比优先算法</title>
    <link href="https://muleimulei.github.io/2017/04/02/OS/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E4%B8%8E%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>https://muleimulei.github.io/2017/04/02/OS/时间片轮转与高响应比优先调度算法/</id>
    <published>2017-04-02T14:53:13.349Z</published>
    <updated>2017-04-04T15:55:11.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>时间片轮转与高响应比优先算法</p>
</blockquote>
<a id="more"></a>
<h1 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h1><h4 id="轮转法的基本原理"><a href="#轮转法的基本原理" class="headerlink" title="轮转法的基本原理"></a>轮转法的基本原理</h4><hr>
<blockquote>
<p>在轮转(RR)法中，系统根据FCFS策略，将所有的就绪队列排成一个就绪队列，并可设置一定时间间隔（如30ms）产生一次终断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，另其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程），由此，可保证就绪队列中的所有进程在一个确定的时间片内，都能获得一次CPU执行。</p>
</blockquote>
<h4 id="进程切换时机"><a href="#进程切换时机" class="headerlink" title="进程切换时机"></a>进程切换时机</h4><hr>
<h6 id="在RR调度算法中，应在何事进行进程的切换，可分为两种情况："><a href="#在RR调度算法中，应在何事进行进程的切换，可分为两种情况：" class="headerlink" title="在RR调度算法中，应在何事进行进程的切换，可分为两种情况："></a>在RR调度算法中，应在何事进行进程的切换，可分为两种情况：</h6><ol>
<li><p>若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将他从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 </p>
</li>
<li><p>在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序就把他送往就绪队列的尾部。</p>
</li>
</ol>
<h4 id="时间片大小确定"><a href="#时间片大小确定" class="headerlink" title="时间片大小确定"></a>时间片大小确定</h4><hr>
<p>如果选择的时间片小，将有利于短作业，因为它能在该时间片内完成。但时间片小，意味着会进行频繁的进程调度和进程上下文的切换，无疑会增加系统的开销。反之，若时间片选择得太长，且为使每个进程都能在一个时间片内完成。RR算法便会退化成FCFS算法，无法满足短作业和交互式用户的需求。<strong> 一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成</strong></p>
<h1 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h1><p>高响应比优先调度算法为每一个作业引入一个动态优先级，即优先级是可以改变的，令他随等待时间延长而增加，这将使长作业的优先级在等待期间不断的增加，等到足够的时间后，必然会有机会获得处理机。该优先级变化规律为：</p>
<center> <strong> 优先级 = (等待时间+要求服务时间)/要求服务时间 </strong> </center>

<p>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比R<sub>p</sub>。优先级又可表示为：</p>
<center> <strong> 优先级 = (等待时间+要求服务时间)/要求服务时间 = 响应时间/要求服务时间 </strong> </center>

<h6 id="由上式可以看出"><a href="#由上式可以看出" class="headerlink" title="由上式可以看出"></a>由上式可以看出</h6><ol>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先级愈高，因而类似于SJF算法，有利于短作业。</li>
<li>当要求服务的的时间相同时，作业的优先级又取决于其等待时间，因而又类似于FCFS算法。</li>
<li>对于长作业的优先级，可以随等待时间的增加而增大，当其等待时间足够长时，也可获得处理机。</li>
<li>在每次进行调度前，都需要进行响应比的计算，显然会增加系统开销。</li>
</ol>
<p>两种算法代码实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line">//进程类</div><div class="line">function Process()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Process.list = []; //进程列表</div><div class="line">Process.task_num = 5;//进程数</div><div class="line">Process.regetRatioAndGetProcess = function(list)&#123; //获得响应比</div><div class="line">    list.forEach(function(item)&#123;</div><div class="line">        item.ratio = ((Date.parse(new Date()) - item.arriveTime) / item.runTime) +1;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    var maxRatio = 0,NO = -1;</div><div class="line">    list.forEach(function(item,index)&#123;</div><div class="line">        if(item.ratio&gt;maxRatio)&#123;</div><div class="line">            maxRatio = item.ratio;</div><div class="line">            NO = index;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return list.splice(NO,1)[0];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Process.init = function()&#123;</div><div class="line">    Process.list.splice(0,Process.list.length);</div><div class="line">    for(var i = 0;i&lt;Process.task_num;i++)&#123;</div><div class="line">        Process.list.push(&#123;</div><div class="line">            id: i,//进程号</div><div class="line">            arriveTime: 0, //进程到达时间</div><div class="line">            ratio: 0, //响应比</div><div class="line">            runTime: (Math.floor(Math.random()*4)+2)*1000, //运行时间间隔为[2,6]s</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//-----------------------------------------------------------</div><div class="line">//高响应比优先调度算法</div><div class="line">var HRRN = &#123;</div><div class="line">    list:[], //记录进程响应时间</div><div class="line">    init_task: function(list,num)&#123;</div><div class="line">        list.forEach(function(item)&#123;</div><div class="line">            item.arriveTime = Date.parse(new Date());</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    run: function(list,num)&#123;</div><div class="line">        for(var i = 0;i&lt;num;i++)&#123;</div><div class="line">            var runItem = Process.regetRatioAndGetProcess(list);</div><div class="line">            console.log(`第$&#123;runItem.id&#125;号进程开始运行：$&#123;new Date()&#125;`);</div><div class="line">            var t = Date.parse(new Date());</div><div class="line">            var exit = t + runItem.runTime;</div><div class="line">            while(true)&#123;</div><div class="line">                if(Date.parse(new Date()) &gt;=exit)&#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            console.log(`第$&#123;runItem.id&#125;号进程结束运行：$&#123;new Date()&#125;`);</div><div class="line">            HRRN.list.push(&#123;</div><div class="line">                id: runItem.id,</div><div class="line">                responseTime: Date.parse(new Date()) - runItem.arriveTime</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    show:function()&#123;</div><div class="line">        var total = 0;</div><div class="line">        HRRN.list.forEach(function(item)&#123;</div><div class="line">            console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`);</div><div class="line">            total+=Math.floor(item.responseTime);</div><div class="line">        &#125;);</div><div class="line">        console.log(`平均周转周期为$&#123;Math.floor(total/HRRN.list.length)/1000&#125;s`);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Process.init();</div><div class="line">HRRN.init_task(Process.list,Process.task_num);</div><div class="line">HRRN.run(Process.list,Process.task_num);</div><div class="line">HRRN.show();</div><div class="line"></div><div class="line">//---------------------------------------------------------------</div><div class="line">//时间片轮转算法</div><div class="line">var RR = &#123;</div><div class="line">    circle_size:4000,//时间片大小</div><div class="line">    list:[], //记录进程执行时间</div><div class="line">    init_task:function(list)&#123;</div><div class="line">        list.forEach(function(item)&#123;</div><div class="line">            item.arriveTime = Date.parse(new Date());</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    run:function(list)&#123;</div><div class="line">        while(true)&#123;</div><div class="line">            if(list.length===0) break;</div><div class="line">            var item = list.splice(0,1)[0];</div><div class="line">            var runTime = item.runTime;</div><div class="line">            var id = item.id;</div><div class="line">            console.log(`第$&#123;id&#125;号进程开始运行 :$&#123;new Date()&#125;`);</div><div class="line">            if(runTime&lt;RR.circle_size)&#123; //如果能够在本时间片内运行完</div><div class="line">                var exit = Date.parse(new Date()) + runTime;</div><div class="line">                while((Date.parse(new Date()))&lt; exit);</div><div class="line">                console.log(`第$&#123;id&#125;号进程结束运行,运行时间为$&#123;runTime/1000&#125;s :$&#123;new Date()&#125;`);</div><div class="line">                RR.list.push(&#123;</div><div class="line">                    id: item.id,</div><div class="line">                    responseTime: Date.parse(new Date()) - item.arriveTime</div><div class="line">                &#125;);</div><div class="line">            &#125;else&#123;</div><div class="line">                item.runTime -= RR.circle_size;</div><div class="line">                list.push(item);</div><div class="line">                var exit = Date.parse(new Date()) + RR.circle_size;</div><div class="line">                while((Date.parse(new Date()))&lt; exit);</div><div class="line">                console.log(`$&#123;new Date()&#125;:第$&#123;id&#125;号进程时间片用完，处于等待状态`);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    show:function()&#123;</div><div class="line">        var total = 0;</div><div class="line">        RR.list.forEach(function(item)&#123;</div><div class="line">            console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`);</div><div class="line">            total+=Math.floor(item.responseTime);</div><div class="line">        &#125;);</div><div class="line">        console.log(`平均周转周期为$&#123;Math.floor(total/RR.list.length)/1000&#125;s`);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Process.init();</div><div class="line">RR.init_task(Process.list);</div><div class="line">RR.run(Process.list);</div><div class="line">RR.show();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;时间片轮转与高响应比优先算法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://muleimulei.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>JQuery的Deferred对象详解</title>
    <link href="https://muleimulei.github.io/2017/04/02/JavaScript/jquery%E7%9A%84Deferred%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>https://muleimulei.github.io/2017/04/02/JavaScript/jquery的Deferred对象详解/</id>
    <published>2017-04-02T10:24:29.261Z</published>
    <updated>2017-04-02T15:22:10.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>JQuery的Deferred对象就是Jquery的回调函数的解决方案</p>
</blockquote>
<a id="more"></a>
<p>在我们开发网站的过程中，我们经常会遇到很长的JavaScript操作。其中，既有异步的操作，如ajax读取服务器的数据，也有异步的操作，如遍历一个大型数组，他们都不是能立即返回结果的。通常的做法是，为他们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。简单地说，Deferred对象就是JQuery的回调函数的解决方案。在英语中，defer的意思是“延迟”，所以Deferred对象的含义是延迟到未来的某个点在执行。</p>
<h3 id="ajax的链式写法"><a href="#ajax的链式写法" class="headerlink" title="ajax的链式写法"></a>ajax的链式写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'test.html'</span>,</div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">'ok'</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">'fail'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调方法，error方法指定操作失败后的回调函数。</p>
<p>$.ajax()操作完成后，如果使用的是低于1.5.0版本的JQuery，返回的是XHR对象，没法进行链式操作；如果高于1.5.0版本，返回的是Deferred对象，可以进行链式操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">'text.html'</span>)</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'ok'</span>);    </div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="指定同一操作的多个回调函数"><a href="#指定同一操作的多个回调函数" class="headerlink" title="指定同一操作的多个回调函数"></a>指定同一操作的多个回调函数</h3><p>Deferred对象的一大好处是允许你自由添加多个回调函数。<br>还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，还想再运行一个回调函数。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">'test.html'</span>)</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'ok'</span>);</div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>)</div><div class="line">&#125;)</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'第二个回调'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>回调函数可以添加任意多个，它们按添加顺序执行</p>
<h3 id="为多个操作指定回调函数"><a href="#为多个操作指定回调函数" class="headerlink" title="为多个操作指定回调函数"></a>为多个操作指定回调函数</h3><p>Deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。此时用到一个新的方法：<code>$.when()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.when($.ajax(<span class="string">'test1.html'</span>),$.ajax(<span class="string">'test2.html'</span>))</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'ok'</span>)  </div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码的意思是，先执行两个操作$.ajax()操作，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p>
<h3 id="普通函数的回调函数接口（上）"><a href="#普通函数的回调函数接口（上）" class="headerlink" title="普通函数的回调函数接口（上）"></a>普通函数的回调函数接口（上）</h3><p>Deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作（不管是ajax操作还是本地操作，也不管是异步操作还是同步操作，都可以使用Deferred对象的各种方法，指定回调函数）。</p>
<p>来看一个具体的例子。假如有一个很耗时的操作wait:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">'执行完毕'</span>);</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks,<span class="number">5000</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>为它指定回调函数，应该怎么做呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.when(wait())</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'haha'</span>);</div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是Deferred对象，所以必须对wait()改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//新建一个Deferred对象</span></div><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">'执行完毕'</span>);</div><div class="line">        dtd.resolve();</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks,<span class="number">5000</span>);</div><div class="line">    <span class="keyword">return</span> dtd;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，wait()函数返回的是Deferred对象，这样就可以加上链式操作了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.when(wait(dtd))</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'haha'</span>);</div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>wait()函数运行完，就会自动运行done()方法指定的回调函数。</p>
<h3 id="deferred-resolve-方法和deferred-reject-方法"><a href="#deferred-resolve-方法和deferred-reject-方法" class="headerlink" title="deferred.resolve()方法和deferred.reject()方法"></a>deferred.resolve()方法和deferred.reject()方法</h3><p>JQuery规定，Deferred对象有三种执行状态:未完成，已完成和已失败。如果执行状态是“已完成”(resolved)，Deferred对象立即调用done()方法指定的回调函数；如果执行状态是“已失败”(rejected)，调用fail()方法指定的回调函数；如果执行状态是“未完成”(pending)，调用progress()方法指定的回调函数。</p>
<p>前面部分的ajax操作，Deferred对象会根据返回结果，自动改变自身的执行状态；但在wait()函数中，这个状态必须有程序员手动指定。dtd.resolve()的意思是，将Deferred对象的执行状态从“未完成”改为<strong>“已完成”</strong>，从而触发done()方法。类似的，还存在一个deferred.reject()方法，作用是将Deferred对象的执行状态从“未完成”改为<strong>“已失败”</strong>，从而触发fail()方法。</p>
<h3 id="Deferred对象的promise-方法"><a href="#Deferred对象的promise-方法" class="headerlink" title="Deferred对象的promise()方法"></a>Deferred对象的promise()方法</h3><p>上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。<br>看如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">//新建一个Deferred对象</span></div><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">'执行完毕'</span>);</div><div class="line">        dtd.resolve();</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks,<span class="number">5000</span>);</div><div class="line">    <span class="keyword">return</span> dtd;</div><div class="line">&#125;;</div><div class="line">$.when(wait(dtd))</div><div class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'haha'</span>);</div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'fail'</span>);</div><div class="line">&#125;);</div><div class="line">dtd.resolve();</div></pre></td></tr></table></figure></p>
<p>在其尾部添加一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立即执行，先跳出“haha”,然后5秒后在跳出”执行完毕”的提示框。<br>为了避免这种情况，JQuery提供了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```JavaScript</div><div class="line">    var dtd = $.Deferred(); // 新建一个Deferred对象</div><div class="line">　　var wait = function(dtd)&#123;</div><div class="line">　　　　var tasks = function()&#123;</div><div class="line">　　　　　　alert(&quot;执行完毕！&quot;);</div><div class="line">　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</div><div class="line">　　　　&#125;;</div><div class="line">　　　　setTimeout(tasks,5000);</div><div class="line">　　　　return dtd.promise(); // 返回promise对象</div><div class="line">　　&#125;;</div><div class="line">　　var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作</div><div class="line">　　$.when(d)</div><div class="line">　　.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;)</div><div class="line">　　.fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);</div><div class="line">　　d.resolve(); // 此时，这个语句是无效的</div></pre></td></tr></table></figure></p>
<p>在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定到这个对象上，而不是原来的Deferred对象。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的Deferred对象。</p>
<p>不过最好的写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">// 新建一个Deferred对象</span></div><div class="line">　　　　<span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(<span class="string">"执行完毕！"</span>);</div><div class="line">　　　　　　dtd.resolve(); <span class="comment">// 改变Deferred对象的执行状态</span></div><div class="line">　　　　&#125;;</div><div class="line">　　　　setTimeout(tasks,<span class="number">5000</span>);</div><div class="line">　　　　<span class="keyword">return</span> dtd.promise(); <span class="comment">// 返回promise对象</span></div><div class="line">　　&#125;;</div><div class="line">　　<span class="keyword">var</span> d = wait(dtd); <span class="comment">// 新建一个d对象，改为对这个对象进行操作</span></div><div class="line">　　$.when(d)</div><div class="line">　　.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"哈哈，成功了！"</span>); &#125;)</div><div class="line">　　.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"出错啦！"</span>); &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Deferred对象的方法"><a href="#Deferred对象的方法" class="headerlink" title="Deferred对象的方法"></a>Deferred对象的方法</h3><ul>
<li>$.Deferred() 生成一个Deferred对象</li>
<li>deferred.progress() 该方法用于指定deferred对象状态为等待中的回调函数。但是她仅在deferred对象生成了进度通知时才会被调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">// 新建一个deferred对象    </span></div><div class="line">    <span class="keyword">var</span> i = <span class="number">1</span>,</div><div class="line">        timer,</div><div class="line">        percent; <span class="comment">// 记录进度</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">11</span>) &#123;</div><div class="line">            alert(<span class="string">"执行完毕！"</span>);</div><div class="line">            dtd.resolve(); <span class="comment">// 此操作完成后改变deferred对象的执行状态</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            percent = (i * <span class="number">500</span>) / <span class="number">5000</span> * <span class="number">100</span> + <span class="string">'%'</span>;</div><div class="line">            dtd.notify(percent); <span class="comment">// 调用progress回调</span></div><div class="line">            i++;</div><div class="line">            setTimeout(tasks, <span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks, <span class="number">1000</span>);</div><div class="line">    <span class="keyword">return</span> dtd;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 绑定回调函数</span></div><div class="line">$.when(wait())</div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"执行成功了！"</span>);</div><div class="line">    &#125;)</div><div class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"出错啦！"</span>);</div><div class="line">    &#125;)</div><div class="line">    .progress(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行中,已完成'</span>, data);</div><div class="line">    &#125;);</div><div class="line"><span class="comment">// 执行中,已完成 10%</span></div><div class="line"><span class="comment">// 执行中,已完成 20%</span></div><div class="line"><span class="comment">// 执行中,已完成 30%</span></div><div class="line"><span class="comment">// 执行中,已完成 40%</span></div><div class="line"><span class="comment">// 执行中,已完成 50%</span></div><div class="line"><span class="comment">// 执行中,已完成 60%</span></div><div class="line"><span class="comment">// 执行中,已完成 70%</span></div><div class="line"><span class="comment">// 执行中,已完成 80%</span></div><div class="line"><span class="comment">// 执行中,已完成 90%</span></div><div class="line"><span class="comment">// 执行中,已完成 100%</span></div><div class="line"><span class="comment">// 之后弹出 执行完毕！和 执行成功了！</span></div></pre></td></tr></table></figure>
<blockquote>
<p>jQuery3.0以上版本对when方法做了大幅调整。向promise/A+靠齐，上面的写法中notify是触发不了when中的progress回调的，需要使用promise来给对象部署deferred接口或使用$.Deferred()传入函数名。</p>
</blockquote>
<ol>
<li>promise 给一个对象部署Deferred接口</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">// 新建一个deferred对象</span></div><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">1</span>,</div><div class="line">        timer,</div><div class="line">        percent; <span class="comment">// 记录进度</span></div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">11</span>) &#123;</div><div class="line">            alert(<span class="string">"执行完毕！"</span>);</div><div class="line">            dtd.resolve(); <span class="comment">// 此操作完成后改变deferred对象的执行状态</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            percent = (i * <span class="number">500</span>) / <span class="number">5000</span> * <span class="number">100</span> + <span class="string">'%'</span>;</div><div class="line">            dtd.notify(percent); <span class="comment">// 调用progress回调</span></div><div class="line">            i++;</div><div class="line">            setTimeout(tasks, <span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks, <span class="number">1000</span>);        </div><div class="line">&#125;;</div><div class="line"><span class="comment">// 在wait对象上部署Deferred接口，此后就可以直接在wait上使用deferred对象promise后的方法了</span></div><div class="line">dtd.promise(wait);</div><div class="line"><span class="comment">// 在wait对象上使用deferred对象的方法指定回调。</span></div><div class="line">wait.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"执行成功了！"</span>);</div><div class="line">&#125;)</div><div class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"出错啦！"</span>);</div><div class="line">&#125;)</div><div class="line">.progress(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'执行中,已完成'</span>, data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 执行</span></div><div class="line">wait(dtd);</div></pre></td></tr></table></figure>
<ol>
<li>使用$.Deferred传入函数名：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span>(<span class="params">dtd</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">1</span>,</div><div class="line">        timer,</div><div class="line">        percent; <span class="comment">// 记录进度</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">11</span>) &#123;</div><div class="line">            alert(<span class="string">"执行完毕！"</span>);</div><div class="line">            dtd.resolve(); <span class="comment">// 此操作完成后改变deferred对象的执行状态</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            percent = (i * <span class="number">500</span>) / <span class="number">5000</span> * <span class="number">100</span> + <span class="string">'%'</span>;</div><div class="line">            dtd.notify(percent); <span class="comment">// 调用progress回调</span></div><div class="line">            i++;</div><div class="line">            setTimeout(tasks, <span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    setTimeout(tasks, <span class="number">1000</span>);</div><div class="line">    <span class="keyword">return</span> dtd;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 绑定回调函数</span></div><div class="line">$.Deferred(wait)  <span class="comment">//$.Deferred()的返回值将作为wait函数的参数</span></div><div class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"执行成功了！"</span>);</div><div class="line">    &#125;)</div><div class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"出错啦！"</span>);</div><div class="line">    &#125;)</div><div class="line">    .progress(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行中,已完成'</span>, data);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ul>
<li>deferred.done() 指定操作成功时的回调函数</li>
<li>deferred.fail() 指定操作失败时的回调函数</li>
<li>deferred.promise() 没有参数时，返回一个新的Deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。</li>
<li>deferred.resolve() 手动改变deferred对象的运行状态为“已完成”，从而触发done()方法。</li>
<li>deferred.always() 不管Deferred对象如何，总是执行。</li>
<li>deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将Deferred对象的运行状态变为“已失败”，从而立即触发fail()方法。</li>
<li>$.when() 为多个操作指定回调函数。</li>
<li>deferred.then() 有时为了省事，可以把done()和fail()合写在一起，这就是then()方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$.when($.ajax(<span class="string">'test.html'</span>))</div><div class="line">    .then(successFunc,failureFunc);</div></pre></td></tr></table></figure>
<p>如果then()有两个参数，那么第一个参数时done()方法的回调函数。如果then()只有一个参数，那么等同于done()。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;JQuery的Deferred对象就是Jquery的回调函数的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="JQuery" scheme="https://muleimulei.github.io/tags/JQuery/"/>
    
      <category term="Deferred" scheme="https://muleimulei.github.io/tags/Deferred/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript函数柯里化</title>
    <link href="https://muleimulei.github.io/2017/03/22/JavaScript/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://muleimulei.github.io/2017/03/22/JavaScript/函数柯里化/</id>
    <published>2017-03-21T16:34:44.227Z</published>
    <updated>2017-04-02T15:21:04.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>什么是函数柯里化</p>
</blockquote>
<a id="more"></a>
<p>柯里化（Curring）,又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p>
<h2 id="柯里化特点"><a href="#柯里化特点" class="headerlink" title="柯里化特点"></a>柯里化特点</h2><blockquote>
<ul>
<li>接受单一参数，将更多的参数通过回调函数来解决。</li>
<li>返回一个新的函数，用于处理所有的想要传入的参数。</li>
<li>需要利用call/apply与arguments伪数组收集参数。</li>
<li>返回的函数正是用来处理收集起来的参数。</li>
</ul>
</blockquote>
<h3 id="需要理解JavaScript函数的隐式转换"><a href="#需要理解JavaScript函数的隐式转换" class="headerlink" title="需要理解JavaScript函数的隐式转换"></a>需要理解JavaScript函数的隐式转换</h3><p>JavaScript是一种弱类型语言，它的隐式转换是非常灵活的。<br>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fn+<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>试着运行一下你会发现答案为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;<span class="number">10</span></div></pre></td></tr></table></figure></p>
<p>接着我们在修改代码为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fn+<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>你会发现答案为：20，接着我们在进行修改<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fn+<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>答案为30</p>
<p>当我们使用console.log()或者进行运算时，隐式转换就可能会发生。从上面的例子我们可以得到如下结论：</p>
<blockquote>
<p>当我们没有重新定义toString()与valueOf时，函数的隐式转换会调用默认的toString方法，他会将函数的定义内容转化为字符串返回。当我们主动定义了toString()/valueOf时，那么隐式转化的返回结果则由我们自己控制了。其中valueOf的优先级会比toString()高。</p>
</blockquote>
<h3 id="需要知道如何利用call-apply封装数组的map方法"><a href="#需要知道如何利用call-apply封装数组的map方法" class="headerlink" title="需要知道如何利用call/apply封装数组的map方法"></a>需要知道如何利用call/apply封装数组的map方法</h3><blockquote>
<p>map:对数组的每一项运行给定的函数，将每次函数调用返回的结果组成新的数组。</p>
</blockquote>
<p>具体实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">fn,ctx</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> list = <span class="keyword">this</span>,</div><div class="line">        temp = []; <span class="comment">//用来存储返回的新值</span></div><div class="line">        <span class="built_in">console</span>.log(list);</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fn ==<span class="string">'function'</span>)&#123;</div><div class="line">        <span class="comment">//遍历数组的每一项</span></div><div class="line">        list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</div><div class="line">            temp.push(fn.call(ctx,item,index));</div><div class="line">        &#125;);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.err(<span class="string">'TypeError:'</span>+fn+<span class="string">' must be a function'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]._map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item + index;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(arr);</div></pre></td></tr></table></figure></p>
<h3 id="理解函数柯里化"><a href="#理解函数柯里化" class="headerlink" title="理解函数柯里化"></a>理解函数柯里化</h3><blockquote>
<p>考虑实现一个add方法，使结果能够满足如下预期：<br>add(1)(2) = 3<br>add(1,2,3)(4) = 10<br>add(1)(2)(3)(4)(5) = 15</p>
</blockquote>
<p>一开始如果只有两个参数，你可能会这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有三个的话，可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> a+b+c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有n个呢，难道要一直嵌套下去，而且2,3种情况也没有覆盖到。所以，要利用函数柯里化，利用闭包的特性，将所有参数，集中到最后的返回函数里进行计算并返回结果。因此，我们在写代码时，要将所有的参数集中起来处理。<br>具体实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">rest</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    rest.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">return</span> sum+=item;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">...rest</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _args = rest;</div><div class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>)</span>&#123;</div><div class="line">        [].push.apply(_args, rest);</div><div class="line">        <span class="keyword">return</span> _adder;</div><div class="line">    &#125;</div><div class="line">    _adder.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="keyword">return</span> getSum(_args);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _adder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="我们再来考虑函数柯里化的例子"><a href="#我们再来考虑函数柯里化的例子" class="headerlink" title="我们再来考虑函数柯里化的例子"></a>我们再来考虑函数柯里化的例子</h3><blockquote>
<p>假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连接起来。我们该怎么做？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">chars</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(chars);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> str = arr.merge(<span class="string">'-'</span>);</div><div class="line"><span class="built_in">console</span>.log(str);</div></pre></td></tr></table></figure>
<blockquote>
<p>在考虑将数组每一位加一位数在连接起来</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">chars,number</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">return</span> item+number;    </div><div class="line">    &#125;).join(chars);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> str = arr.merge(<span class="string">'-'</span>,<span class="number">7</span>);</div><div class="line"><span class="built_in">console</span>.log(str);</div></pre></td></tr></table></figure>
<blockquote>
<p>我们并不知道自己要对数组进行何种处理，所以我们要把对数组的操作封装起来。我们现在只知道需要将他们处理后用字符串连接起来，所以不妨将他们的处理内容保存在函数中，而仅仅固定封装连起来的部分。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span>(<span class="params">fn,chars</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(fn).join(chars);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> num + item;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> item - num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//每一项加2合并</span></div><div class="line"><span class="keyword">var</span> res1 = arr.merge(add(<span class="number">2</span>),<span class="string">'-'</span>);</div><div class="line"><span class="comment">//每一项减2合并</span></div><div class="line"><span class="keyword">var</span> res2 = arr.merge(reduce(<span class="number">2</span>),<span class="string">'-'</span>);</div><div class="line"><span class="comment">//也可以直接传入回调函数</span></div><div class="line"><span class="keyword">var</span> res3 = arr.merge((<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> item + num;</div><div class="line">    &#125;</div><div class="line">&#125;)(<span class="number">2</span>),<span class="string">'-'</span>);</div></pre></td></tr></table></figure>
<h2 id="柯里化通用式"><a href="#柯里化通用式" class="headerlink" title="柯里化通用式"></a>柯里化通用式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>,[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> _args = args.concat([].slice.apply(<span class="built_in">arguments</span>));</div><div class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>,_args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> list = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> list.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;,<span class="number">10</span>);</div></pre></td></tr></table></figure>
<h2 id="柯里化与bind"><a href="#柯里化与bind" class="headerlink" title="柯里化与bind"></a>柯里化与bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        fn.apply(ctx,_args.concat([].slice.call(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考链接 <a href="http://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="external">函数柯里化</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;什么是函数柯里化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="函数柯里化" scheme="https://muleimulei.github.io/tags/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript内置函数</title>
    <link href="https://muleimulei.github.io/2017/01/05/JavaScript/JavaScript%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>https://muleimulei.github.io/2017/01/05/JavaScript/JavaScript内置函数解析/</id>
    <published>2017-01-04T16:00:00.000Z</published>
    <updated>2017-04-02T15:20:30.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这篇文章将介绍几个关于JavaScript内置函数的简单算法</p>
</blockquote>
<a id="more"></a>
<h2 id="一、将字符串重复一定次数"><a href="#一、将字符串重复一定次数" class="headerlink" title="一、将字符串重复一定次数"></a>一、将字符串重复一定次数</h2><h3 id="1-使用while循环"><a href="#1-使用while循环" class="headerlink" title="1. 使用while循环"></a>1. 使用while循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">num,str</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> repeatStr = <span class="string">''</span>;</div><div class="line">    <span class="keyword">while</span>(num--)&#123;</div><div class="line">        repeatStr+=str;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> repeatStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-使用递归"><a href="#2-使用递归" class="headerlink" title="2. 使用递归"></a>2. 使用递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStringNumTimes</span>(<span class="params">str,times</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(times&lt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(times===<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> str + repeatStringNumTimes(str,times<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-使用es6的repeat"><a href="#3-使用es6的repeat" class="headerlink" title="3. 使用es6的repeat"></a>3. 使用es6的repeat</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStringNumTimes</span>(<span class="params">str,times</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> times&lt;<span class="number">0</span>?<span class="string">''</span>:str.repeat(times);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二、检查某一字符串是否已特定字符串结束"><a href="#二、检查某一字符串是否已特定字符串结束" class="headerlink" title="二、检查某一字符串是否已特定字符串结束"></a>二、检查某一字符串是否已特定字符串结束</h2><h3 id="1-利用substr函数"><a href="#1-利用substr函数" class="headerlink" title="1. 利用substr函数"></a>1. 利用substr函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str,target</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> str.substr(-target.length)===target? <span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-使用内置函数"><a href="#2-使用内置函数" class="headerlink" title="2. 使用内置函数"></a>2. 使用内置函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str,target</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> str.endsWith(target);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、翻转字符串"><a href="#三、翻转字符串" class="headerlink" title="三、翻转字符串"></a>三、翻转字符串</h2><h3 id="1-使用split-reverse-join"><a href="#1-使用split-reverse-join" class="headerlink" title="1. 使用split(),reverse(),join()"></a>1. 使用split(),reverse(),join()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reserve().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-使用for循环"><a href="#2-使用for循环" class="headerlink" title="2.使用for循环"></a>2.使用for循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newStr = <span class="string">''</span>;</div><div class="line">    <span class="keyword">var</span> len = str.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">        newStr+=str[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-使用递归"><a href="#3-使用递归" class="headerlink" title="3. 使用递归"></a>3. 使用递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(str===<span class="string">''</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> str.charAt(<span class="number">0</span>)+reverseStr(str.substr(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、将一个句子的每个单词首字母大写，其余小写"><a href="#四、将一个句子的每个单词首字母大写，其余小写" class="headerlink" title="四、将一个句子的每个单词首字母大写，其余小写"></a>四、将一个句子的每个单词首字母大写，其余小写</h2><h3 id="1-使用for循环"><a href="#1-使用for循环" class="headerlink" title="1. 使用for循环"></a>1. 使用for循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> list = str.toLowerCase().split(<span class="string">' '</span>);</div><div class="line">    <span class="keyword">var</span> len = list.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;len;i++)&#123;</div><div class="line">        list[i] = list[i].charAt(<span class="number">0</span>).toUpperCase() + list[i].substr(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list.join(<span class="string">' '</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-使用map方法"><a href="#2-使用map方法" class="headerlink" title="2. 使用map方法"></a>2. 使用map方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> str.toLowerCase().split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> word.charAt(<span class="number">0</span>).toUpperCase()+ word.slice(<span class="number">1</span>);</div><div class="line">    &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-使用replace方法"><a href="#2-使用replace方法" class="headerlink" title="2. 使用replace方法"></a>2. 使用replace方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> str.toLowerCase().split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> word.replace(word[<span class="number">0</span>],word[<span class="number">0</span>].toUpperCase());</div><div class="line">    &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这篇文章将介绍几个关于JavaScript内置函数的简单算法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="function" scheme="https://muleimulei.github.io/tags/function/"/>
    
  </entry>
  
</feed>
