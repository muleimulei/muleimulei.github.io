<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风的影子</title>
  <subtitle>小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muleimulei.github.io/"/>
  <updated>2017-08-13T03:31:39.846Z</updated>
  <id>https://muleimulei.github.io/</id>
  
  <author>
    <name>穆蕾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS实现单行，多行文本溢出显示省略号</title>
    <link href="https://muleimulei.github.io/2017/08/13/CSS3/css%E6%8E%A7%E5%88%B6%E6%96%87%E5%AD%97/"/>
    <id>https://muleimulei.github.io/2017/08/13/CSS3/css控制文字/</id>
    <published>2017-08-13T02:52:15.745Z</published>
    <updated>2017-08-13T03:31:39.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>CSS实现单行，多行文本溢出显示省略号</p>
</blockquote>
<a id="more"></a>
<p>实现单行文本的溢出显示省略号使用<code>text-overflow: ellipsis</code>，当然还需要加宽度width属性来兼容部分浏览。</p>
<p>实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">overflow: hidden;</div><div class="line">text-overflow: ellipsis;</div><div class="line">white-space: nowrap;</div></pre></td></tr></table></figure>
<p>但是这个属性只支持单行文本的溢出显示省略号。多行文本溢出显示省略号方法如下：<br>实现方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">display: -webkit-box;</div><div class="line">-webkit-box-orient: vertical;</div><div class="line">-webkit-line-clamp: 3;</div><div class="line">overflow: hidden;</div></pre></td></tr></table></figure></p>
<p>适用范围：<br>因为使用了webkit的css扩展属性，该方法适用于webkit浏览器及移动端；</p>
<p>注：</p>
<ol>
<li>-webkit-line-clamp:  用来限制在一个块元素显示的文本的行数。为了实现该效果，他需要组合其它的webkit属性。常用结合属性;</li>
<li>display: -webkit-box:    必须结合的属性，将对象作为弹性伸缩盒子模型</li>
<li>-webkit-box-orient: 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">p&#123;position: relative; line-height: 20px; max-height: 40px;overflow: hidden;&#125;</div><div class="line">p::after&#123;content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;</div><div class="line">background: -webkit-linear-gradient(left, transparent, #fff 55%);</div><div class="line">background: -o-linear-gradient(right, transparent, #fff 55%);</div><div class="line">background: -moz-linear-gradient(right, transparent, #fff 55%);</div><div class="line">background: linear-gradient(to right, transparent, #fff 55%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>将height设置为line-height的整数倍，防止超出的文字露出</li>
<li>给p::after添加渐变背景可避免文字只显示一半。</li>
<li>由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：<span></span>）；兼容ie8需要将<code>::after</code>替换成<code>:afetr</code>。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;CSS实现单行，多行文本溢出显示省略号&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://muleimulei.github.io/categories/CSS3/"/>
    
    
  </entry>
  
  <entry>
    <title>STL的map常用操作</title>
    <link href="https://muleimulei.github.io/2017/08/12/c%E4%B8%8Ec++/STL%E7%9A%84map%E5%87%BD%E6%95%B0/"/>
    <id>https://muleimulei.github.io/2017/08/12/c与c++/STL的map函数/</id>
    <published>2017-08-12T09:06:56.447Z</published>
    <updated>2017-08-12T09:47:04.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>STL的map常用操作</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>map中的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>(); <span class="comment">// 默认构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&amp; m) <span class="comment">// 拷贝构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end ); <span class="comment">//区间构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end, <span class="keyword">const</span> traits&amp; _compare) <span class="comment">//带比较谓词的构造函数</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>(iterator begin, iterator end, <span class="keyword">const</span> traits&amp; _compare, <span class="keyword">const</span> allocator&amp; all) <span class="comment">//带分配器</span></div></pre></td></tr></table></figure>
</li>
<li><p>数据的插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, <span class="string">"student_two"</span>));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"student_three"</span>));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>第二种插入value_type数据<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>, <span class="string">"student_one"</span>));</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">2</span>, <span class="string">"student_two"</span>));</div><div class="line">       mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">"student_three"</span>));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三种：用数组方式插入数据，下面举例说明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent[<span class="number">1</span>] =  “student_one”;</div><div class="line">       mapStudent[<span class="number">2</span>] =  “student_two”;</div><div class="line">       mapStudent[<span class="number">3</span>] =  “student_three”;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以用pair来获得是否插入成功：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">Pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;</div><div class="line">       Insert_Pair＝mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       If(Insert_Pair.second == <span class="literal">true</span>)</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Successfully”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Else</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Failure”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Insert_Pair＝mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_two”));</div><div class="line">       If(Insert_Pair.second == <span class="literal">true</span>)</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Successfully”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       Else</div><div class="line">       &#123;</div><div class="line">              Cout&lt;&lt;”Insert Failure”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator  iter;</div><div class="line">       <span class="keyword">for</span>(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)</div><div class="line">&#123;</div><div class="line">       Cout&lt;&lt;iter-&gt;first&lt;&lt;”   ”&lt;&lt;iter-&gt;second&lt;&lt;end;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>数据的查找（包括判定这个关键字是否在map中出现）<br>在这里我们将体会，map在数据插入时保证有序的好处。<br>要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的<br>map基本用法。<br>这里给出两种数据查找方法<br>第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系<br>，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了<br>第二种：用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，<br>如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器，程序说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, “student_two”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, “student_three”));</div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</div><div class="line">       iter = mapStudent.find(<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(iter != mapStudent.end())</div><div class="line">        &#123;</div><div class="line">               Cout&lt;&lt;”Find, the value is ”&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">               Cout&lt;&lt;”Do not Find”&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数据的删除</p>
</li>
</ol>
<p>这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       Map&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, “student_one”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2</span>, “student_two”));</div><div class="line">       mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, “student_three”));</div><div class="line"><span class="comment">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好</span></div><div class="line">       <span class="comment">//如果要删除1,用迭代器删除</span></div><div class="line">       <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</div><div class="line">       iter = mapStudent.find(<span class="number">1</span>);</div><div class="line">       mapStudent.erase(iter);</div><div class="line">       <span class="comment">//如果要删除1，用关键字删除</span></div><div class="line">       Int n = mapStudent.erase(<span class="number">1</span>);<span class="comment">//如果删除了会返回1，否则返回0</span></div><div class="line">       <span class="comment">//用迭代器，成片的删除</span></div><div class="line">       <span class="comment">//一下代码把整个map清空</span></div><div class="line">       mapStudent.earse(mapStudent.begin(), mapStudent.end());</div><div class="line">       <span class="comment">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合</span></div><div class="line">       <span class="comment">//自个加上遍历代码，打印输出吧</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>排序<br>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任<br>何问题的，因为上面的关键字是int型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体，涉及<br>到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去。<br>第一种：小于号重载，程序举例<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line">Using <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">Typedef <span class="keyword">struct</span> tagStudentInfo</div><div class="line">&#123;</div><div class="line">       Int      nID;</div><div class="line">       String   strName;</div><div class="line">        Bool <span class="keyword">operator</span> &lt; (tagStudentInfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></div><div class="line">       &#123;</div><div class="line">              <span class="comment">//这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序</span></div><div class="line">              If(nID &lt; _A.nID)  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">              If(nID == _A.nID) <span class="keyword">return</span> strName.compare(_A.strName) &lt; <span class="number">0</span>;</div><div class="line">              Return <span class="literal">false</span>;</div><div class="line">       &#125;</div><div class="line">&#125;StudentInfo, *PStudentInfo;  <span class="comment">//学生信息</span></div><div class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> nSize;</div><div class="line">       <span class="comment">//用学生信息映射分数</span></div><div class="line">       <span class="built_in">map</span>&lt;StudentInfo, <span class="keyword">int</span>&gt;mapStudent;</div><div class="line">    <span class="built_in">map</span>&lt;StudentInfo, <span class="keyword">int</span>&gt;::iterator iter;</div><div class="line">       StudentInfo studentInfo;</div><div class="line">       studentInfo.nID = <span class="number">1</span>;</div><div class="line">       studentInfo.strName = “student_one”;</div><div class="line">       mapStudent.insert(pair&lt;StudentInfo, <span class="keyword">int</span>&gt;(studentInfo, <span class="number">90</span>));</div><div class="line">       studentInfo.nID = <span class="number">2</span>;</div><div class="line">       studentInfo.strName = “student_two”;</div><div class="line">mapStudent.insert(pair&lt;StudentInfo, <span class="keyword">int</span>&gt;(studentInfo, <span class="number">80</span>));</div><div class="line"><span class="keyword">for</span> (iter=mapStudent.begin(); iter!=mapStudent.end(); iter++)</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first.nID&lt;&lt;<span class="built_in">endl</span>&lt;&lt;iter-&gt;first.strName&lt;&lt;<span class="built_in">endl</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;STL的map常用操作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="STL的map常用操作" scheme="https://muleimulei.github.io/tags/STL%E7%9A%84map%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>STL的vector初始化</title>
    <link href="https://muleimulei.github.io/2017/08/12/c%E4%B8%8Ec++/STL%E7%9A%84vector%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://muleimulei.github.io/2017/08/12/c与c++/STL的vector初始化/</id>
    <published>2017-08-12T07:47:20.239Z</published>
    <updated>2017-08-12T08:58:32.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>STL的vector初始化</p>
</blockquote>
<a id="more"></a>
<p>vector是连续内存容器，所以对于插入与删除的时间复杂度是很高的，因为删除或者插入的时候，需要元素的移动，即元素复制拷贝。</p>
<h1 id="使用原则："><a href="#使用原则：" class="headerlink" title="使用原则："></a>使用原则：</h1><ol>
<li>尽量使用vector代替C风格的数组或者CArray；</li>
<li>尽量使用算法代替手工写的循环；</li>
<li>尽量使用vector本身的函数代替其它泛型算法；</li>
</ol>
<h1 id="初始化vector"><a href="#初始化vector" class="headerlink" title="初始化vector"></a>初始化vector</h1><p>填充vector，如果我们想使用原始数组的内容填充vector，例如我们有数组<code>int v[10] = {0,1,1,10,0,0,0,0,3,5}</code></p>
<ul>
<li><p>初始化方式1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>); <span class="comment">//  初始化size为10可以避免数组动态增长的时候不断的分配内存</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">    v2.push_back(v2[i]);    <span class="comment">//  增加一个元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(&amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>]);   <span class="comment">//  原始数组的元素指针可以作为迭代器来使用</span></div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</div><div class="line">v4.resize(<span class="number">10</span>);</div><div class="line">v4.insert(v4.begin(), &amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>]);</div></pre></td></tr></table></figure>
</li>
<li><p>初始化方式4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5(<span class="number">10</span>);</div><div class="line">copy(&amp;v[<span class="number">0</span>], &amp;v[<span class="number">9</span>], v5.begin());</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>原始数组的元素指针可以作为迭代器来使用,</p>
</blockquote>
<ul>
<li>原则：尽量使用resize来减少不必要的内存分配次数。</li>
<li>原则：尽量使用empty而不是size()==0来判断容器是否为空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">23</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">546</span>,<span class="number">76</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">v.resize(<span class="number">6</span>);</div><div class="line">copy(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">6</span>], v.begin());  <span class="comment">//  将a数组复制到v</span></div><div class="line">v.insert(v.begin(), <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="comment">//  找到所有的23</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = find(v.begin(), v.end(), <span class="number">23</span>);</div><div class="line"><span class="keyword">while</span>(pos!=v.end())&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"**"</span>&lt;&lt;*pos&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    pos = find(pos+<span class="number">1</span>, v.end(), <span class="number">23</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; v.size();i++)&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; v[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;STL的vector初始化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="STL的vector初始化" scheme="https://muleimulei.github.io/tags/STL%E7%9A%84vector%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Vuex讲解</title>
    <link href="https://muleimulei.github.io/2017/08/10/Vue/Vuex%E8%AE%B2%E8%A7%A3/"/>
    <id>https://muleimulei.github.io/2017/08/10/Vue/Vuex讲解/</id>
    <published>2017-08-10T09:04:34.336Z</published>
    <updated>2017-08-11T14:39:21.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Vuex讲解</p>
</blockquote>
<a id="more"></a>
<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>Vuex是一个专为Vue.js应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所以组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h1 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="comment">//state</span></div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">count</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//view</span></div><div class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    <span class="comment">//actions</span></div><div class="line">    methods: &#123;</div><div class="line">        increment () &#123;</div><div class="line">            <span class="keyword">this</span>.count++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个状态自管理应用包括以下几个部分：</p>
<ul>
<li>state：驱动应用的数据源</li>
<li>view：以声明方式将state映射到视图</li>
<li>actions：响应在view上的用户输入导致的状态变化。</li>
</ul>
<img src="/assets/segment/vue-flow.png">
<p>但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态</li>
<li>来自不同视图的行为需要变更同一状态</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p>
<p>我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<img src="/assets/segment/vuex.png">
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h1 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h1><p>Vuex使用 <strong>单一状态树</strong>，用一个对象就包含了全部的应用层级状态。至此它便作为一个《《唯一数据源》》而存在。这也意味着，每个应用将仅仅包含一个store实例。单一状态树让我们能够直接的定位任意特定的状态片段，在调试的过程中也能够获得当前应用状态的快照。</p>
<h1 id="在Vue组件中获得Vuex状态"><a href="#在Vue组件中获得Vuex状态" class="headerlink" title="在Vue组件中获得Vuex状态"></a>在Vue组件中获得Vuex状态</h1><p>Vuex通过store选项，提供了一个机制将状态从根组件注入到每一个子组件中（需调用Vue.use(Vuex)）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">    <span class="comment">//  把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件</span></div><div class="line">    store,</div><div class="line">    <span class="attr">component</span>: &#123;Counter&#125;,</div><div class="line">    <span class="attr">template</span>: <span class="string">`</span></div><div class="line">        &lt;div class="app"&gt;</div><div class="line">            &lt;counter&gt;&lt;/counter&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `    </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过在根实例中注册store选项，该store实例会注入到根组件的所以子组件中，且子组件能通过this.$store访问到。counter的实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;`</span>,</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">        count () &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h1><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。可以使用mapState辅助函数帮助我们生成计算属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    computed: mapState(&#123;</div><div class="line">        <span class="comment">//  箭头函数可使代码更简练</span></div><div class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</div><div class="line">        <span class="comment">//传字符串参数 ‘count’等同于 `state =&gt; state.count`    </span></div><div class="line">        countAlias: <span class="string">'count'</span>,</div><div class="line">        <span class="comment">//为了能够使用this获取局部状态，必须使用常规函数</span></div><div class="line">        countPlusLocalState (state) &#123;</div><div class="line">            <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodoCount () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它—无论哪种方式都不是很理想。<br>Vuex允许我们在store中定义getter（可以认为是store的计算属性）。Getter接受state作为第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">todos</span>: [</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</div><div class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">'.....'</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getter</span>: &#123;</div><div class="line">        <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Getter会暴露为store.getters对象:<br><code>store.getters.doneTodos</code></p>
<p>Getters也可以接受其它getters作为第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">    <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">store.getters.doneTodosCount</div></pre></td></tr></table></figure></p>
<p>我们可以很容易地在任何组件中使用它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">    doneTodosCount () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h1><p>mapGetters 辅助函数仅仅是将store中的getters映射到局部计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">        <span class="comment">//使用对象展开运算符将getters混入computed对象中</span></div><div class="line">        ...mapGetters([</div><div class="line">            <span class="string">'doneTodosCount'</span>,</div><div class="line">            <span class="string">'anotherGetter'</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想将一个getter属性另取一个名字，使用对象形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...mapGetters(&#123;</div><div class="line">    <span class="comment">//  映射 this.doneCount 为 store.getters.doneTodosCount</span></div><div class="line">    doneCount: <span class="string">'doneTodosCount'</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex中的mutations非常类似于事件：每个mutation都有一个字符串的<strong>事件类型</strong>和一个<strong>回调函数</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">count</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mutations</span>: &#123;</div><div class="line">        increment (state) &#123;</div><div class="line">            <span class="comment">//变更状态</span></div><div class="line">            state.count++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不能直接调用一个mutation.handler。这个选项更像是事件注册：“当触发一个类型为increment的mutation时，调用此函数。”要唤醒一个mutation handler，你需要以相应的type调用store.commit方法。<code>store.commit(‘increment’)</code></p>
<h1 id="提交载荷"><a href="#提交载荷" class="headerlink" title="提交载荷"></a>提交载荷</h1><p>你可以向store.commit传入额外的参数，即mutation的载荷：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  ...</span></div><div class="line">mutations: &#123;</div><div class="line">    increment (state, n)&#123;</div><div class="line">        state.count += n</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mutation: &#123;</div><div class="line">    increment (state, payload) &#123;</div><div class="line">        state.count += payload.amount</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="Mutation需遵循Vue的响应规则"><a href="#Mutation需遵循Vue的响应规则" class="headerlink" title="Mutation需遵循Vue的响应规则"></a>Mutation需遵循Vue的响应规则</h1><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
<ol>
<li><p>最好提前在你的 store 中初始化好所有所需属性。</p>
</li>
<li><p>当需要在对象上添加新属性时，你应该<br>使用 Vue.set(obj, ‘newProp’, 123), 或者 -<br>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：<code><br>state.obj = { …state.obj, newProp: 123 }</code></p>
</li>
</ol>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Action类似于mutation，不同在于：</p>
<ul>
<li>Action提交的是mutation，而不是直接变更状态</li>
<li>Action可以包含任意异步操作</li>
</ul>
<p>让我们来注册一个简单的action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">    <span class="attr">state</span>: &#123;</div><div class="line">        <span class="attr">count</span>: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mutations</span>: &#123;</div><div class="line">        increment (state) &#123;</div><div class="line">            state.count++</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">actions</span>: &#123;</div><div class="line">        increment (context) &#123;</div><div class="line">            context.commit(<span class="string">'increment'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Action 函数接受一个与store实例具有相同方法的属性的context对象，因此你可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。</p>
<p>实践中，我们会经常用到ES2015的参数解构来简化代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    increment (&#123;commit&#125;) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h1><p>Action通过<code>store.dispatch</code>方法触发：<br><code>store.dispatch(‘increment’)</code>，<strong>mutation必须同步执行，但是我们可以在action内部执行异步操作 </strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    incrementAsync (&#123;commit&#125;) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            commit(<span class="string">'increment'</span>)    </div><div class="line">        &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Actions支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  以载荷形式分发</span></div><div class="line">store.dispatch(<span class="string">'increment'</span>, &#123;</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//以对象形式分发</span></div><div class="line">store.dispatch(&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'incrementAsync'</span>,</div><div class="line">    <span class="attr">amount</span>: <span class="number">10</span>    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h1><p>你在组件中使用<code>this.$store.dispatch(‘xxx’)</code>分发action，或者使用<code>mapActions</code>辅助函数将组件的methods映射为<code>store.dispatch</code>调用（需要先在根节点注入store）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    methods: &#123;</div><div class="line">        ...mapActions([</div><div class="line">            <span class="string">'increment'</span> <span class="comment">//  映射this.increment()为this.$store.dispatch('increment')</span></div><div class="line">            add: <span class="string">'increment'</span>    <span class="comment">//  映射this.add() 为this.$store.dispatch('increment')</span></div><div class="line">        ])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="组合Actions"><a href="#组合Actions" class="headerlink" title="组合Actions"></a>组合Actions</h1><p>Action通常是异步的，那么如何知道action什么时候结束呢？更重要的是，我们如何才能组合多个action，以处理更加复杂的异步流程？</p>
<p>首先，你需要明白<code>store.dispatch</code>可以处理被触发的action的回调函数返回的Promise，并且store.dispatch仍然返回Promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    actionA (&#123;commit&#125;) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                commit(<span class="string">'someMutation'</span>)</div><div class="line">                resolve()</div><div class="line">            &#125;, <span class="number">1000</span>)    </div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//...    </span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在另外一个action中也可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    actionB (&#123;dispatch, commit&#125;) &#123;</div><div class="line">        <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            commit(<span class="string">'someOtherMutation'</span>)    </div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>由于使用单一状态树，应用的所以状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相对臃肿。</p>
<p>为了解决以上问题，Vuex允许我们将store分割成<strong>模块</strong>，每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块—从上至下进行同样方式分割：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">getters</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</div><div class="line">  <span class="attr">actions</span>: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">a</span>: moduleA,</div><div class="line">    <span class="attr">b</span>: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></div></pre></td></tr></table></figure>
<h1 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h1><p>对于模块内部的mutation和getter，接受的第一个参数是<strong>模块的局部状态对象</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">mutations</span>: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">getters</span>: &#123;</div><div class="line">    doubleCount (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样，对于模块内部的action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于模块内部的getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  getters: &#123;</div><div class="line">    sumWithRootCount (state, getters, rootState) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + rootState.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块更加自包含或提高可重用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  <span class="attr">modules</span>: &#123;</div><div class="line">    <span class="attr">account</span>: &#123;</div><div class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</div><div class="line">      <span class="comment">// 模块内容（module assets）</span></div><div class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></div><div class="line">      getters: &#123;</div><div class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">actions</span>: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">mutations</span>: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// 嵌套模块</span></div><div class="line">      modules: &#123;</div><div class="line">        <span class="comment">// 继承父模块的命名空间</span></div><div class="line">        myPage: &#123;</div><div class="line">          <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">          <span class="attr">getters</span>: &#123;</div><div class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 进一步嵌套命名空间</span></div><div class="line">        posts: &#123;</div><div class="line">          <span class="attr">namespaced</span>: <span class="literal">true</span>,</div><div class="line">          <span class="attr">state</span>: &#123; ... &#125;,</div><div class="line">          <span class="attr">getters</span>: &#123;</div><div class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Vuex讲解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://muleimulei.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>类型化数组</title>
    <link href="https://muleimulei.github.io/2017/08/07/JavaScript/%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <id>https://muleimulei.github.io/2017/08/07/JavaScript/类型化数组/</id>
    <published>2017-08-07T14:41:10.392Z</published>
    <updated>2017-08-10T04:38:17.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>类型化数组</p>
</blockquote>
<a id="more"></a>
<h2 id="类型化数组是JavaScript操作二进制数据的一个接口"><a href="#类型化数组是JavaScript操作二进制数据的一个接口" class="headerlink" title="类型化数组是JavaScript操作二进制数据的一个接口"></a>类型化数组是JavaScript操作二进制数据的一个接口</h2><p>类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。<br><code>var buf = new ArrayBuffer(32)</code>，这段代码生成了一段32字节的内存区域。ArrayBuffer对象的<strong>byteLength属性</strong>，返回所分配的区域区域的字节长度。<code>var buffer = new ArrayBuffer(32); buffer.byteLength</code>,如果分配的内存区域很大，有可能分配失败，所以有必要检查是否分配成功。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(buffer.byteLength===n)&#123;</div><div class="line">    <span class="comment">//success</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//fail</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ArrayBuffer对象有一个slice方法，允许将内存区域的一部分拷贝生成一个新的ArrayBuffer对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> newBuffer = buffer.slice(<span class="number">0</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码拷贝buffer对象的前3个字节，生成一个新的ArrayBuffer对象。slice方法包含两步：第一步先分配一段新内存，第二部是将原来那个ArrayBuffer对象拷贝过去。<br>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号，第二个参数表示拷贝截至的字节序号。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。<br>除了slice方法，ArrayBuffer对象不提供任何直接读取内存的方法，只允许再其上方建立视图，然后通过视图读写。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ol>
<li>视图的生成<br>ArrayBuffer作为内存区域，可以存放多种类型的数据。不同数据有不同的存取方式，这就叫做”视图”。目前，JavaScript提供以下类型的视图：</li>
</ol>
<blockquote>
<p>Int8Array：8位有符号整数，长度1个字节。<br>  Uint8Array：8位无符号整数，长度1个字节。<br>  Int16Array：16位有符号整数，长度2个字节。<br>  Uint16Array：16位无符号整数，长度2个字节。<br>  Int32Array：32位有符号整数，长度4个字节。<br>  Uint32Array：32位无符号整数，长度4个字节。<br>  Float32Array：32位浮点数，长度4个字节。<br>  Float64Array：64位浮点数，长度8个字节。</p>
</blockquote>
<p>每一种视图都有一个BYTE_PER_ELEMENT常数，表示这种数据类型占据的字节数。</p>
<blockquote>
<p>Int8Array.BYTES_PER_ELEMENT // 1<br>  Uint8Array.BYTES_PER_ELEMENT // 1<br>  Int16Array.BYTES_PER_ELEMENT // 2<br>  Uint16Array.BYTES_PER_ELEMENT // 2<br>  Int32Array.BYTES_PER_ELEMENT // 4<br>  Uint32Array.BYTES_PER_ELEMENT // 4<br>  Float32Array.BYTES_PER_ELEMENT // 4<br>  Float64Array.BYTES_PER_ELEMENT // 8</p>
</blockquote>
<ol>
<li>在ArrayBuffer对象之上生成视图<br>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个8字节的ArrayBuffer</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码在一段长度为8个字节的内存之上，生成了三个视图：v1，v2，v3。视图的构造函数可以接受三个参数：</p>
<blockquote>
<p>第一个参数：视图对应的底层ArrayBuffer对象，该参数是必需的。<br>  第二个参数：视图开始的字节序号，默认从0开始。<br>  第三个参数：视图包含的数据个数，默认直到本段内存区域结束。</p>
</blockquote>
<p>因此，v1、v2和v3是重叠：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>
<ol>
<li><p>直接生成<br>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f64a = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">8</span>);</div><div class="line">f64a[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line">f64a[<span class="number">1</span>] = <span class="number">20</span>;</div><div class="line">f64a[<span class="number">2</span>] = f64a[<span class="number">0</span>] + f64a[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
</li>
<li><p>将普通数组转为视图数组<br>将一个数据类型符合要求的普通数组，传入构造函数，也能直接生成视图。<code>var typedArray = new Uint8Array( [ 1, 2, 3, 4 ] );</code>，代码将一个普通的数组，赋值给一个新生成的8位无符号整数的视图数组。视图数组也可以转换回普通数组。<code>var normalArray = Array.apply( [], typedArray );</code></p>
</li>
<li><p>视图的操作<br>建立了视图以后，就可以进行各种操作了。这里需要明确的是，视图其实就是普通数组，语法完全没有什么不同，只不过它直接针对内存进行操作，而且每个成员都有确定的数据类型。所以，视图就被叫做“类型化数组”。</p>
<ul>
<li><p>数组操作<br>普通数组的操作方法和属性，对类型化数组完全适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</div><div class="line"><span class="keyword">var</span> int32View = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int32View.length; i++) &#123;</div><div class="line">  int32View[i] = i*<span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int16View = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;int16View.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Entry "</span> + i + <span class="string">": "</span> + int16View[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Entry 0: 0</span></div><div class="line"><span class="comment">// Entry 1: 0</span></div><div class="line"><span class="comment">// Entry 2: 2</span></div><div class="line"><span class="comment">// Entry 3: 0</span></div><div class="line"><span class="comment">// Entry 4: 4</span></div><div class="line"><span class="comment">// Entry 5: 0</span></div><div class="line"><span class="comment">// Entry 6: 6</span></div><div class="line"><span class="comment">// Entry 7: 0</span></div></pre></td></tr></table></figure>
<p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。<br>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以类型化数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。<br>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，类型化数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序，下文会详细介绍。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></div><div class="line"><span class="comment">// 计算机采用小端字节序</span></div><div class="line"><span class="keyword">var</span> uInt16View = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buffer);</div><div class="line"><span class="comment">// 比较运算 </span></div><div class="line"><span class="keyword">if</span> (bufView[<span class="number">0</span>]===<span class="number">258</span>) &#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 赋值运算</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></div><div class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></div></pre></td></tr></table></figure>
<p>总之，与普通数组相比，类型化数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
</li>
<li><p>buffer属性<br>类型化数组的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。<br>var a = new Float32Array(64);<br>var b = new Uint8Array(a.buffer);<br>上面代码的a对象和b对象，对应同一个ArrayBuffer对象，即同一段内存。</p>
</li>
<li>byteLength属性和byteOffset属性<br>byteLength属性返回类型化数组占据的内存长度，单位为字节。byteOffset属性返回类型化数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div><div class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(b, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">v1.byteLength <span class="comment">// 8</span></div><div class="line">v2.byteLength <span class="comment">// 6</span></div><div class="line">v3.byteLength <span class="comment">// 4</span></div><div class="line"></div><div class="line">v1.byteOffset <span class="comment">// 0</span></div><div class="line">v2.byteOffset <span class="comment">// 2</span></div><div class="line">v3.byteOffset <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</div><div class="line">a.length <span class="comment">// 8</span></div><div class="line">a.byteLength <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<ul>
<li>set方法<br>类型化数组的set方法用于复制数组，也就是将一段内容完全复制到另一段内存。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</div><div class="line">b.set(a);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</div><div class="line">b.set(a,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>
<ul>
<li>subarray方法<br>subarray方法是对于类型化数组的一部分，再建立一个新的视图。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> b = a.subarray(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">a.byteLength <span class="comment">// 16</span></div><div class="line">b.byteLength</div></pre></td></tr></table></figure>
<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>
<ul>
<li>ArrayBuffer与字符串的互相转换<br>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params">buf</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 字符串转为ArrayBuffer对象，参数为字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(str.length*<span class="number">2</span>); <span class="comment">// 每个字符占用2个字节</span></div><div class="line">    <span class="keyword">var</span> bufView = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(buf);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, strLen=str.length; i&lt;strLen; i++) &#123;</div><div class="line">         bufView[i] = str.charCodeAt(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h1><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。<br>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种类型化视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。<br>DataView本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。<br><code>DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</code></p>
<blockquote>
<p>getInt8：读取1个字节，返回一个8位整数。<br>  getUint8：读取1个字节，返回一个无符号的8位整数。<br>  getInt16：读取2个字节，返回一个16位整数。<br>  getUint16：读取2个字节，返回一个无符号的16位整数。<br>  getInt32：读取4个字节，返回一个32位整数。<br>  getUint32：读取4个字节，返回一个无符号的32位整数。<br>  getFloat32：读取4个字节，返回一个32位浮点数。<br>  getFloat64：读取8个字节，返回一个64位浮点数。</p>
</blockquote>
<p>这一系列get方法的参数都是一个字节序号，表示从哪个字节开始读取。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 从第1个字节读取一个8位无符号整数</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint8(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 从第2个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">1</span>); </div><div class="line"></div><div class="line"><span class="comment">// 从第4个字节读取一个16位无符号整数</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。<br>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 小端字节序</span></div><div class="line"><span class="keyword">var</span> v1 = dv.getUint16(<span class="number">1</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v2 = dv.getUint16(<span class="number">3</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// 大端字节序</span></div><div class="line"><span class="keyword">var</span> v3 = dv.getUint16(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>DataView视图提供以下方法写入内存：</p>
<blockquote>
<p>setInt8：写入1个字节的8位整数。<br>setUint8：写入1个字节的8位无符号整数。<br>setInt16：写入2个字节的16位整数。<br>setUint16：写入2个字节的16位无符号整数。<br>setInt32：写入4个字节的32位整数。<br>setUint32：写入4个字节的32位无符号整数。<br>setFloat32：写入4个字节的32位浮点数。<br>setFloat64：写入8个字节的64位浮点数。</p>
</blockquote>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在第1个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">0</span>, <span class="number">25</span>, <span class="literal">false</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第5个字节，以大端字节序写入值为25的32位整数</span></div><div class="line">dv.setInt32(<span class="number">4</span>, <span class="number">25</span>); </div><div class="line"></div><div class="line"><span class="comment">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></div><div class="line">dv.setFloat32(<span class="number">8</span>, <span class="number">2.5</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> littleEndian = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line">  <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer).setInt16(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer)[<span class="number">0</span>] === <span class="number">256</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;类型化数组&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
      <category term="类型化数组" scheme="https://muleimulei.github.io/tags/%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据库安全性</title>
    <link href="https://muleimulei.github.io/2017/08/07/DataBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>https://muleimulei.github.io/2017/08/07/DataBase/数据库安全性/</id>
    <published>2017-08-07T11:37:04.409Z</published>
    <updated>2017-08-07T13:30:13.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据库安全性</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>数据库的特点之一是由数据库管理系统提供统一的数据保护功能来保护数据的安全可靠和正确有效。数据库的数据保护主要包括数据的安全性和完整性。</p>
</blockquote>
<p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露，更改或破坏</p>
<p>数据库的不安全因素</p>
<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄露</li>
<li>安全环境的脆弱性</li>
</ol>
<p>数据库安全性控制</p>
<ol>
<li>用户身份鉴别</li>
<li>多层存取控制</li>
<li>审计</li>
<li>视图和数据加密</li>
</ol>
<p>存取控制<br><strong>存取控制机制主要包括定义用户权限和合法权限检查两部分，定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统 </strong></p>
<blockquote>
<p>C2级的数据库管理系统支持<strong>自主存取控制</strong>，B1级的数据库管理系统支持<strong>强制存取控制</strong></p>
</blockquote>
<ol>
<li>在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其它用户。因此自主存取控制非常灵活。</li>
<li>在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具体合法许可证的用户才可以存取。强制存取控制因此相对比较严格。</li>
</ol>
<h1 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h1><p>用户权限是由两个要素组成的：数据库对象和操作类型。定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，定义存取权限称为授权。<br>在关系数据库系统中，存取控制的对象不仅有数据本身（基本表中的数据，属性列上的数据），还有数据库模式（包括数据库，基本表，视图和索引的创建等）。</p>
<h1 id="关系数据库系统中的存取权限"><a href="#关系数据库系统中的存取权限" class="headerlink" title="关系数据库系统中的存取权限"></a>关系数据库系统中的存取权限</h1><p>数据类型</p>
<ul>
<li>数据库模式<ol>
<li>模式：<code>CREATE SCHEMA</code></li>
<li>基本表：<code>CREATE TABLE, ALTER TABLE</code></li>
<li>视图：<code>CREATE VIEW</code></li>
<li>索引：<code>CREATE INDEX</code></li>
</ol>
</li>
<li>数据<ol>
<li>基本表和视图：<code>SELECT, INSERT, UPDATE, DELETE, REFERENCES, ALL PRIVILEGES</code></li>
<li>属性列：<code>SELECT, INSERT, UPDATE, REFERENCES, ALL PRIVILEGES</code></li>
</ol>
</li>
</ul>
<h1 id="授权：授予与收回"><a href="#授权：授予与收回" class="headerlink" title="授权：授予与收回"></a>授权：授予与收回</h1><ol>
<li><p>GRANT<br>GRANT语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;权限&gt;，[,&lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt; [,&lt;对象类型&gt; &lt;对象名&gt;]...</div><div class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</div></pre></td></tr></table></figure>
<p>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的还可以是数据库管理员，也可以是该数据库对象创建者（即属主owner），还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，及全体用户。如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予其它的用户。如果没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(Sno), <span class="keyword">SELECT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</div><div class="line"><span class="keyword">To</span> U4</div><div class="line"></div><div class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</div><div class="line"><span class="keyword">TO</span> U5</div><div class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></div></pre></td></tr></table></figure>
</li>
<li><p>REVOKE<br>REVOKE的一般格式为；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[, &lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt;&lt;对象名&gt; [, &lt;对象类型&gt;&lt;对象名&gt;]...</div><div class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;] ... [<span class="keyword">CASCADE</span>|RESTRICT]</div><div class="line"></div><div class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span></div><div class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</div><div class="line"><span class="keyword">FROM</span> U5 <span class="keyword">CASCADE</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>创建数据库模式的权限<br>创建数据库模式一类的数据库对象的授权则由数据库管理员在创建用户时实现，创建用户的一般合适如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &lt;username&gt; [<span class="keyword">WITH</span>] [DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>只有系统的超级用户才有权创建一个新的数据库用户</li>
<li>新创建的数据库用户有三种权限：CONNECT, RESOURCE和DBA</li>
<li>CREATE USER命令中如果没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登陆数据库。由数据库管理员或其它用户授予他应用的权限，根据获得的授权的情况他可以对数据库对象进行权限范围内的操作。</li>
<li>拥有RESOURCE权限的用户能创建基本表和视图，称为所创建对象的属主，但不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把该对象上的存取权限授予其它用户。</li>
<li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户，创建模式，创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</li>
</ul>
<ol>
<li><p>角色</p>
<ul>
<li>角色的创建：<code>CREATE ROLE &lt;角色名&gt;</code></li>
<li><p>给角色授权：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;权限&gt; [, &lt;权限&gt;]...</div><div class="line"><span class="keyword">ON</span> &lt;对象类型&gt; 对象名</div><div class="line"><span class="keyword">To</span> &lt;角色&gt; [,&lt;角色&gt;]</div></pre></td></tr></table></figure>
</li>
<li><p>将一个角色授予其它的角色或用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GRANT</span> &lt;角色<span class="number">1</span>&gt; [, &lt;角色<span class="number">2</span>&gt;]...</div><div class="line"><span class="keyword">To</span> &lt;角色<span class="number">3</span>&gt; [, &lt;用户<span class="number">1</span>&gt;]...</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</div></pre></td></tr></table></figure>
<p>如果指定了<code>WITH ADMIN OPTION</code>子句，则获得某种权限的角色或用户还可以把这种权限再授予其它的角色</p>
</li>
<li><p>角色权限的收回</p>
<pre><code class="sql"><span class="keyword">REVOKE</span> &lt;权限&gt; [, &lt;权限&gt;]...
<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;
<span class="keyword">FROM</span>  &lt;角色&gt; [,&lt;角色&gt;]
</code></pre>
<p>REVOKE动作的执行者或者角色的创建者，或者拥有在这个角色上的ADMIN OPTION</p>
</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据库安全性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="数据库安全性" scheme="https://muleimulei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>百度音乐API</title>
    <link href="https://muleimulei.github.io/2017/08/06/nodejs/%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90API/"/>
    <id>https://muleimulei.github.io/2017/08/06/nodejs/百度音乐API/</id>
    <published>2017-08-06T10:22:31.277Z</published>
    <updated>2017-08-06T11:42:36.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>百度音乐API</p>
</blockquote>
<a id="more"></a>
<h2 id="百度音乐全接口-会利用使用接口找歌简单又快捷-http-tingapi-ting-baidu-com-v1-restserver-ting"><a href="#百度音乐全接口-会利用使用接口找歌简单又快捷-http-tingapi-ting-baidu-com-v1-restserver-ting" class="headerlink" title="百度音乐全接口 会利用使用接口找歌简单又快捷  http://tingapi.ting.baidu.com/v1/restserver/ting "></a>百度音乐全接口 会利用使用接口找歌简单又快捷 <code> <a href="http://tingapi.ting.baidu.com/v1/restserver/ting" target="_blank" rel="external">http://tingapi.ting.baidu.com/v1/restserver/ting</a> </code></h2><p>获取方式：GET<br>参数：format=json或xml&amp;calback=&amp;from=webapp_music&amp;method=以下不同的参数获得不同的数据<br>PS：format根据开发需要可选择json或xmml，其他参数对应填入，calback是等于空的。</p>
<h1 id="一、获取列表"><a href="#一、获取列表" class="headerlink" title="一、获取列表"></a>一、获取列表</h1><p>例：method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0 </p>
<p>参数： type = 1-新歌榜,2-热歌榜,11-摇滚榜,12-爵士,16-流行,21-欧美金曲榜,22-经典老歌榜,23-情歌对唱榜,24-影视金曲榜,25-网络歌曲榜</p>
<p>size = 10 //返回条目数量</p>
<p>offset = 0 //获取偏移</p>
<h1 id="二、貌似是推广（无用）"><a href="#二、貌似是推广（无用）" class="headerlink" title="二、貌似是推广（无用）"></a>二、貌似是推广（无用）</h1><p>例：method=baidu.ting.adv.showlist&amp;_=1430215999</p>
<p>参数：_ = 1430215999//时间戳</p>
<h1 id="三、搜索"><a href="#三、搜索" class="headerlink" title="三、搜索"></a>三、搜索</h1><p>例：method=baidu.ting.search.catalogSug&amp;query=海阔天空</p>
<p>参数：query = ‘’ //搜索关键字</p>
<h1 id="四、播放"><a href="#四、播放" class="headerlink" title="四、播放"></a>四、播放</h1><p>例：method=baidu.ting.song.play&amp;songid=877578</p>
<p>例：method=baidu.ting.song.playAAC&amp;songid=877578</p>
<p>参数：songid = 877578 //歌曲id</p>
<h1 id="五、LRC歌词"><a href="#五、LRC歌词" class="headerlink" title="五、LRC歌词"></a>五、LRC歌词</h1><p>例：method=baidu.ting.song.lry&amp;songid=877578</p>
<p>参数：songid = 877578 //歌曲id</p>
<h1 id="六、推荐列表"><a href="#六、推荐列表" class="headerlink" title="六、推荐列表"></a>六、推荐列表</h1><p>例：method=baidu.ting.song.getRecommandSongList&amp;song_id=877578&amp;num=5</p>
<p>参数： song_id = 877578</p>
<p>num = 5//返回条目数量</p>
<h1 id="七、下载"><a href="#七、下载" class="headerlink" title="七、下载"></a>七、下载</h1><p>例：method=baidu.ting.song.downWeb&amp;songid=877578&amp;bit=24&amp;_t=1393123213</p>
<p>参数： songid = 877578//歌曲id</p>
<p>bit = 24, 64, 128, 192, 256, 320 ,flac//码率</p>
<p>_t = 1430215999,, //时间戳</p>
<h1 id="八、获取歌手信息"><a href="#八、获取歌手信息" class="headerlink" title="八、获取歌手信息"></a>八、获取歌手信息</h1><p>例：method=baidu.ting.artist.getInfo&amp;tinguid=877578</p>
<p>参数： tinguid = 877578 //歌手ting id</p>
<h1 id="九、获取歌手歌曲列表"><a href="#九、获取歌手歌曲列表" class="headerlink" title="九、获取歌手歌曲列表"></a>九、获取歌手歌曲列表</h1><p>例：method=baidu.ting.artist.getSongList&amp;tinguid=877578&amp;limits=6&amp;use_cluster=1&amp;order=2</p>
<p>参数： tinguid = 877578//歌手ting id</p>
<p>limits = 6//返回条目数量</p>
<p>其他就不用管了</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;百度音乐API&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Node" scheme="https://muleimulei.github.io/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库视图</title>
    <link href="https://muleimulei.github.io/2017/08/05/DataBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE/"/>
    <id>https://muleimulei.github.io/2017/08/05/DataBase/数据库视图/</id>
    <published>2017-08-05T12:27:14.469Z</published>
    <updated>2017-08-05T14:38:54.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据库视图</p>
</blockquote>
<a id="more"></a>
<p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p>
<ol>
<li><p>建立视图<br> sql语言用CREATE VIEW命令建立视图，其一般格式为：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> &lt;视图名&gt; [(&lt;列名&gt;[,&lt;列名&gt;]...)]</div><div class="line"><span class="keyword">AS</span> &lt;子查询&gt;</div><div class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</div></pre></td></tr></table></figure>
<p> 其中，子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，取决于具体系统的实现。<strong>WITH CHECK OPTION表示对视图进行UPDATE, INSERT,和DELETE操作时要保证更新，插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</strong>，组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成，但在下列情况下必须明确指定组成视图的所有列名。</p>
<p> 1) 某个目标列不是单纯的属性名，而是聚集函数或列表达式<br> 2) 多表连接时选出了几个同名列作为视图的字段<br> 3) 需要在视图中为某个列启用新的更合适的名字</p>
</li>
</ol>
<blockquote>
<p>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为<strong>行列子集视图</strong><br>还可以用带有聚集函数和group by 子句的查询来定义视图，这种视图称为<strong>分组视图</strong><br>    <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno Gavg)</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</div><div class="line"><span class="keyword">FROM</span> SC</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>删除视图<br> 语句为  <code>DROP VIEW &lt;视图名&gt; [CASCADE]</code> ，视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其它视图，则使用CASCADE级联删除语句把该视图和由它导出的所有视图一起删除。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BT_S <span class="keyword">CASCADE</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>查询视图<br> 关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表，视图等是否存在。如果存在，则从<strong>数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转化成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解</strong></p>
</li>
<li><p>更新视图<br> 更新视图是通过视图来插入（insert），删除（delete）和修改（update）数据。由于视图是不实际存储数据的虚表，因此对视图的更新最终要转化为对基本表的更新。像查询视图一样，对视图的更新操作也是通过视图消解，转化为对基本表的更新操作。<br> 为防止用户通过视图对数据进行增加，删除，修改时，有意无意地对不属于视图范围的基本表数据进行操作，可在定义视图时加上WITH CHECK OPTION子句，这样在视图上增，删，改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。</p>
</li>
<li><p>视图的作用</p>
<ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当利用视图可以更清晰地表达查询</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据库视图&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="数据库视图" scheme="https://muleimulei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>string与stringstream</title>
    <link href="https://muleimulei.github.io/2017/08/05/c%E4%B8%8Ec++/string%E4%B8%8Estringstream/"/>
    <id>https://muleimulei.github.io/2017/08/05/c与c++/string与stringstream/</id>
    <published>2017-08-05T08:05:11.302Z</published>
    <updated>2017-08-05T09:40:56.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>string与stringstream</p>
</blockquote>
<a id="more"></a>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string是c++提供的字符串型，和c的字符串相比，除了有不限长度的优点外，还有其它许多方便的功能。</p>
<p>首先加入<code>#include\<string\> </string\></code>，声明变量可以写成<code>string s;s=”hello”</code>，也可以直接设置其值<code>string s = “TCGS”</code>，如果要取得其中一个字符，和传统的c语言一样是用s[i]取得。比较不一样的是如果s有三个字符，传统c的字符s[3]是0字元，但是c++的string则是只到s[2]这个字符而已。</p>
<p>操作：</p>
<pre><code>- 声明：
    + string：string s
    + 字符阵列：char s[100]
- 取得第i个字符
    + string：s[i]
    + 字符阵列：s[i]
- 字符串长度
    + string：s.length()
    + 字符阵列：strlen(s)
- 读取一行
    + string：getline(cin, s)
    + 字符阵列：gets(s)
- 设成某字符串
    + string：s=&quot;TSS&quot;
    + 字符阵列：strcpy(s, &apos;TSS&apos;)
- 字符串相加
    + string：s = s + &apos;TSS&apos;
    + 字符阵列：strcat(s, &apos;TSS&apos;)
- 字符比较
    + string：s==&apos;TSS&apos;
    + 字符阵列：strcmp(s, &apos;TSS&apos;)
</code></pre><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>stringstream是c++提供的另一个字符串型的串流物件，要使用stringstream，必须先加入这一行：<code>#include<sstream></sstream></code>，stringstream主要是用在将一个字符串分割，可以先用clear()以及str()将指定字符串设定成一开始的内容，再用&gt;&gt;把个别的资料输出，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="built_in">stringstream</span> ss;</div><div class="line"><span class="keyword">int</span> a,b,c;</div><div class="line">getline(<span class="built_in">cin</span>, s);</div><div class="line">ss.clear();</div><div class="line">ss.str(s);</div><div class="line">ss&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div></pre></td></tr></table></figure>
<p>题目：输入的第一行有一个数字N代表接下来N行资料，每一行资料里有不固定个数的整数（最多20个，每行最大200个字符），请你写一个算法将每行的总和打印出来<br>輸入：</p>
<p>3<br>1 2 3<br>20 17 23 54 77 60<br>111 222 333 444 555 666 777 888 999</p>
<p>輸出：</p>
<p>6<br>251<br>4995</p>
<p>程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="built_in">stringstream</span> ss;</div><div class="line"><span class="keyword">int</span> n, i, sum, a;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">getline(<span class="built_in">cin</span>, s); <span class="comment">// 讀取換行</span></div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">&#123;</div><div class="line">    getline(<span class="built_in">cin</span>, s);</div><div class="line">    ss.clear();</div><div class="line">    ss.str(s);</div><div class="line">    sum=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        ss &gt;&gt; a;</div><div class="line">        <span class="keyword">if</span> ( ss.fail() ) <span class="keyword">break</span>;</div><div class="line">        sum+=a;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>常用的方法有size()，find()，substr()方法：</div><div class="line"><span class="built_in">string</span> str = <span class="string">"yutyuyuyussdfas"</span>;</div><div class="line"><span class="keyword">size_t</span> pos = str.find(<span class="string">"ssdf"</span>, <span class="number">3</span>);   <span class="comment">//用if(pos==string::npos)用来判断是否找到字符串</span></div><div class="line"><span class="built_in">string</span> str2 = str.substr(pos, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">//find函数从str的第三个位置查起，找到sddf这个字符串后，返回字符串的位置。而substr函数从pos位置开始，截取5个字符，赋给str2</span></div></pre></td></tr></table></figure>
<p>stringstream是字符串流，可以用来数据切分或者类型转化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">i2s</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len = <span class="number">0</span>)</span></span>&#123;</div><div class="line">    <span class="built_in">stringstream</span> ss;</div><div class="line">    ss &lt;&lt; setw(len) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; i;</div><div class="line">    <span class="keyword">return</span> ss.str();</div><div class="line">&#125;</div><div class="line"><span class="comment">//以i2s(7, 3)形式调用这个函数，返回的结果是字符串007</span></div></pre></td></tr></table></figure></p>
<p>string到int的转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> res = <span class="string">"1000"</span>;</div><div class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">stream&lt;&lt;result;</div><div class="line">stream&gt;&gt;n;</div></pre></td></tr></table></figure></p>
<p>在类型转化中使用模板。to_string()函数将t转化为字符串并写入result中。使用str()成员函数来获取流内部缓存的一份拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_string</span><span class="params">(<span class="built_in">string</span> &amp;result, <span class="keyword">const</span> T &amp;l)</span></span>&#123;</div><div class="line">    <span class="built_in">ostringstream</span> oss; <span class="comment">//创建一个流</span></div><div class="line">    oss&lt;&lt;t; <span class="comment">//把值传递到流中</span></div><div class="line">    result = oss.str(); <span class="comment">//获取转换后的字符并将其写入result</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">to_string(s1, <span class="number">10.5</span>); <span class="comment">//double到string</span></div><div class="line">to_string(s1, <span class="number">123</span>); <span class="comment">//int到string</span></div></pre></td></tr></table></figure>
<p>可以更进一步定义一个通用的转化模板，用于任意类型之间的转换。函数模板convert()含有两个模板参数out_type和in_type，功能是将in_value值转换成out_type类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> out_type, <span class="keyword">class</span> in_value&gt;</div><div class="line"><span class="function">out_type <span class="title">convert</span> <span class="params">(<span class="keyword">const</span> in_value &amp;t)</span></span>&#123;</div><div class="line">    <span class="built_in">stringstream</span> stream;</div><div class="line">    stream &lt;&lt; t; <span class="comment">//向流中传值</span></div><div class="line">    out_type result; <span class="comment">//这里存储转换结果</span></div><div class="line">    stream&gt;&gt;result; <span class="comment">//向result中写入值</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">double</span> d;</div><div class="line"><span class="built_in">string</span> salary;</div><div class="line"><span class="built_in">string</span> s = <span class="string">"23.323"</span>;</div><div class="line">s = convert&lt;<span class="keyword">double</span>&gt;(s);</div><div class="line">salary = convert&lt;<span class="built_in">string</span>&gt;(<span class="number">9000.0</span>);</div></pre></td></tr></table></figure>
<p>在进行多次转换的时候，必须调用stringstream的成员函数clear()函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</div><div class="line">    <span class="keyword">int</span> first, second;</div><div class="line">    stream&lt;&lt; <span class="string">"456"</span>; <span class="comment">//插入字符串</span></div><div class="line">    stream &gt;&gt; first; <span class="comment">//转换成int</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    stream.clear(); <span class="comment">//在进行多次转换前，必须清除stream</span></div><div class="line">    stream &lt;&lt; <span class="literal">true</span>; <span class="comment">//插入bool值</span></div><div class="line">    stream &gt;&gt; second; <span class="comment">//提取出int</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;string与stringstream&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="string与stringstream" scheme="https://muleimulei.github.io/tags/string%E4%B8%8Estringstream/"/>
    
  </entry>
  
  <entry>
    <title>C++的find函数</title>
    <link href="https://muleimulei.github.io/2017/08/05/c%E4%B8%8Ec++/C++%E7%9A%84find/"/>
    <id>https://muleimulei.github.io/2017/08/05/c与c++/C++的find/</id>
    <published>2017-08-05T07:43:47.952Z</published>
    <updated>2017-08-05T08:04:50.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>C++的find函数</p>
</blockquote>
<a id="more"></a>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>#include<algorithm></algorithm></p>
<p>函数实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp;val)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span> (first!=last)&#123;</div><div class="line">        <span class="keyword">if</span>(*first==val) <span class="keyword">return</span> first;</div><div class="line">        ++first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> last;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.push_back(<span class="string">"hello"</span>);</div><div class="line">    m.push_back(<span class="string">"hello2"</span>);</div><div class="line">    m.push_back(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例2<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.insert(<span class="string">"hello"</span>);</div><div class="line">    m.insert(<span class="string">"hello2"</span>);</div><div class="line">    m.insert(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>set，string自身有个find()函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; m;</div><div class="line">    m.insert(<span class="string">"hello"</span>);</div><div class="line">    m.insert(<span class="string">"hello2"</span>);</div><div class="line">    m.insert(<span class="string">"hello3"</span>);</div><div class="line">    <span class="keyword">if</span> (find(m.begin(), m.end(), <span class="string">"hello"</span>) == m.end())</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">//find函数返回类型 size_type</span></div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i"</span>)</span></span>;  </div><div class="line">    <span class="built_in">string</span> flag;</div><div class="line">    <span class="built_in">string</span>::size_type position;</div><div class="line">    <span class="comment">//find 函数 返回jk 在s 中的下标位置   </span></div><div class="line">    position = s.find(<span class="string">"jk"</span>);  </div><div class="line">    <span class="keyword">if</span> (position != s.npos)  <span class="comment">//如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295，  </span></div><div class="line">     &#123;  </div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"position is : "</span> &lt;&lt; position &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">     &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">     &#123;  </div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found the flag"</span> + flag;  </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;C++的find函数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="C++的find函数" scheme="https://muleimulei.github.io/tags/C-%E7%9A%84find%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL数据定义语句</title>
    <link href="https://muleimulei.github.io/2017/08/04/DataBase/sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/"/>
    <id>https://muleimulei.github.io/2017/08/04/DataBase/sql数据定义语句/</id>
    <published>2017-08-04T10:35:17.613Z</published>
    <updated>2017-08-04T12:30:03.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>SQL数据定义语句</p>
</blockquote>
<a id="more"></a>
<p>关系数据库系统支持三级模式结构，其模式，外模式和内模式中的基本对象有模式，视图和索引等。因此SQL的数据定义功能包括模式定义，表定义，视图和索引的定义。</p>
<h2 id="sql的数据定义语句"><a href="#sql的数据定义语句" class="headerlink" title="sql的数据定义语句"></a>sql的数据定义语句</h2><ol>
<li>模式<ul>
<li>创建：<code>CREATE SCHEMA</code></li>
<li>删除：<code>DROP SCHEMA</code></li>
</ul>
</li>
<li>表<ul>
<li>创建：<code>CREATE TABLE</code></li>
<li>删除：<code>DROP TABLE</code></li>
<li>修改：<code>ALTER TABLE</code></li>
</ul>
</li>
<li>视图<ul>
<li>创建：<code>CREATE VIEW</code></li>
<li>删除：<code>DROP VIEW</code></li>
</ul>
</li>
<li>索引<ul>
<li>创建：<code>CREATE INDEX</code></li>
<li>删除：<code>DROP INDEX</code></li>
<li>修改：<code>ALTER INDEX</code></li>
</ul>
</li>
</ol>
<p><strong>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表，视图和索引等数据库对象。</strong></p>
<h1 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h1><ol>
<li><p>定义模式<br> <code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;<code>，如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;。要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的<code>CREATE SCHEMA<code>的权限。目前，在<code>CREATE SCHEMA<code>中可以接受<code>CREATE TABLE<code>，<code>CREATE VIEW<code>和<code>GRANT<code>，也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表，视图，定义授权。即：<code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [ &lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt; ]<code>;</code></code></code></code></code></code></code></code></code></code></code></code></code></code></p>
</li>
<li><p>删除模式<br> <code>DROP SCHEMA &lt;模式名&gt; <cascade |="" rrestrict=""></cascade></code>，其中cascade和restrict两者必选其一。选择了cascade（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict（限制），表示如果该模式中已经定义了下属的数据库对象（如表，视图等），则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行drop schema语句。</p>
</li>
</ol>
<h1 id="基本表的定义，删除与修改"><a href="#基本表的定义，删除与修改" class="headerlink" title="基本表的定义，删除与修改"></a>基本表的定义，删除与修改</h1><ol>
<li><p>定义基本表<br> 创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语句使用<code>CREATE TABLE</code>语句定义基本表，其基本格式为：</p>
<p> <code></code></p>
<pre><code>CREATE TABLE &lt;表名&gt; (&lt;列名&gt;&lt;数据类型&gt; [列级完整性约束条件]
                    [,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]])
                    ...........
                    [,&lt;表级完整性约束条件&gt;]
</code></pre><p> </p>
<p> 建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。<strong> 如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级 </strong></p>
<p> <code></code></p>
<pre><code>CREATE TABLE SC
(
    Sno CHAR(9),
    Cno CHAR(4),
    Grade SMALLINT,
    PRIMARY KEY (Sno, Cno),  /* 主码由两个属性构成，必须作为表级完整性进行定义 */
    FOREIGN KEY (Sno) REFERENCES Student (Sno), /* 表级完整性约束条件，Sno是外码，被参照表是Student */
    FOREIGN KEY (Cno) REFERENCES Course (Cno) /* 表级完整性约束条件，Cno是外码，被参照表是Course */
)
</code></pre><p> </p>
</li>
<li><p>数据类型</p>
<ul>
<li>CHAR(N)，CHARACTER(N)：长度为n的定长字符串</li>
<li>VARCHAR(N)：最大长度为n的变长字符串</li>
<li>CLOB：字符串大对象</li>
<li>BLOB：二进制大对象</li>
<li>INT，INTEGER：长整数（4字节）</li>
<li>SMALLINT：短整形（2字节）</li>
<li>BIGINT：大整形(8整数)</li>
<li>NUMERIC(p,d)：定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字</li>
<li>DECIMAL(p,d)：同NUMERIC</li>
<li>REAL：取决于机器精度的单精度浮点数</li>
<li>DOUBLE PRECISION：取决于机器精度的双精度浮点数</li>
<li>FLOAT(n)：可选精度的浮点数，精度至少为n位数字</li>
<li>BOOLEAN：逻辑布尔值</li>
<li>DATE：日期，包含年，月，日，格式为yyyy-mm-dd</li>
<li>TIME：时间，包含一日的时，分，秒，格式为HH:MM:SS</li>
<li>TIMESTAMP：时间戳类型</li>
<li>INTERVAL：时间间隔类型</li>
</ul>
</li>
<li><p>修改基本表<br> <code></code></p>
<pre><code>ALTER TABLE &lt;表名&gt;
[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]]
[ADD &lt;表级完整性约束&gt;]
[DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]]
[DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT|CASCADE]]
[ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]
</code></pre><p> </p>
</li>
<li><p>删除基本表<br> <code>DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</code>。</p>
</li>
</ol>
<h1 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h1><ol>
<li><p>建立索引<br> <code></code></p>
<pre><code>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;
ON &lt;表名&gt;(&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt; [&lt;次序&gt;]] ...)
</code></pre><p> </p>
<ul>
<li>UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录</li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
</li>
<li><p>修改索引<br> <code> ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</code></p>
</li>
<li><p>删除索引<br> <code>DROP INDEX &lt;索引名&gt;</code></p>
</li>
</ol>
<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p><code><br>    SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [, &lt;目标列表达式&gt;] …<br>    FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;] | (<select 语句="">) [AS] &lt;别名&gt;<br>    [WHERE &lt;条件表达式&gt;]<br>    [GROUP BY &lt;列名 1&gt; [HAVING &lt;条件表达式&gt;]]<br>    [ORDER BY &lt;列名 2&gt; [ASC|DESC]]<br></select></code></p>
<blockquote>
<p>%（百分号）：代表任意长度（长度可以为0）的字符串。<br>_(下横线)：代表任意单个字符</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;SQL数据定义语句&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="SQL数据定义语句" scheme="https://muleimulei.github.io/tags/SQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>关系的完整性</title>
    <link href="https://muleimulei.github.io/2017/08/03/DataBase/%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <id>https://muleimulei.github.io/2017/08/03/DataBase/关系的完整性/</id>
    <published>2017-08-03T07:11:26.020Z</published>
    <updated>2017-08-03T08:07:16.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>关系的完整性</p>
</blockquote>
<a id="more"></a>
<p>关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时因该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。</p>
<p><strong> 关系模型中有三类完整性约束：实体完整性，参照完整性和用户定义的完整性 </strong>。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称为关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。</p>
<ol>
<li><p>实体完整性<br>实体完整性规则：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（null value）。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p>实体完整性规则说明如下：</p>
<ol>
<li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li>
<li>现实世界中的实体是可区分的，即他们具有某种唯一性标识。</li>
<li>相应的，关系模型中以主码作为唯一性标识。</li>
<li>主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的主体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性。</li>
</ol>
</li>
</ol>
<blockquote>
<p>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。关系R和S不一定是不同的关系。</p>
</blockquote>
<ol>
<li>参照完整性<br>若属性（属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R与S不一定是不同的关系），则对于R中的每个元组在F上的值必须：<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元组的主码值。</li>
</ul>
</li>
</ol>
<ol>
<li>用户定义的完整性<br> 任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反应某一具体应用所涉及的数据必须满足的语义要求。<strong> 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需要由应用程序承担这一功能 </strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;关系的完整性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="DataBase" scheme="https://muleimulei.github.io/categories/DataBase/"/>
    
    
      <category term="关系的完整性" scheme="https://muleimulei.github.io/tags/%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>module的加载实现</title>
    <link href="https://muleimulei.github.io/2017/07/31/JavaScript/module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>https://muleimulei.github.io/2017/07/31/JavaScript/module的加载实现/</id>
    <published>2017-07-31T07:37:28.196Z</published>
    <updated>2017-08-03T07:10:50.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>module的加载实现</p>
</blockquote>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><ol>
<li>传统方法</li>
</ol>
<p>在HTML网页中，浏览器通过<code>script</code>标签加载JavaScript脚本<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="comment">//module code</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/JavaScript"</span> <span class="attr">src</span>=<span class="string">"path/to/Module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，由于浏览器的脚本的默认语言是JavaScript，因此<code> type=”application/javascript” </code>可以省略。</p>
<p>默认情况下，浏览器同步加载JavaScript脚本，即渲染引擎遇到script标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>下面有两种异步加载的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"mymodule.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"mymodule.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>上面代码中，script标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一命令，就会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。</p>
<blockquote>
<p>defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
</blockquote>
<ol>
<li>加载规则</li>
</ol>
<p>浏览器加载ES6模块，也使用script标签，但要加入type=”module”属性。<br><code> <script type="module" src="foo.js"></script> </code>上面代码在网页插入foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。</p>
<p>浏览器对于带有type=”module”的script，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，在执行模块脚本，等同于打开了script标签的defer属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;!-- 等同于 --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>script标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，在恢复渲染。<br><code> <script type="module" src="foo.js" async></script> </code><br>ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span>&gt;</div><div class="line">    <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./util.js'</span></div><div class="line">    <span class="comment">// other code</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>对于外部的模块的脚本，有几点注意。</p>
<blockquote>
<ol>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code></li>
<li>模块之中，可以使用import命令加载其它模块(<strong> .js后缀不可省略，需要提供绝对url与相对url </strong>)，也可以使用export命令输出绝对接口。</li>
<li>模块之中，顶层的this关键字返回undefined，而不是window。也就是说，在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// 句法错误，严格模式禁止删除变量</span></div></pre></td></tr></table></figure>
<p><strong> 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在es6模块之中 </strong></p>
<p><code>const isNotModuleScript = this !== undefined</code></p>
<ol>
<li>ES6模块与CommonJs模块的差异</li>
</ol>
<p>它们有两个重大差异</p>
<ul>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用。</li>
<li>CommonJs 模块是运行时加载，ES6模块是编译时输出接口</li>
</ul>
<p>第二个差异是因为CommonJs加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">counter</span>: counter,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div><div class="line">上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</div><div class="line"></div><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  get counter() &#123;</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">incCounter</span>: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
</blockquote>
<p>export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mod.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</div></pre></td></tr></table></figure></p>
<p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// x.js</div><div class="line">import &#123;c&#125; from &apos;./mod&apos;;</div><div class="line">c.add();</div><div class="line"></div><div class="line">// y.js</div><div class="line">import &#123;c&#125; from &apos;./mod&apos;;</div><div class="line">c.show();</div><div class="line"></div><div class="line">// main.js</div><div class="line">import &apos;./x&apos;;</div><div class="line">import &apos;./y&apos;;</div><div class="line">现在执行main.js，输出的是1。</div><div class="line"></div><div class="line">$ babel-node main.js</div><div class="line">1</div></pre></td></tr></table></figure>
<p>这就证明了x.js和y.js加载的都是C的同一个实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;module的加载实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器加载&quot;&gt;&lt;a href=&quot;#浏览器加载&quot; class=&quot;headerlink&quot; title=&quot;浏览器加载&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="HTML5" scheme="https://muleimulei.github.io/tags/HTML5/"/>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue的非父子组件通信</title>
    <link href="https://muleimulei.github.io/2017/07/30/Vue/%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>https://muleimulei.github.io/2017/07/30/Vue/非父子组件通信/</id>
    <published>2017-07-30T14:12:52.333Z</published>
    <updated>2017-07-30T14:32:18.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Vue的非父子组件通信</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>可以通过vuex和event bus来解决</p>
</blockquote>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>我们要实现的效果是：</p>
<img src="/assets/segment/vue1.jpg">
<p>上下分别为foo组件和bar组件，他们之间是非父子关系，分别点击各自的button，另一个组件的count对应增加。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>非父子组件通信<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bar</span>&gt;</span><span class="tag">&lt;/<span class="name">bar</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>JavaScript的实现是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册一个空的Vue实例，作为“中转站”</span></div><div class="line"><span class="keyword">var</span> eventBus = <span class="keyword">new</span> Vue(&#123;&#125;)</div><div class="line"><span class="comment">//foo组件</span></div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;&lt;p&gt;the count of foo is &#123;&#123;fooCount&#125;&#125;&lt;/p&gt;</span></div><div class="line">                &lt;button @click="addBar"&gt;add bar's count&lt;/button&gt;</div><div class="line">            &lt;/div&gt;`,</div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">fooCount</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">        addBar () &#123;</div><div class="line">            eventBus.$emit(<span class="string">'addBar'</span>,<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted () &#123;</div><div class="line">        eventBus.$on(<span class="string">'addFoo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.fooCount += num    </div><div class="line">        &#125;.bind(<span class="keyword">this</span>)) <span class="comment">//这里必须将this绑定到组件实例上，如果不使用bind，也可以使用箭头函数。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//bar组件</span></div><div class="line"><span class="keyword">var</span> bar = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;&lt;p&gt;the count of bar is &#123;&#123;fooCount&#125;&#125;&lt;/p&gt;</span></div><div class="line">                &lt;button @click="addBar"&gt;add foo's count&lt;/button&gt;</div><div class="line">            &lt;/div&gt;`,</div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">barCount</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">        addFoo () &#123;</div><div class="line">            eventBus.$emit(<span class="string">'addFoo'</span>,<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted () &#123;</div><div class="line">        eventBus.$on(<span class="string">'addBar'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.barCount += num</div><div class="line">        &#125;.bind(<span class="keyword">this</span>)) <span class="comment">//这里必须将this绑定到组件实例上，如果不使用bind，也可以使用箭头函数。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue (&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">        foo,</div><div class="line">        bar</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>以上就实现了一个简易的非父子组件之间的通信方式。通过event bus，在一个组件创建时的钩子函数中监听某个事件，而在需要与其进行通信的组件中触发这个函数，同时交换数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Vue的非父子组件通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://muleimulei.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Git的reset与checkout的区别</title>
    <link href="https://muleimulei.github.io/2017/07/29/git/git%E7%9A%84reset%E4%B8%8Echeckout%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://muleimulei.github.io/2017/07/29/git/git的reset与checkout的区别/</id>
    <published>2017-07-29T04:12:25.099Z</published>
    <updated>2017-07-29T06:26:48.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Git的reset与checkout的区别</p>
</blockquote>
<a id="more"></a>
<h2 id="Head，Index，Working-Director"><a href="#Head，Index，Working-Director" class="headerlink" title="Head，Index，Working Director"></a>Head，Index，Working Director</h2><ol>
<li><p>Git里面的三个重要区域</p>
<ul>
<li>HEAD指向最近一次commit里的所以snapshot</li>
<li>Index 缓存区域，只有Index区域里的东西才可以被commit</li>
<li><p>Working Directory 用户操作区域</p>
<img src="/assets/segment/git1.png">
</li>
</ul>
</li>
</ol>
<h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>当你checkout分支的时候，git做了这么三件事情</p>
<pre><code>&gt; 将HEAD指向那个分支的最后一次commit
&gt; 将HEAD指向的commit里所有的文件的snapshot替换掉Index区域里面的内容
&gt; 将Index区域里面的内容填充到Working Directory里
</code></pre><p>所以你可以发现，HEAD，Index，Working Directory这个时候里的内容都是一摸一样的。<br><strong> 注意：一般会误解为，Index中的内容是空的，只有git add后才会有东西。实际上不是，Index里一直是有东西的。 </strong>，所以，git里的所有操作就是对这三个区域的状态的操作。</p>
<h2 id="Changed"><a href="#Changed" class="headerlink" title="Changed"></a>Changed</h2><p>如果你在Working Directory里修改了文件，git会发现Working Directory里面的内容与Index区域里面的内容不一致了。这个时候<code>git status</code>的结果就是：<br><code>Changes not staged for commit</code></p>
<h2 id="Staged"><a href="#Staged" class="headerlink" title="Staged"></a>Staged</h2><p>一个文件仅仅changed是不能够被commit的，git要求只能提交Index里的东西。所以需要git add，这个命令的意思是，把changed的文件的内容同步到Index区域里。这样Working Directory和Index区域的内容就一致了，这个过程称之为stage，这个时候<code>git status</code>的结果是：<code>Changes to be commited</code></p>
<h2 id="Commited"><a href="#Commited" class="headerlink" title="Commited"></a>Commited</h2><p>最后，就可以提交了<code>git commit</code>，这样，就把HEAD的状态和Index以及Working Directory就形成了一致了。</p>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>reset是用来修改提交历史的，想象这种情况，如果你在2天前提交了一个东西，突然发现这个提交是有问题的。这个时候你有两个选择，要么使用<code>git revert</code>（推荐），要么使用<code>git reset</code>。</p>
<img src="/assets/segment/git2.png">
<p>上图可以看到git reset是会修改版本历史的，他会丢弃掉一些版本历史。而git revert是根据那个commit逆向生成一个新的commit，版本历史是不会破会的。</p>
<h1 id="已经push到远程仓库的commit不允许reset"><a href="#已经push到远程仓库的commit不允许reset" class="headerlink" title="已经push到远程仓库的commit不允许reset"></a>已经push到远程仓库的commit不允许reset</h1><p>上面已经讲了，<code>git reset</code>是会丢弃掉commit的。如果commit已经被push到远程仓库上了，也就意味着其它开发人员就可能基于这个commit形成了新的commit，这时你去reset，就会造成其它开发人员的提交历史莫名其妙的丢失，或者其它灾难性的后果。</p>
<p><strong> 因此，一旦commit已经被push到远程仓库，那么是坚决不允许去reset它的。 </strong></p>
<h1 id="不带文件参数的reset"><a href="#不带文件参数的reset" class="headerlink" title="不带文件参数的reset"></a>不带文件参数的reset</h1><p>前面章节已经说到Git有三个区域，Git的所有操作实际上是在操作这三个区域的状态（或内容）。<br>git reset配合不同的参数，对这三个区域会产生不同的影响。reset实际上有三个步骤，根据不同的参数可以决定执行哪个步骤(<code>–soft,–mixed,–hard</code>)。</p>
<pre><code>1. 改变HEAD所指向的commit(--soft)
2. 执行第一步，将Index区域更新为HEAD所指向的commit里包含的内容(--mixed)
3. 执行第1,2步，将Working Directory区域更新为HEAD所指向的commit里包含的内容(--hard)
</code></pre><h1 id="带文件参数的reset"><a href="#带文件参数的reset" class="headerlink" title="带文件参数的reset"></a>带文件参数的reset</h1><p>上面讲到的git reset实际上不带参数的，那带上文件参数呢？</p>
<ol>
<li>HEAD不会动</li>
<li>将那个commit的snapshot里的文件放到Index区域中</li>
</ol>
<p><strong> 需要注意的是带文件参数的git reset没有–hard, –soft这两个参数。只有–mixed参数。 </strong></p>
<h1 id="unstage"><a href="#unstage" class="headerlink" title="unstage"></a>unstage</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset file.txt</div><div class="line">git reset --mixed HEAD file.txt</div></pre></td></tr></table></figure>
<p>上面这两条命令是一样的，都是reset到HEAD上，这个例子的意义在于，unstage file，当你把一个文件stage到Index区域后悔了，那么只需把Index区域里的这个文件恢复到最近一次commit的状态（也就是HEAD），那就相当于unstage。</p>
<h1 id="恢复到历史版本"><a href="#恢复到历史版本" class="headerlink" title="恢复到历史版本"></a>恢复到历史版本</h1><p>下面这个命令就是将某个文件恢复到历史版本上。<br><code>git reset eb23er file.txt</code><br>这个例子的意思在于，把某个文件恢复到Index区域里，然后直接commit，这样就等于把这个文件恢复到历史版本了，这样依赖你都不需要改动working Directory了。</p>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>前面讲到的checkout是会修改HEAD的指向，变更Index区域的内容，修改Working Directory里的内容。<br>这看上去很像reset –hard，但两者有两个重要的差别</p>
<ol>
<li>reset会把working directory里面所有的内容都更新掉，checkout不会去修改你在working Directory里修改过的文件。</li>
<li>reset把branch移动到HEAD指向的地方，checkout则把HEAD移动到另一个分支。</li>
</ol>
<p>第二个区别可能有点那以理解，举例来说：假若你有两个分支master和develop，这两个分支指向不一样的commit，我们现在在develop分支上（HEAD指向的地方）</p>
<p>如果我们<code>git reset master</code>，那么develop就会指向master所指向的那个commit。<br>如果我们<code>git checkout master</code>，那么develop不会动，只有HEAD会移动。HEAD会指向master。看图：</p>
<img src="/assets/segment/git3.png">
<h1 id="带文件参数"><a href="#带文件参数" class="headerlink" title="带文件参数"></a>带文件参数</h1><p>当执行git checkout [branch] file，checkout干了这件事情：</p>
<ol>
<li>更新了index区域里面的file文件的内容</li>
<li>更新了working directory里file文件的内容</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Git的reset与checkout的区别&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git" scheme="https://muleimulei.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://muleimulei.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>自制滚动条</title>
    <link href="https://muleimulei.github.io/2017/07/28/CSS3/%E8%87%AA%E5%88%B6%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://muleimulei.github.io/2017/07/28/CSS3/自制滚动条/</id>
    <published>2017-07-28T13:16:39.590Z</published>
    <updated>2017-07-28T14:05:44.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>自制滚动条</p>
</blockquote>
<a id="more"></a>
<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>webkit支持拥有overflow属性的区域，列表框，下拉菜单，textarea的滚动条的自定义样式。</p>
<h2 id="滚动条的组成"><a href="#滚动条的组成" class="headerlink" title="滚动条的组成"></a>滚动条的组成</h2><ul>
<li>::-webkit-scrollbar  滚动条整体部分</li>
<li>::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动</li>
<li>::-webkit-scrollbar-track 滚动条的轨道</li>
<li>::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置</li>
<li>::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分除去</li>
<li>::-webkit-scrollbar-corner边角，即两个滚动条的交汇处</li>
<li>::-webkit-resizer 两个滚动条的交汇处上用于通过拖到调整元素大小的控件  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/  </div><div class="line">::-webkit-scrollbar  </div><div class="line">&#123;  </div><div class="line">    width: 16px;  </div><div class="line">    height: 16px;  </div><div class="line">    background-color: #F5F5F5;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">/*定义滚动条轨道 内阴影+圆角*/  </div><div class="line">::-webkit-scrollbar-track  </div><div class="line">&#123;  </div><div class="line">    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);  </div><div class="line">    border-radius: 10px;  </div><div class="line">    background-color: #F5F5F5;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">/*定义滑块 内阴影+圆角*/  </div><div class="line">::-webkit-scrollbar-thumb  </div><div class="line">&#123;  </div><div class="line">    border-radius: 10px;  </div><div class="line">    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);  </div><div class="line">    background-color: #555;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="详细设置"><a href="#详细设置" class="headerlink" title="详细设置"></a>详细设置</h2><p>定义滚动条就是利用伪元素与伪类，那什么是伪元素与伪类呢？<br>伪类如:link，:focus，:hover，此外，css3中又增加了许多伪类选择器，如:nth-child，:last-child，:nth-last-of-type等。</p>
<p>CSS中的伪元素大家以前看过，:first-line，:first-letter，:before，:after。那么在CSS3中，伪元素进行了调整，在以前的基础上增加了一个 “:”，也就是变成了 “::first-line，::first-letter，::before，::after”，另外，CSS3还增加了一个”::selection”。两个”:”和一个”::”，在CSS3中主要用来区分伪类和伪类选择器。</p>
<p>webkit的伪类和伪元素的实现很强，可以把滚动条当成一个页面元素来定义，再结合一些高级的CSS3属性，比如渐变，圆角，RGBA等等。如果有些地方要用图片，可以把图片转换成Base64，不然每次都得加载那个图片，增加请求数。</p>
<p>任何对象都可以设置：边框，阴影，背景图片等等，创建的滚动条任然会按照操作系统本身的设置来完成其交互的行为。下面的伪类可以应用到上面的伪元素中。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">:horizontal  </div><div class="line">//horizontal伪类适用于任何水平方向上的滚动条  </div><div class="line">:vertical  </div><div class="line">//vertical伪类适用于任何垂直方向的滚动条  </div><div class="line">:decrement  </div><div class="line">//decrement伪类适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮  </div><div class="line">:increment  </div><div class="line">//increment伪类适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮  </div><div class="line">:start  </div><div class="line">//start伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面  </div><div class="line">:end  </div><div class="line">//end伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面  </div><div class="line">:double-button  </div><div class="line">//double-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。  </div><div class="line">:single-button  </div><div class="line">//single-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。  </div><div class="line">:no-button  </div><div class="line">no-button伪类表示轨道结束的位置没有按钮。  </div><div class="line">:corner-present  </div><div class="line">//corner-present伪类表示滚动条的角落是否存在。  </div><div class="line">:window-inactive  </div><div class="line">//适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。  </div><div class="line">::-webkit-scrollbar-track-piece:start &#123;  </div><div class="line">/*滚动条上半边或左半边*/  </div><div class="line">&#125;  </div><div class="line">::-webkit-scrollbar-thumb:window-inactive &#123;  </div><div class="line">/*当焦点不在当前区域滑块的状态*/  </div><div class="line">&#125;  </div><div class="line">::-webkit-scrollbar-button:horizontal:decrement:hover &#123;  </div><div class="line">/*当鼠标在水平滚动条下面的按钮上的状态*/  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;自制滚动条&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS3" scheme="https://muleimulei.github.io/categories/CSS3/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue实例与生命周期</title>
    <link href="https://muleimulei.github.io/2017/07/28/Vue/Vue%E5%AE%9E%E4%BE%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://muleimulei.github.io/2017/07/28/Vue/Vue实例与生命周期/</id>
    <published>2017-07-28T02:51:46.214Z</published>
    <updated>2017-07-28T07:03:47.514Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Vue实例与生命周期</p>
</blockquote>
<a id="more"></a>
<p>Vue的实例是Vue框架的入口，其实也就是前端的viewModel，它包含了页面中的业务逻辑，数据模型等，当然他也有自己的一系列的生命周期的事件钩子，辅助我们进行对整个Vue实例生成，编译，挂载，销毁等过程进行JavaScript控制。</p>
<ol>
<li><p>Vue实例初始化的选项配置对象详解</p>
<ul>
<li><p>Vue实例的data对象</p>
<ul>
<li>Vue的实例的数据对象data我们已经用了很多，数据绑定离不开data里的数据。他也是Vue里的核心属性。它是Vue绑定数据到HTML标签的数据源泉，另外Vue框架会自动监视data里面的数据变化，自动更新数据到HTML标签上去。<strong>本质原理是：Vue会自动将data里面的数据进行递归抓取换成getter和setter,然后就可以自动更新HTML标签了，所以用getter和setter老的浏览器Vue支持不够好</strong>。<ul>
<li>data对象的类型<ul>
<li>类型是Object或者Function。</li>
<li>如果是组件对象，data必须是Function类型</li>
</ul>
</li>
<li>实例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建普通的Vue实例</span></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">data</span>: data    </div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//组件定义，Vue.extend()中data必须是函数</span></div><div class="line"><span class="keyword">var</span> component = Vue.extend(&#123;</div><div class="line">    <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//这里必须是函数！！！</span></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">a</span>: <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue实例的computed</p>
<ul>
<li>介绍<br>  Vue的计算属性会自动混入Vue的实例中。所有getter和setter的this上下文会自动地绑定为Vue实例。</li>
<li>类型<br>  <code> {键：函数} {[key：string]: Function | {get: Function, set: Function}} </code>。 当然，可以省略setter和getter，那么值就可以是普通的函数，但是必须有返回值。</li>
<li>实例  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">data</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</div><div class="line">    <span class="attr">computed</span>: &#123;</div><div class="line">        aDouble () &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></div><div class="line">        &#125;,</div><div class="line">        aPlus () &#123;</div><div class="line">            set () &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            get () &#123;</div><div class="line">                thia.a = v - <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>methods</p>
<ul>
<li>类型 {[key: string] : Function}</li>
<li>详细<br>  methods 将被混入到Vue实例中。可以直接通过Vm实例访问这些方法，或者在指令表达式中使用。方法中的this自动绑定为Vue实例。<strong>注意：不应该使用箭头函数来定义method函数（例如 plus: ()=&gt; this.a++）。理由是箭头函数绑定了父级作用域的上下文，所以this将不会按照期望指向Vue实例，this.a将会是undefined。</strong></li>
<li>实例  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">data</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">        plus () &#123;</div><div class="line">            <span class="keyword">this</span>.a++</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;)</div><div class="line">vm.plus()</div><div class="line">vm.a</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>类型 {[key: string]: string | Function | Object}</li>
<li>详细：<br>  一个对象，键是需要观察的表达式，值是对应回掉函数，也可以是方法名，或者包含选项的对象。Vue实例将会在实例化时调用$watch，遍历watch对象的每一个属性。</li>
<li>实例：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">        <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">c</span>: <span class="number">3</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">watch</span>: &#123;</div><div class="line">        <span class="comment">//监控a变量变化时，自动执行此函数</span></div><div class="line">        a: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"new : %s, old: %s"</span>, val,oldVal)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">c</span>: &#123;</div><div class="line">            <span class="attr">handle</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>)</span>&#123;&#125;,</div><div class="line">            <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置el的详解</p>
<ul>
<li>类型 <code>string | HTMLElement</code><br>  限制：只在由new创建的实例中遵循</li>
<li>详细<br>  提供一个在页面上已存在的DOM元素作为Vue实例的挂载目标，也就是说Vue绑定数据到哪里去找。可以是css选择器，也可以是一个HTMLElement实例。在实例挂载之后，元素可以用vm.$el访问。如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显示调用vm.$mount()手动开始编译。</li>
<li>实例  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">    ....</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Vue实例的生命周期<br>  Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载DOM，渲染，更新，卸载等一系列过程，我们称这为Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<strong> 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们达到控制整个过程的目的，在这些事件响应方法中的this直接指向的是Vue的实例。 </strong></p>
<img src="/assets/segment/vue_life.png">
<ul>
<li><p>Vue提供的可以注册的钩子函数在图上的红色框标注：</p>
<ul>
<li><p>beforeCreate：在实例初始化之后，数据观测（data observer）和event/watcher事件配置之前被调用。</p>
</li>
<li><p>created：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event事件的回调。然而，挂载阶段还没开始，$el属性目前不可见。</p>
</li>
<li><p>beforeMount：在挂载开始之前被调用：相关的render函数首次被调用。</p>
</li>
<li><p>mounted：el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。</p>
</li>
<li><p>beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步更改状态，这不会触发附加的重渲染过程。</p>
</li>
<li><p>updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免再次期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p>
</li>
<li><p>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</p>
</li>
<li><p>destroyd： Vue实例销毁后调用。调用后，Vue实例指示的所有的东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
</li>
</ul>
</li>
<li><p>实例1</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue生命周期<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; number &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"number"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">         <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;         </div><div class="line">              <span class="attr">el</span>: <span class="string">'#app'</span>,               </div><div class="line">              <span class="attr">data</span>: &#123;                   </div><div class="line">                <span class="attr">number</span>: <span class="number">1</span></div><div class="line">              &#125;,</div><div class="line">              <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'beforeCreate 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">cteated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'cteated 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">beforeMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'beforeMount 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'mounted 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">beforeUpdate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'beforeUpdate 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'updated 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'beforeDestroy 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">              <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'destroyed 钩子执行...'</span>);</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.number)</div><div class="line">              &#125;,</div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>实例2</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Axio <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">//这是一个轻量级的ajax库，import是es6模块导入的语法</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'app'</span>,</div><div class="line">    <span class="attr">component</span>: &#123;&#125;,</div><div class="line">    <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">list</span>: []</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//挂载完成后的生命周期钩子注册</span></div><div class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//等待下一次更新完成后执行业务处理代码</span></div><div class="line">            Axio.get(<span class="string">'/api/menulist'</span>,&#123; <span class="comment">//将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新</span></div><div class="line">                params:&#123;&#125;</div><div class="line">            &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.list = res.data    </div><div class="line">            &#125;.bind(<span class="keyword">this</span>))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue实例的全局配置</p>
<ul>
<li><p>silent</p>
<ul>
<li>类型：boolean</li>
<li>默认值：false</li>
<li>用法：<figure class="highlight plain"><figcaption><span>= true</span><a href="//取消Vue所有的日志与警告```">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- optionMergeStrategies</div><div class="line">    + 类型：&#123;[key: string]: Function&#125;</div><div class="line">    + 默认值：&#123;&#125;</div><div class="line">    + 用法：</div><div class="line">        ```JavaScript</div><div class="line">            Vue.config.optionMergeStrategies._my_option = function (parent, child, vm)&#123;</div><div class="line">                return child+1</div><div class="line">            &#125;</div><div class="line">            const Profile = Vue.extend(&#123;</div><div class="line">                _my_option: 1</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            //Profile.options._my_option = 2</div><div class="line">            //自定义合并策略的选项</div><div class="line">            //合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入</div></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>devtools</p>
<ul>
<li>类型：boolean</li>
<li>默认值：true （生产版为false）</li>
<li>用法：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//务必在加载Vue之后，立即同步设置以下内容</span></div><div class="line">Vue.config.devtools = <span class="literal">true</span></div><div class="line"><span class="comment">//配置是否允许vue-devtools检查代码。开发版本默认为true，生产版本默认为false</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>errorHandle</p>
<ul>
<li>类型：Function</li>
<li>默认值：默认抛出错误</li>
<li>用法：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm</span>)</span>&#123; <span class="comment">//指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和Vue实例。</span></div><div class="line">    <span class="comment">//handle error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>keyCodes</p>
<ul>
<li>类型：{[key:string]: number | Array}</li>
<li>默认值： {}</li>
<li>用法：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.config.keyCodes = &#123;</div><div class="line">    <span class="attr">v</span>: <span class="number">86</span>,</div><div class="line">    <span class="attr">f1</span>: <span class="number">112</span>,</div><div class="line">    <span class="attr">mediaPlayPause</span>: <span class="number">179</span>,</div><div class="line">    <span class="attr">up</span>: [<span class="number">38</span>, <span class="number">87</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue的全局API</p>
<ul>
<li><p>Vue.nextTick([{callback: Function} , {context: Object}])</p>
<ul>
<li>用法：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改数据</span></div><div class="line">vm.msg = <span class="string">"hello"</span></div><div class="line"><span class="comment">//DOM还没有更新</span></div><div class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//DOM更新了    </span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Vue.set([{object: Object}, {key: string}, {value: any}])</p>
<ul>
<li>用法：设置对象的属性，如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制。注意对象不能是Vue实例，或者是Vue实例的根数据对象。</li>
</ul>
</li>
<li><p>Vue.compile</p>
<ul>
<li>语法：<code>Vue.compile(template)</code></li>
<li>参数：{template: string}</li>
<li>用法：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在render函数中编译模板字符串。只在独立构建时有效</span></div><div class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">"&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;"</span>)</div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">data</span>: &#123;</div><div class="line">        <span class="attr">msg</span>: <span class="string">'hello'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: res.render,</div><div class="line">    <span class="attr">staticRenderFns</span>: res.staticRenderFns</div><div class="line">&#125;)</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Vue实例与生命周期&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://muleimulei.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>javaScript获取css样式</title>
    <link href="https://muleimulei.github.io/2017/07/17/JavaScript/javaScript%E8%8E%B7%E5%8F%96css%E6%A0%B7%E5%BC%8F/"/>
    <id>https://muleimulei.github.io/2017/07/17/JavaScript/javaScript获取css样式/</id>
    <published>2017-07-17T09:19:31.150Z</published>
    <updated>2017-07-17T09:49:27.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>javaScript获取css样式</p>
</blockquote>
<a id="more"></a>
<h2 id="css样式分为行内样式与外部样式"><a href="#css样式分为行内样式与外部样式" class="headerlink" title="css样式分为行内样式与外部样式"></a>css样式分为行内样式与外部样式</h2><ol>
<li>javaScript获得行内样式<br> 可以使用<code>ele.style.属性名称</code>(如果遇到属性名称带有‘-’，需要使用驼峰方法，例如background-color改为backgroundColor)；</li>
<li>javaScript获得外部样式(getComputedStyle可以获得style的值也可以获得外部样式表的css)<br> 获得外部样式可以使用浏览器提供的<code>window.getComputedStyle(ele,null)</code>，这里的ele就是需要操作的对象，第二个参数是指定一个伪元素匹配，常规的元素用不上，直接使用null。但这个getComputedStyle并不支持IE9以下的浏览器，但是ie有它自己支持的方法：ele.currentStyle;</li>
<li>ele.style.属性名和ele.cssText以及getComputedStyle(obj,null)有什么区别？<ul>
<li>ele.style.属性名：这里获得的style可以获得属性值，也可以进行修改</li>
<li>ele.cssText: 其实跟style差不多，只不过它是获得多个css样式，也是生成在行内样式中。</li>
<li>getComputedStyle(obj,null)： 只能获取不能修改，并且返回的css是一个CSSStyleDecoration对象集合。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;javaScript获取css样式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>javascript事件解读</title>
    <link href="https://muleimulei.github.io/2017/07/16/JavaScript/javaScript%E4%BA%8B%E4%BB%B6%E8%A7%A3%E8%AF%BB/"/>
    <id>https://muleimulei.github.io/2017/07/16/JavaScript/javaScript事件解读/</id>
    <published>2017-07-16T13:24:42.982Z</published>
    <updated>2017-07-17T09:18:24.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>javascript事件解读</p>
</blockquote>
<a id="more"></a>
<p>与浏览器进行交互的时候浏览器会触发各种事件。这样，我们就可以编写javascript，通过监听某一个事件，来实现某些功能扩展。例如监听load事件，显示欢迎信息，</p>
<h2 id="基础事件操作"><a href="#基础事件操作" class="headerlink" title="基础事件操作"></a>基础事件操作</h2><ol>
<li><p>监听事件<br> 浏览器会根据某些操作触发对应事件，如果我们需要针对某些事件进行处理，则需要监听这个事件。监听事件主要有以下几种方法：</p>
<ul>
<li><p><strong>HTML内联属性</strong><br>  HTML元素里面直接填写事件有关属性，属性值为javascript代码，即可在触发该事件的时候，执行属性值的内容。<br>  例如：<code>&lt;button onclick=&quot;alert(&#39;click&#39;)&quot;&gt;&lt;/button&gt;</code>,onclick属性表示触发click，属性值的内容会在单击该HTML节点时执行。显而易见，使用这种方法，javascript代码与HTML代码耦合在了一起，不便于维护与开发。所以除非在必须使用的情况下（例如统计连接点击数据）下，尽量避免使用这种方法。</p>
</li>
<li><p><strong>DOM属性绑定</strong><br>  也可以直接设置DOM属性来指定某个事件对应的处理函数，这个方法比较简单：<code>element.onclick = function(){alert(&#39;click&#39;);}</code>，上面代码就是监听element节点的click事件。他比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为element绑定一个回调函数，会覆盖掉之前回调函数的内容。<br>  虽然也可以用一些方法实现多个绑定，但还是推荐下面的标准事件监听函数。</p>
</li>
<li><p><strong>使用事件监听函数</strong><br>  标准的事件监听函数如下： <code>element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;)</code>。表示在element这个对象上面添加一个事件监听器，当监听到有<event-name>事件发生的时候，调用<callback>这个回调函数。至于<use-capture>这个参数，表示该事件监听是在“捕获”阶段中监听（设置为true）还是在“冒泡”阶段中监听（设置为false）。关于捕获与冒泡，会在下面讲解。<br>  用标准事件监听函数改写上面的例子：<code>var btn = document.querySelector(&#39;button);btn.addEventListener(&#39;click&#39;,function(){alert(&#39;click&#39;);},false);</code>。</use-capture></callback></event-name></p>
</li>
</ul>
</li>
<li><p>移除事件监听<br> 当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用removeEventListener方法：<code>element.removeEventListener(&lt;event-name&gt;,&lt;callback&gt;,&lt;use-capture&gt;)</code>,需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：<code>var fun = function(){};element.addEventListener(&#39;click&#39;,fun,false);    element.removeEventListener(&#39;click&#39;,fun,false);</code>。</p>
</li>
<li><p>事件触发过程</p>
<img src="/assets/segment/7.jpg">
 <iframe src="/assets/event.html" width="600" height="550" frameborder="0" allowfullscreen></iframe>
<ul>
<li><strong>捕获阶段</strong><br>  当我们在DOM树的某个节点发生了一些操作(例如单击，鼠标移动上去)，就会有一个事件发射过去。这个事件从window发出，不断经过下级节点直到目标节点。在到达目标节点之前的过程，就是捕获阶段。所有经过的节点，都会触发这个事件。捕获阶段的任务就是建立这个事件传递路线，以便后面冒泡阶段顺着这条路线返回Window。监听某个在捕获阶段触发的事件，需要在事件监听函数传递第三个参数true。<code>element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;,true)</code>，但一般我们使用false，会在后面说明。</li>
<li><strong>目标阶段</strong><br>  当事件传递到触发目标节点那里，最终在目标节点上触发这个事件，就是目标阶段。需要注意的是，事件触发的目标总是在最底层的节点。</li>
<li><strong>冒泡阶段</strong><br>  当事件到达目标节点之后，就会沿着原路返回，由于这个过程类似于水泡从底部浮动到顶部，所以称之为冒泡阶段。<br>  **在实际使用中，你并不需要把事件监听函数准确绑定到最底层的节点也可以正常工作。比如在上例，你想为<div>绑定单击时的回调函数，你无须为这个<div>下面的所有子节点全部绑定单击事件，只需要为<div>这一节点绑定即可。因为发生它子节点的单击事件，都会冒泡上去，发生在<div>上面。</div></div></div></div></li>
</ul>
</li>
<li><p>为什么不用第三个参数true？<br> 这时因为IE浏览器不支持在捕获阶段监听事件，为了统一而设置的，毕竟IE浏览器的份额是不可忽略的。</p>
</li>
<li><p>使用事件代理提升性能<br> 因为事件有冒泡机制，所有子节点的事件都会顺着父级节点跑回去，所以我们可以通过监听父级节点来实现监听子节点的功能，这就是事件代理。</p>
<p> 使用事件代理的优势：</p>
<ul>
<li>减少了事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。</li>
<li>动态变化的DOM结构，任然可以监听。当一个DOM动态创建之后，不会带有任何事件监听，除非你重新执行监听事件函数，而使用事件监听无需担忧这个问题。为了简单，使用jquery来实现普通事件绑定和事件处理。目标是监听所有a连接的单击事件。1. 常规的事件绑定方法，jquery会循环每一个a结构并绑定事件监听函数。 2. 事件监听的方法，jquery只为父元素绑定事件监听函数，因为父元素下面会有很多无关节点也会触发click事件，所以在on函数里传递了第二个参数，表示只监听a子节点的事件。<em>*他们都可以正常工作，但是当我动态创建新DOM结构的时候，第一个方法问题出现了，新创建的结构没有绑定事件，所以无法执行回调函数。而第二个方法工作很好，因为点击新建的DOM，它的事件会冒泡到父级节点进行处理</em>。*如果使用原生的方法实现事件代理，需要注意过滤非目标节点，可以通过id，class或者tagname等等，例如：<code>ele.addEventListener(&#39;click&#39;,function(event){ //判断是否为a节点 if(event.target.tagName==&#39;A&#39;){ // 执行a的交互}}，false)</code>。</li>
</ul>
</li>
<li><p>停止事件冒泡<br> 所有的事情都会有对立面，事件的冒泡阶段虽然看起来很好，也会有不适用的场所。比较复杂的应用，由于事件监听比较复杂，可能会希望只监听发生在具体节点的事件。这个时候就需要停止事件冒泡。停止事件冒泡要使用事件对象的stopPropagation方法，具体代码如下：<code>ele.addEventListener(&#39;click&#39;,function(e){ e.stopPropagation(); },false)</code>。</p>
</li>
<li><p>事件Event对象<br> 事件对象包括很多有用的信息，比如事件触发时，鼠标在屏幕上的坐标，被触发的DOM的详细信息，以及一些常用方法与属性。</p>
<ul>
<li>type: String<br>  事件的名称，比如’click’</li>
<li>target: Node<br>  事件要触发的目标节点</li>
<li>bubbles: Boolean<br>  表示该事件是否在冒泡阶段触发的</li>
<li>preventDefault: function<br>  这个方法可以禁止一切默认的行为，例如点击a标签时，会打开一个新的页面，如果为a标签监听事件click同时调用该方法，则不会打开新的页面。</li>
<li>stopPropagation: function<br>  停止冒泡</li>
<li>cancelable: Boolean<br>  这个属性表明该事件是否可以通过event.preventDefault()方法来禁用默认行为。</li>
<li><strong>eventPhase: Number</strong><br>  这个属性的数字表示当前事件触发在什么阶段。none: 0，捕获：1，目标：2，冒泡：3。</li>
<li>isTrusted: Boolean<br>  表明该事件是浏览器触发（用户真实操作触发）。</li>
</ul>
</li>
<li><p>常用事件和技巧<br> 用户的操作有很多种，所以有很多事件。为了开发方便，浏览器又提供了一些事件，所以有很多的事件。这里只介绍几种常用的事件和使用技巧。</p>
<ul>
<li>load: load事件在资源加载完成时触发。这个资源可以是图片，css文件，js文件，视屏，document和window等等。比较常用的就是监听window的load事件，当页面内所有资源加载完成之后就会触发。比如用javaScript对图片以及其它资源处理，我们在load事件中触发，可以保证javaScript不会在资源未加载完成就开始处理资源导致报错。同样的，也可以监听图片等其它资源加载情况。</li>
<li>beforeunload: 当浏览者在页面的输入框输入一些内容时，未保存，误操作关掉网页会导致输入信息丢失。</li>
</ul>
</li>
</ol>
<ol>
<li><p>利用javaScript模拟触发内置事件。<br> 内置的事件也可以被javaScript模拟触发，比如下面函数模拟触发单击事件<br> <code></code></p>
<pre><code>function simulate(){
    var event = new MouseEvent(&apos;click&apos;,{
        &apos;view&apos;: window,
        &apos;bubbles&apos;:true,
        &apos;cancelable&apos;: true
    });
}
var cb = document.getElementById(&apos;checkbox&apos;);
var canceled = !cb.dispatchEvent(event);
if(canceled){
    alert(&apos;canceled&apos;); // A handle called preventDefault
}else{
    alert(&apos;not canceled&apos;); //None of the handles called preventDefault
}
</code></pre><p> </p>
</li>
<li><p>自定义事件<br>我们可以自定义事件来实现更灵活的开发，事件用好了可以是一个强大的工具。与自定义相关的函数有Event，CustomEvent和dispatchEvent。直接自定义事件，使用event构造函数。</p>
<p><code></code></p>
<pre><code>// Create the event.
var event = document.createEvent(&apos;Event&apos;);
// Define that the event name is &apos;build&apos;.
event.initEvent(&apos;build&apos;, true, true);
// Listen for the event.
elem.addEventListener(&apos;build&apos;, function (e) {
// e.target matches elem
}, false);
// target can be any Element or other EventTarget.
elem.dispatchEvent(event);
</code></pre><p></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;javascript事件解读&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://muleimulei.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>strcpy与strncpy用法与区别</title>
    <link href="https://muleimulei.github.io/2017/07/14/c%E4%B8%8Ec++/strcpy%E4%B8%8Estrncpy%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>https://muleimulei.github.io/2017/07/14/c与c++/strcpy与strncpy用法与区别/</id>
    <published>2017-07-14T14:03:11.444Z</published>
    <updated>2017-07-14T15:05:21.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>strcpy与strncpy用法与区别</p>
</blockquote>
<a id="more"></a>
<ul>
<li>strcpy函数：把从src地址开始含有NULL结束符的字符串复制到以dest开始的地址空间，返回dest。要求：src和dest所指的内存区域不可以重叠且dest必须有足够的空间来容纳src字符串。函数原型为：    extern char <em> strcpy(char </em>dest, char <em>src</em>);</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">( <span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> *strDestCopy = strDest;</div><div class="line">    <span class="keyword">if</span>((strDest==<span class="literal">NULL</span>)||(strSrc==<span class="literal">NULL</span>))</div><div class="line">        <span class="keyword">throw</span> <span class="string">"Invalid arguments"</span>;</div><div class="line">    <span class="keyword">while</span>((*strDest++ = *strSrc++)!=<span class="string">'\0'</span>);</div><div class="line">    <span class="keyword">return</span> strDestCopy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>该函数的参数是字符指针，也就是可以是字符串变量和字符数组，因为它们的变量名代表字符地址。字符串默认有一个以null的结束符，字符数组没有。所以此处需要注意：因为src要求有null结束符，所以字符数组的长度必须大于等于src包含null结束符的总长度。例如，char *src=”abcd”；char dest[5] ；这里的dest的长度至少为5；</p>
</blockquote>
<ul>
<li><p>strncpy函数：n代表可以指定字符个数进行赋值。原型：char <em>strncpy(char </em>dest, char *src, size_t n)；功能：将字符串src最多n个字符复制到字符数组dest中（它并不像strcpy一样遇到NULL才停止复制，而是等凑够n个字符才开始复制），返回指向dest的指针。要求：如果n &gt; dest串长度，dest栈空间溢出产生崩溃异常。</p>
<ol>
<li><p>src串长度 &lt;= dest串长度（这里的串长度包含串尾NULL字符）<br>如果 n = (0, src串长度)，src的前n个字符复制到dest中。但是由于没有NULL字符，所以直接访问dest会发生乱码。这时，一般建议采用memset将dest的全部元素用null填充，如memset(dest, 0, 7)</p>
<p>如果n=src串长度,与strcpy一致。<br>如果n=dest串长度，[0, src串长度]处存放src字符串，（src串长度，dest串长度]处存放NULL。</p>
</li>
<li><p>src串长度 &gt; des串长度<br>如果n = dest串长度，则dest串没有null字符，会导致输出有乱码。如果不考虑src串复制完整性，可以将dest最后一个字符置为NULL。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>所以，一般把n设为dest（含null）的长度,当n=dest串长度时，定义dest为字符数组，因为这时没有null字符拷贝。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;strcpy与strncpy用法与区别&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C++" scheme="https://muleimulei.github.io/categories/C/"/>
    
    
      <category term="c++拷贝函数解析" scheme="https://muleimulei.github.io/tags/c-%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
