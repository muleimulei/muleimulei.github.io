<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[页面置换算法的实现]]></title>
      <url>%2F2017%2F04%2F13%2FOS%2F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[页面置换算法的实现 页面置换算法的实现在进程运行过程中，若其所要访问的页面不在内存，而需把它们调入内存，但内存已无空闲空间时，但为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送到磁盘的对换区中。但应将哪个页面调出。需根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法。 一个好的页面置换算法应具有较低的页面置换频率。从理论上上讲，应将那些以后不再会访问的页面换出，或把那些在较长时间内不会再访问的页面换出。 常用算法介绍 最佳置换算法 最佳置换算法是由Belady与1966年提出的一种理论上的算法。其所选择的被淘汰页面将是以后永不使用的，或许是在最长时间内不再被访问的页面。采用最佳置换算法通常可保证获得最低的缺页率。但由于人们目前还无法预知，一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的。因而该算法是无法实现的。 先进先出页面置换算法 FIFO算法是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序连接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量，常用函数，例程等的页面，FIFO算法并不能保证这些页面不被淘汰。 最近最久未使用算法 最近最久未使用(LRU)的页面置换算法是根据页面调入内存后的使用情况作出决策的。由于无法预测各页面将来的使用情况，只能利用”最近的过去”作为”最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。 LRU置换算法的硬件支持 寄存器为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为：R=Rn-1Rn-2Rn-3·····R1R0当某进程访问某物理块时，要将相应寄存器的Rn-1位置成1。此时，定时信号将每隔一定时间(列如 100ms)将寄存器右移一位。如果我们把n位寄存器的数看做一个整数，那么，具有最小数值的寄存器所对应的页面，就是最久未使用的页面。 栈可利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问页面时，便将该页面的页面号从栈中移除，将它压入栈顶。因此，栈顶始终是最新被访问的页面的编号，而栈底则是最近最久未使用页面的编号。 FIFO与LRU使用栈数据结构代码效果如下(源码可按F12查看)：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery基本事件]]></title>
      <url>%2F2017%2F04%2F08%2Fjquery%2Fjquery%E5%9F%BA%E6%9C%AC%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[jquery基本事件 jquery基本事件 页面加载时触发ready()事件 ready()方法类似于onload()事件，但前者只要页面的dom结构加载后触发，而后者需要页面全部元素加载成功才触发，ready可以写多个，其按顺序执行。$(document).ready(function(){$(&#39;#tip&#39;).html(&#39;加载完毕&#39;);});。 使用hover方法切换事件 hover方法的功能是当鼠标移到所选元素上时，执行方法中的第一个函数，鼠标移出时，执行方法中的第二个函数，实现事件的切换效果。$(selector).hover(over,out)。 使用toggle()方法绑定多个函数 toggle()方法可以在元素的click事件中绑定两个或两个以上的函数，同时，它还可以实现元素的隐藏与显示的切换，绑定多个函数的调用格式$(selector).toggle(fun1,fun2,······funN)。 使用unbind()方法移除移除元素绑定事件 $(selector).unbind(event,fun),其中参数event表示需要移除的事件名称，多个事件用空格隔开，fun参数为事件执行时调用的函数名称，如果没有规定参数，unbind()方法会删除指定元素的所有事件处理程序。 使用one()方法绑定元素的一次性事件 one()方法可以绑定元素任何有效的事件，但这种方法的绑定事件只会触发一次。$(selector).one(event,[data],fun)，参数event为事件名称,dada为触发事件时携带的数据，fun为触发该事件时执行的函数。 调用trigger方法手动触发指定事件。 trigger方法可以直接手动触发元素指定的事件，这些事件可以是元素自带事件，也可以是自定义事件。总之，该事件必须能执行。 文本框的focus和blur事件 focus事件在元素获取焦点时触发，如点击文本框时触发该事件；而blur事件则在元素失去焦点时触发。 下拉列表框的change事件 当一个元素的值发生变化时，将会触发change事件。 调用live()方法绑定事件 与bind相同，live可以绑定元素的可执行事件，除此之外，live方法还可以绑定动态元素，即是使用代码添加的元素事件。 调用show()和hide()方法显示和隐藏元素 $(selector).hide(speed,[callback])和$(selector).show(speed,[callback]),参数speed设置隐藏或显示的速度值，可为’slow’,’fast’或毫秒数值。可选参数callback为隐藏或显示动作执行完成后调用的函数。 使用slideUp和slideDown方法的滑动效果 前者用于向上滑动元素，后者用于向下滑动元素，调用方法为$(selector).slideUp(speed,[callback])和$(selector).slideDown(speed,[callback]),其中speed为滑动时的速度，单位是毫秒，可选参数是滑动成功后的回调函数。 使用slideToggle方法 该方法可以切换slideUp和slideDown，即调用该方法时，如果元素已向上滑动，则元素自动向下滑动，反之，向下滑动。$(selector).slideToggle(speed,[callback])。 使用fadeIn()和fadeOut()实现淡入与淡出 $(selector).fadeIn(speed,[callback])和$(selector).fadeOut(speed,[callback])。 使用fadeTo()方法设置淡入淡出效果的不透明度 调用fadeTo()方法，可以将所选元素的不透明度以淡入淡出的效果调整为指定的值。$(selector).fadeTo(speed,opacity,[callback])，其中speed参数为效果的速度，opacity参数为指定的不透明度，取值为0~1，可选参数callback为效果完成后回调的函数。 调用animate()方法制作简单的动画效果 格式为$(selector).animate({params},speed,[callback])。其中，params参数为制作动画效果的css属性名与值，speed参数为动画的效果速度，单位为毫秒，可选项callback参数为动画效果完成后执行的回调函数。$(&#39;img&#39;).animate({left: &#39;+=90px&#39;,3000,function(){$(this).animate({width:&#39;+=30px&#39;,height:&#39;+=30px&#39;},3000,function(){$(&#39;#tip&#39;).html(&#39;done!&#39;);});});。 调用stop方法停止当前动画效果 stop()方法的功能是在动画完成前，停止当前正在执行的动画效果，这些效果包括滑动，淡入淡出和自定义动画。$(selector).stop([clearQueue],[goToEnd])。 调用delay()方法延迟执行动画效果 $(selector).delay(duration)，其中duration为延时值，单位是毫秒，当超过延时值时，动画开始执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery基本方法]]></title>
      <url>%2F2017%2F04%2F08%2Fjquery%2Fjquery%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[jquery基本方法 jquery基本方法 使用attr()方法来控制元素的属性 attr()方法的作用是设置或者返回元素的属性，其中attr(属性名)格式是获取元素属性的值，attr(属性名，属性值)是设置元素属性的值。 操作元素的内容 使用html()和text()方法操作元素的内容，当两个方法的参数为空时，表示获取该元素的内容。而如果方法中包含参数，则表示将参数值设置为元素内容。html()方法可以获取元素的HTML文本。因此，原文中的格式代码也被一起获取，而text()方法只是获取元素中的文本内容，并不包含HTML格式代码。 操作元素内容 通过addClass()和css()方法可以方便的操作元素的样式，前者括号中的参数为增加元素的样式名称，后者直接将样式内容写入到括号里。使用removeAttr(name)和removeClass(class)分别可以实现移除元素的属性和样式的功能，前者方法中的参数表示移除属性名，后者方法中的参数则表示样式名。 使用append()方法向元素内追加内容 append(content)方法的功能是向指定的元素内追加内容，被追加的content参数可以表示字符，HTML标记，还可以是一个返回字符串内容的函数。 使用appendTo()方法向被选元素内插入内容 $(content).appendTo(selector)，参数content表示要插入的内容，参数select表示被选的元素，即把content内容插入到selector元素内，默认在尾部。 使用before()和after()在元素前后插入内容 $(selector).before(content)和$(selector).after(content)。 使用clone()方法复制元素 调用clone()方法可以生成一个被选元素的副本，即复制了一个被选元素，包含它的节点，文本，属性。 $(selector).clone()。 replaceWith()和replaceAll()替换内容 它们在使用时，内容和被替换元素所在的位置不同，$(selector).replaceWith(content),$(content).replaceAll(selector)。 使用wrap()和wrapInner()方法包裹元素的内容 前者用于包裹元素本身，后者用于包裹元素的内容，调用格式为$(selector).wrap(wrapper),$(selector).wrapInner(wrapper)。 使用each方法遍历元素 使用时，通过回调函数返回遍历元素的序列号。$(&#39;span&#39;).each(function(index){if(index==2){$(this).addClass(&#39;focus&#39;);}});。 使用remove()和empty()方法删除元素 remove()方法删除所选元素本身和子元素，该方法可以添加过滤参数指定要删除的某些元素，而empty()方法则只删除所选元素的子元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery选择器]]></title>
      <url>%2F2017%2F04%2F08%2Fjquery%2Fjquery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[jquery选择器使用 jquery选择器 #id选择器 jquery能够使用css选择器来操作网页中的标签元素。如果你想要通过一个ID号去查找一个元素，$(&#39;#my_id&#39;)，其中#my_id表示根据ID选择器获取页面中的指定标签元素，且返回唯一一个元素。 element选择器 其中element就是元素的名称 .class选择器 $(&#39;.class&#39;) 其中, .class参数表示元素的css类别(类选择器名称) sele1,sele2,…,seleN选择器 有时需要精确的选择任意多个指定的元素。$(&#39;sele1,sele2,...seleN&#39;) ,其中sele1，sele2到seleN为有效选择器，每个选择器之间用逗号来隔开。它们可以是之前提及的各种类型选择器，如$(&#39;#id&#39;),$(&#39;.class&#39;),$(&#39;selector&#39;) 选择器等。 ance , desc 选择器 $(&#39;ance desc&#39;),其中ance,desc是使用空格隔开的两个参数,ance表示父元素,desc表示后代元素，包括子元素，孙元素等。两个元素都可以通过选择器来获取。 parent &gt; child $(&#39;parent &gt; child&#39;)，它所选择的目标是子集元素，相当于一个家庭中的子辈们，但不包括孙辈。 prev + next 选择器 $(&#39;prev + next&#39;),查找与”prev”元素紧邻的下一个”next”元素，并且只返回唯一一个元素。 prev ~ siblings选择器 $(&#39;prev ~ siblings&#39;) 获取prev元素后边全部紧邻的元素。 :first 过滤选择器 $(&#39;li:first&#39;) 得到一组相同标签中的第一个元素。 :eq(index)过滤选择器$(&#39;li:eq(3)&#39;)在一组标签元素数组中，灵活选择任意一个标签元素。 :contains(text)过滤选择器希望按照文本内容来查找一个或多个元素，功能是选择包含指定字符串的全部元素。 :has(selector)过滤选择器$(&#39;li:has(&#39;p&#39;)&#39;)是获取选择器中包含指定元素名称的全部字符。 :hidden过滤选择器获取全部不可见的元素，这些不可见的元素包括type属性值为hidden的元素，如$(&#39;p:hidden&#39;)。 :visible过滤选择器获取全部的可见元素，也就是说，只要不将元素的display属性值设置为none,那么都可以获取该标签。 [attribute]包含属性选择器用于选择包含给定属性的所有元素 [attribute=value]属性等于选择器获取与属性名和属性值完全相同的全部元素，其中[]是专用于属性选择器的括号符。 [attribute!=’value’]属性不等于选择器获取不包含属性名，或者与属性名和属性值不相同的全部元素 [attribute|=’value’]属性选择器获取指定属性值等于给定字符串或以字符串为前缀(该字符串后跟一个连字符‘-’)的元素 [attribute*=’value’]属性包含过滤器用于选择指定属性值包含给定字符串的所有元素 [attribute~=’value’]属性包含单词过滤器用于选择指定属性值中包含给定单词(由空格分隔)的元素 [attribute^=’value’]属性开始过滤器用于选择给定属性是以特定值开始的所有元素 [attribute$=’value’]属性结尾过滤器用于选择给定属性是以某特定值结尾的所有元素 :first-child 获取属于其父元素和所有兄弟元素的第一个元素 :last-child 获取每个父元素中返回的最后一个子元素 :img图像域选择器当一个input元素的type属性值设为”image”时，该元素就是一个图像域，```$(‘#form :img’) :button表单按钮选择器获取’type’值为button的input和button这两类普通元素 :checked选择状态选择器(复选框，单选按钮)获取处于选重状态的全部元素 :select 选中状态选择器只能获取select下拉列表框中全部处于选中状态的option选项元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas学习第三章]]></title>
      <url>%2F2017%2F04%2F08%2Fcanvas%2Fcanvas%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[canvas学习第三章 基础知识 canvas文本API ctx.fillText([text],[x],[y],[width]) text: 在画布上渲染的文本 x: 文本在画布上的x坐标 y: 文本在画布上的y坐标 width： 在画布上渲染文本的最大宽度 ctx.font 设置所选用字体大小，榜重，样式，字体外观 font style 字体样式 font weight 字体榜重 font size 字体大小 font face 字体外观 ctx.strokeText([text],[x],[y],[maxwidth]) ctx.measureText([text]) 获得文字的宽 canvas图像API ctx.drawIamge(image,dx,dy) image 图像对象 dx ，dy 定义画布上图像在左上角的位置 ctx.drawImage(image,dx,dy,dw,dh) dw和dh代表在画布上绘制图像的矩形部分的宽和高 ctx.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh) sx,sy代表在画布上开始复制源图像的“原位置” sw,sh代表从(sx,sy)出开始的矩形宽度与高度。 综合代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;CH3EX3: Text Arranger 3.0&lt;/title&gt;&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="jscolor/jscolor.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;window.addEventListener("load", eventWindowLoaded, false); function eventWindowLoaded() &#123; canvasApp();&#125;function canvasSupport () &#123; return Modernizr.canvas;&#125;function eventWindowLoaded() &#123; var pattern = new Image(); pattern.src = "texture.jpg"; pattern.onload = eventAssetsLoaded;&#125;function eventAssetsLoaded() &#123; canvasApp();&#125;function canvasApp() &#123; var message = "your text"; //输入的文本 var fontSize = "50"; //字体大小 var fontFace = "serif"; //字体外观 var textFillColor ="#ff0000"; //填充字体颜色 var textAlpha =1; //透明度 var shadowX = 1; //阴影x轴偏移 var shadowY = 1; //阴影y轴偏移 var shadowBlur = 1; //模糊度 var shadowColor = "#707070"; //阴影颜色 var textBaseline = "middle"; //文字基线 var textAlign = "center"; //文字对齐方式 var fillOrStroke ="fill"; var fontWeight ="normal"; //字体榜重 var fontStyle = "normal"; var fillType = "colorFill"; var textFillColor2 ="#000000"; var pattern = new Image(); if (!canvasSupport()) &#123; return; &#125; var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d"); var formElement = document.getElementById("textBox"); formElement.addEventListener("keyup", textBoxChanged, false);//监听文本框 formElement = document.getElementById("fillOrStroke"); formElement.addEventListener("change", fillOrStrokeChanged, false); formElement = document.getElementById("textSize"); formElement.addEventListener("change", textSizeChanged, false); formElement = document.getElementById("textFillColor"); formElement.addEventListener("change", textFillColorChanged, false); formElement = document.getElementById("textFont"); formElement.addEventListener("change", textFontChanged, false); formElement = document.getElementById("textBaseline"); formElement.addEventListener("change", textBaselineChanged, false); formElement = document.getElementById("textAlign"); formElement.addEventListener("change", textAlignChanged, false); formElement = document.getElementById("fontWeight"); formElement.addEventListener("change", fontWeightChanged, false); formElement = document.getElementById("fontStyle"); formElement.addEventListener("change", fontStyleChanged, false); formElement = document.getElementById("shadowX"); formElement.addEventListener("change", shadowXChanged, false); formElement = document.getElementById("shadowY"); formElement.addEventListener("change", shadowYChanged, false); formElement = document.getElementById("shadowBlur"); formElement.addEventListener("change", shadowBlurChanged, false); formElement = document.getElementById("shadowColor"); formElement.addEventListener("change", shadowColorChanged, false); formElement = document.getElementById("textAlpha"); formElement.addEventListener("change", textAlphaChanged, false); formElement = document.getElementById("textFillColor2"); formElement.addEventListener("change", textFillColor2Changed, false); formElement = document.getElementById("fillType"); formElement.addEventListener("change", fillTypeChanged, false); formElement = document.getElementById("canvasWidth"); formElement.addEventListener("change", canvasWidthChanged, false); formElement = document.getElementById("canvasHeight"); formElement.addEventListener("change", canvasHeightChanged, false); formElement = document.getElementById("canvasStyleWidth"); formElement.addEventListener("change", canvasStyleSizeChanged, false); formElement = document.getElementById("canvasStyleHeight"); formElement.addEventListener("change", canvasStyleSizeChanged, false); formElement = document.getElementById("createImageData"); formElement.addEventListener("click", createImageDataPressed, false); pattern.src = "texture.jpg"; drawScreen(); function drawScreen() &#123; //Background context.globalAlpha = 1; //全局透明度 context.shadowColor = "#707070"; //阴影颜色 context.shadowOffsetX = 0; context.shadowOffsetY = 0; context.shadowBlur = 0; context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width-10, theCanvas.height-10); //Text context.textBaseline = textBaseline; //文字基线 context.textAlign = textAlign; context.font = fontWeight + " " + fontStyle + " " + fontSize + "px " + fontFace; context.shadowColor =shadowColor; context.shadowOffsetX = shadowX; context.shadowOffsetY = shadowY; context.shadowBlur = shadowBlur; context.globalAlpha = textAlpha; var xPosition = (theCanvas.width/2); var yPosition = (theCanvas.height/2); var metrics = context.measureText(message); var textWidth = metrics.width; var tempColor; if (fillType == "colorFill") &#123; tempColor = textFillColor; &#125; else if (fillType == "linearGradient") &#123; var gradient = context.createLinearGradient(xPosition-textWidth/2, yPosition, textWidth, yPosition); gradient.addColorStop(0,textFillColor); gradient.addColorStop(.6,textFillColor2); tempColor = gradient; &#125; else if (fillType == "radialGradient") &#123; var gradient = context.createRadialGradient(xPosition, yPosition, fontSize, xPosition+textWidth, yPosition, 1); gradient.addColorStop(0,textFillColor); gradient.addColorStop(.6,textFillColor2); tempColor = gradient; &#125; else if (fillType == "pattern") &#123; var tempColor = context.createPattern(pattern,"repeat") &#125; else &#123; tempColor = textFillColor; &#125; switch(fillOrStroke) &#123; case "fill": context.fillStyle = tempColor; context.fillText ( message, xPosition ,yPosition); break; case "stroke": context.strokeStyle = tempColor; context.strokeText ( message, xPosition,yPosition); break; case "both": context.fillStyle = tempColor; context.fillText ( message, xPosition ,yPosition); context.strokeStyle = "#000000"; context.strokeText ( message, xPosition,yPosition); break; &#125; &#125; function textBoxChanged(e) &#123; //文本框字符改变时触发 var target = e.target; message = target.value; drawScreen(); &#125; function textBaselineChanged(e) &#123; //文字基线改变时触发 var target = e.target; textBaseline = target.value; drawScreen(); &#125; function textAlignChanged(e) &#123; //文字水平对齐方式改变时触发 var target = e.target; textAlign = target.value; drawScreen(); &#125; function fillOrStrokeChanged(e) &#123; var target = e.target; fillOrStroke = target.value; drawScreen(); &#125; function textSizeChanged(e) &#123; var target = e.target; fontSize = target.value; drawScreen(); &#125; function textFillColorChanged(e) &#123; var target = e.target; textFillColor = "#" + target.value; drawScreen(); &#125; function textFontChanged(e) &#123; var target = e.target; fontFace = target.value; drawScreen(); &#125; function fontWeightChanged(e) &#123; var target = e.target; fontWeight = target.value; drawScreen(); &#125; function fontStyleChanged(e) &#123; var target = e.target; fontStyle = target.value; drawScreen(); &#125; function shadowXChanged(e) &#123; var target = e.target; shadowX = target.value; drawScreen(); &#125; function shadowYChanged(e) &#123; var target = e.target; shadowY = target.value; drawScreen(); &#125; function shadowBlurChanged(e) &#123; var target = e.target; shadowBlur = target.value; drawScreen(); &#125; function shadowColorChanged(e) &#123; var target = e.target; shadowColor = target.value; drawScreen(); &#125; function textAlphaChanged(e) &#123; var target = e.target; textAlpha = (target.value); drawScreen(); &#125; function textFillColor2Changed(e) &#123; var target = e.target; textFillColor2 = "#" + target.value; drawScreen(); &#125; function fillTypeChanged(e) &#123; var target = e.target; fillType = target.value; drawScreen(); &#125; function canvasWidthChanged(e) &#123; var target = e.target; theCanvas.width = target.value; drawScreen(); &#125; function canvasHeightChanged(e) &#123; var target = e.target; theCanvas.height = target.value; drawScreen(); &#125; function canvasStyleSizeChanged(e) &#123; var styleWidth = document.getElementById("canvasStyleWidth"); var styleHeight = document.getElementById("canvasStyleHeight"); var styleValue = "width:" + styleWidth.value + "px; height:" + styleHeight.value +"px;"; theCanvas.setAttribute("style", styleValue ); drawScreen(); &#125; function createImageDataPressed(e) &#123; var imageDataDisplay = document.getElementById("imageDataDisplay"); imageDataDisplay.value = theCanvas.toDataURL(); window.open(imageDataDisplay.value,"canavsImage","left=0,top=0,width=" + theCanvas.width + ",height=" + theCanvas.height +",toolbar=0,resizable=0"); &#125;&#125;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div style="position: absolute; top: 50px; left: 50px;"&gt;&lt;canvas id="canvasOne" width="500" height="300"&gt; Your browser does not support HTML 5 Canvas. &lt;/canvas&gt;&lt;form&gt; Text: &lt;input id="textBox" placeholder="your text" /&gt; &lt;br&gt; Text Font: &lt;select id="textFont"&gt; &lt;option value="serif"&gt;serif&lt;/option&gt; &lt;option value="sans-serif"&gt;sans-serif&lt;/option&gt; &lt;option value="cursive"&gt;cursive&lt;/option&gt; &lt;option value="fantasy"&gt;fantasy&lt;/option&gt; &lt;option value="monospace"&gt;monospace&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Font Weight: &lt;select id="fontWeight"&gt; &lt;option value="normal"&gt;normal&lt;/option&gt; &lt;option value="bold"&gt;bold&lt;/option&gt; &lt;option value="bolder"&gt;bolder&lt;/option&gt; &lt;option value="lighter"&gt;lighter&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Font Style: &lt;select id="fontStyle"&gt; &lt;option value="normal"&gt;normal&lt;/option&gt; &lt;option value="italic"&gt;italic&lt;/option&gt; &lt;option value="oblique"&gt;oblique&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Text Size: &lt;input type="range" id="textSize" min="0" max="200" step="1" value="50"/&gt; &lt;br&gt; Fill Type : &lt;select id="fillType"&gt; &lt;option value="colorFill"&gt;Color Fill&lt;/option&gt; &lt;option value="linearGradient"&gt;Linear Gradient&lt;/option&gt; &lt;option value="radialGradient"&gt;Radial Gradient&lt;/option&gt; &lt;option value="pattern"&gt;pattern&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Text Color: &lt;input class="color" id="textFillColor" value="FF0000"/&gt; &lt;br&gt; Text Color 2: &lt;input class="color" id="textFillColor2" value ="000000"/&gt; &lt;br&gt; Fill Or Stroke : &lt;select id="fillOrStroke"&gt; &lt;option value="fill"&gt;fill&lt;/option&gt; &lt;option value="stroke"&gt;stroke&lt;/option&gt; &lt;option value="both"&gt;both&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Text Baseline &lt;select id="textBaseline"&gt; &lt;option value="middle"&gt;middle&lt;/option&gt; &lt;option value="top"&gt;top&lt;/option&gt; &lt;option value="hanging"&gt;hanging&lt;/option&gt; &lt;option value="alphabetic"&gt;alphabetic&lt;/option&gt; &lt;option value="ideographic"&gt;ideographic&lt;/option&gt; &lt;option value="bottom"&gt;bottom&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Text Align &lt;select id="textAlign"&gt; &lt;option value="center"&gt;center&lt;/option&gt; &lt;option value="start"&gt;start&lt;/option&gt; &lt;option value="end"&gt;end&lt;/option&gt; &lt;option value="left"&gt;left&lt;/option&gt; &lt;option value="right"&gt;right&lt;/option&gt; &lt;/select&gt; &lt;br&gt; Alpha : &lt;input type="range" id="textAlpha" min="0.0" max="1.0" step="0.01" value="1.0"/&gt; &lt;br&gt; Shadow X:&lt;input type="range" id="shadowX" min="-100" max="100" step="1" value="1"/&gt;&lt;br&gt;Shadow Y:&lt;input type="range" id="shadowY" min="-100" max="100" step="1" value="1"/&gt; &lt;br&gt;Shadow Blur: &lt;input type="range" id="shadowBlur" min="1" max="100" step="1" value="1" /&gt; &lt;br&gt;Shadow Color: &lt;input class="color" id="shadowColor" value="707070"/&gt; &lt;br&gt; Canvas Width: &lt;input type="range" id="canvasWidth" min="0" max="1000" step="1" value="500"/&gt; &lt;br&gt; Canvas Height: &lt;input type="range" id="canvasHeight" min="0" max="1000" step="1" value="300"/&gt; &lt;br&gt; Canvas Style Width: &lt;input type="range" id="canvasStyleWidth" min="0" max="1000" step="1" value="500"/&gt; &lt;br&gt; Canvas Style Height: &lt;input type="range" id="canvasStyleHeight" min="0" max="1000" step="1" value="300"/&gt; &lt;br&gt; &lt;input type="button" id="createImageData" value="Create Image Data"&gt; &lt;br&gt; &lt;br&gt; &lt;textarea id="imageDataDisplay" rows=10 cols=30&gt;&lt;/textarea&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas学习第二章]]></title>
      <url>%2F2017%2F04%2F07%2Fcanvas%2Fcancas%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[canvas学习第二章 基础知识 ctx.fillRect(x,y,width,height) 在位置(x,y)处以宽为width，高为height绘制一个矩形 ctx.strokeRect(x,y,width,height) 在位置(x,y)处以宽为width，高为height绘制一个矩形边框，他需要strokeStyle,lineWidth,lineJoin和miterLimit设置 lineCap: 线段末端的形状 butt: 默认值，端点是垂直于线段边缘的平直边缘 round: 端点是在线段边缘处以线宽为直径的半圆 square: 端点是在选段边缘处以线宽为长，以一半线宽为宽的矩形 lineJoin: 定义两条线相交产生的拐角，可将其称为连接 miter: 默认值，在连接外边缘延长相接 bevel: 连接处是一个对角线斜角 round: 连接处是一个圆 ctx.clearRect(x,y,width,height) 在位置(x,y)处以宽为width和高为height清除指定区域并使其完全透明(使用透明黑作为颜色) 当前路径和位图受canvas上下文控制，不属于保存的状态，保存当前状态到堆栈用：ctx.save()，调出最后存储的堆栈恢复画布用ctx.restore() 高级路径画法 ctx.arc(x,y,radius,startAngle,endAngle,anticlockwise) antilockwise若为false，则顺时针画圆，若为true，则逆时针画圆 ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 三次贝塞尔曲线 ctx.quadraticCurveTo(cpx,cpy,x,y) 二次贝塞尔曲线 canvas裁切区域 使用ctx.save(),ctx.restore(),ctx.rect(),ctx.clip()可以完成区域裁切 旋转变换 ctx.setTransform(1,0,0,1,0,0)和ctx.rotate() 变换在调用setTransform()或其他变换函数后立即应用到形状与路径上。 缩放变换 ctx.scale() 对图像进行缩放 填充渐变形状 ：水平渐变，垂直渐变，对角线渐变，径向渐变 水平渐变：var gr = ctx.createLinearGradient(0,0,100,0); 垂直渐变：var gr = ctx.createLinearGradient(0,0,0,100); 对角线渐变：var gr = ctx.createLinearGradient(0,0,100,100); 径向渐变：var gr = ctx.createRadialGradient(50,50,50,50,100); 给渐变添加断点：gr.addColorStop(.5,’rgb(0,255,0)’); 用图案填充： 四种填充类型：repeat,repeat-x,repeat-y,no-repeat var fill = ctx.createPattern(‘fillImg’,’repeat’); 创建阴影 shadowOffsetX和shadowOffsetY值可以是正也可以为负，负值将会在左侧和上方创建阴影，反之，将会在底部创建阴影。shadowBlur属性用来设置阴影模糊效果的程度。这三个参数不受当前canvas变换矩阵影响，shadowColor可以是任何HTML4颜色字符串。以下代码是关于划线： 12345678910111213141516171819202122232425262728293031function drawScreen() &#123; //round end. bevel join, at top left of canvas context.strokeStyle = "black"; //need list of available colors context.lineWidth=10; context.lineJoin='bevel'; context.lineCap='round'; context.beginPath(); context.moveTo(0, 0); context.lineTo(25, 0); context.lineTo(25,25); context.stroke(); context.closePath(); //round end, bevel join, not at top or left of canvas context.beginPath(); context.moveTo(10, 50); context.lineTo(35, 50); context.lineTo(35,75); context.stroke(); context.closePath(); //flat end, round join, not at top or left context.lineJoin='round'; context.lineCap='butt'; context.beginPath(); context.moveTo(10, 100); context.lineTo(35, 100); context.lineTo(35,125); context.stroke(); context.closePath(); &#125; 以下代码关于区域的裁切： 123456789101112131415161718192021222324252627282930function drawScreen() &#123; //在屏幕上绘制一个黑色的方块 context.fillStyle = "black"; context.fillRect(10, 10, 200, 200); //保存当前上下文 context.save(); context.beginPath(); //裁切画布从(0,0)到(50,50)的正方形 context.rect(0, 0, 50, 50); context.clip(); //绘制红色圆 context.beginPath(); context.strokeStyle = "red"; //need list of available colors context.lineWidth=5; context.arc(100, 100, 100, (Math.PI/180)*0, (Math.PI/180)*360, false); // full circle context.stroke(); context.closePath(); context.restore(); //裁切整个画布 context.beginPath(); context.rect(0, 0, 500, 500); context.clip(); //蓝色圆 context.beginPath(); context.strokeStyle = "blue"; context.lineWidth=5; context.arc(100, 100, 50, (Math.PI/180)*0, (Math.PI/180)*360, false); context.stroke(); context.closePath();&#125; 也可将其它canvas方法配合裁切区域使用，最常见的是arc()函数 以下代码是关于旋转： 12345678910111213function drawScreen()&#123; //绘制黑色正方形 ctx.fillStyle = 'black'; ctx.fillRect(20,20,25,25); //绘制红色正方形 ctx.setTransform(1,0,0,1,0,0); var angle = 45*Math.PI/180, x = 100,y=100,width=50,height=50; ctx.translate(x+.5*width,y+.5*height); ctx.rotate(angle); ctx.fillStyle = 'red'; ctx.fillRect(-0.5*width,-0.5*height,width,height);&#125; 缩放变换代码如下： 12345678910function drawScreen()&#123; //绘制一个红色区域 ctx.setTransform(1,0,0,1,0,0); var angle = 45*Math.PI/180, x = 100,y=100,width=50,height=50; ctx.translate(x+.5*width,y+.5*height); ctx.scale(2,2); ctx.fillStyle = 'red'; ctx.fillRect(-0.5*width,-0.5*height,width,height);&#125; 渐变代码如下： 1234567891011121314151617181920212223//径向渐变function drawScreen()&#123; var gr = ctx.createRadialGradient(100,100,50,100,100,100); //添加颜色断点 gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(0.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(0,0,255)'); //使用fillStyle生成渐变 ctx.fillStyle = gr; ctx.arc(100,100,100,0,2*Math.PI,false); ctx.fill();&#125;//图案填充function drawScreen()&#123; var img = new Image(); img.src = 'fill.gif'; img.onload = function()&#123; var gr = ctx.createPattern(img,'repeat'); ctx.fillStyle = gr; ctx.fillRect(0,0,200,200); &#125;&#125; 阴影代码如下： 12345678910111213141516171819function drawScreen() &#123; context.fillStyle = 'red'; //设置填充颜色 context.shadowOffsetX=4; context.shadowOffsetY=4; context.shadowColor='black'; context.shadowBlur=4; //模糊度 context.fillRect(10,10,100,100); context.shadowOffsetX=-4; context.shadowOffsetY=-4; context.shadowColor='black'; context.shadowBlur=4; context.fillRect(150,10,100,100); context.shadowOffsetX=10; context.shadowOffsetY=10; context.shadowColor='rgb(100,100,100)'; context.shadowBlur=8; context.arc(200, 300, 100, (Math.PI/180)*0, (Math.PI/180)*360, false); context.fill();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas学习第一章]]></title>
      <url>%2F2017%2F04%2F07%2Fcanvas%2Fcanvas%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[canvas学习第一章 基本知识 ctx.fillStyle = ‘#000000’ 设置文本颜色 ctx.font = ‘20px _sans’ 设置字体大小与字号 ctx.textBaseline = ‘top’ 设置字体垂直对齐方式 ctx.fillText(‘Hello World’,195,80) 将测试文本输出到屏幕上 ctx.strokeStyle = ‘#000000’ 用于方块边框的颜色 ctx.strokeRect(5,5,490,290) 绘制矩形边框 ctx.fillRect(0,0,500,300) 填充矩形 canvas.toDataURL() 这个方法返回的数据是代表当前canvas对象产生的位图字符串，就像屏幕的一个快照，通过提供一个不同MIME类型作为参数，可以返回不同的数据格式。基本的格式是image/png，但也可以获取image/jpeg和其它格式。 绘制图片 12345var image = new Image();image.src = 'hello.gif';image.onload = function()&#123; //回调函数在image加载成功时触发 ctx.drawImage(image,160,130); //图像对象，与坐标&#125; 我们利用以上知识来制作一个猜字母小游戏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;CH1Ex4: Guesss The Letter Game &lt;/title&gt;&lt;script src=&quot;modernizr-1.6.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//当页面加载完成时触发eventWindowLoaded方法window.addEventListener(&apos;load&apos;, eventWindowLoaded, false);var Debugger = function () &#123; &#125;;Debugger.log = function (message) &#123; try &#123; console.log(message); &#125; catch (exception) &#123; return; &#125;&#125;function eventWindowLoaded() &#123; canvasApp();&#125;function canvasSupport () &#123; return Modernizr.canvas;&#125;function eventWindowLoaded() &#123; canvasApp();&#125;function canvasApp() &#123; var guesses = 0; //猜的次数 var message = &quot;Guess The Letter From a (lower) to z (higher)&quot;; var letters = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; var today = new Date(); var letterToGuess = &quot;&quot;; //要猜的字母 var higherOrLower = &quot;&quot;; //键盘按下的字母是大还是小 var lettersGuessed; //键盘按下的字母 var gameOver = false; if (!canvasSupport()) &#123; return; &#125; var theCanvas = document.getElementById(&quot;canvasOne&quot;); var context = theCanvas.getContext(&quot;2d&quot;); //获得canvas的上下文 initGame(); //初始化游戏 function initGame() &#123; var letterIndex = Math.floor(Math.random() * letters.length); letterToGuess = letters[letterIndex]; //随机生成一个字母 guesses = 0; lettersGuessed = []; //存储已经猜的字母 gameOver = false; //游戏成功与否标注位 window.addEventListener(&quot;keyup&quot;,eventKeyPressed,true); //监听键盘事件 var formElement = document.getElementById(&quot;createImageData&quot;); //生成快照 formElement.addEventListener(&apos;click&apos;, createImageDataPressed, false); drawScreen(); &#125; function eventKeyPressed(e) &#123; if (!gameOver) &#123; var letterPressed = String.fromCharCode(e.keyCode); //获得键入的字母 letterPressed = letterPressed.toLowerCase(); //转换成小写 guesses++; //猜测次数加一 lettersGuessed.push(letterPressed); //存储到数组中 if (letterPressed == letterToGuess) &#123; //如果猜对了 gameOver = true; //标志位置true &#125; else &#123; letterIndex = letters.indexOf(letterToGuess); //被猜的字母在数组中的位置 guessIndex = letters.indexOf(letterPressed); //键入的字母在数组中的位置 Debugger.log(guessIndex);//控制台调试 if (guessIndex &lt; 0) &#123; //如果输入的不是字母，返回-1 higherOrLower = &quot;That is not a letter&quot;; &#125; else if (guessIndex &gt; letterIndex) &#123; //输入偏大 higherOrLower = &quot;Lower&quot;; &#125; else &#123; higherOrLower = &quot;Higher&quot;; //输入偏小 &#125; &#125; drawScreen(); &#125; &#125; function drawScreen() &#123; //绘制背景 context.fillStyle = &quot;#ffffaa&quot;; context.fillRect(0, 0, 500, 300); //绘制边框 context.strokeStyle = &quot;#000000&quot;; context.strokeRect(5, 5, 490, 290); context.textBaseline = &quot;top&quot;; //绘制日期 context.fillStyle = &quot;#000000&quot;; context.font = &quot;10px _san&quot;; context.fillText (today, 150 ,10); //绘制消息 context.fillStyle = &quot;#FF0000&quot;; context.font = &quot;14px _sans&quot;; context.fillText (message, 125, 30); //绘制猜测次数 context.fillStyle = &quot;#109910&quot;; context.font = &quot;16px _sans&quot;; context.fillText (&apos;Guesses: &apos; + guesses, 215, 50); //输入是大还是小 context.fillStyle = &quot;#000000&quot;; context.font = &quot;16px _sans&quot;; context.fillText (&quot;Higher Or Lower: &quot; + higherOrLower, 150,125); //Letters Guessed context.fillStyle = &quot;#FF0000&quot;; context.font = &quot;16px _sans&quot;; context.fillText (&quot;Letters Guessed: &quot; + lettersGuessed.toString(), 10, 260); if (gameOver) &#123; context.fillStyle = &quot;#FF0000&quot;; context.font = &quot;40px _sans&quot;; context.fillText ( &quot;You Got it!&quot;, 150, 180); &#125; &#125; function createImageDataPressed(e) &#123; window.open(theCanvas.toDataURL(),&quot;canavsImage&quot;,&quot;left=0,top=0,width=&quot; + theCanvas.width + &quot;,height=&quot; + theCanvas.height +&quot;,toolbar=0,resizable=0&quot;); &#125; &#125;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div style=&quot;position: absolute; top: 50px; left: 50px;&quot;&gt;&lt;canvas id=&quot;canvasOne&quot; width=&quot;500&quot; height=&quot;300&quot;&gt; Your browser does not support HTML 5 Canvas. &lt;/canvas&gt;&lt;form&gt;&lt;input type=&quot;button&quot; id=&quot;createImageData&quot; value=&quot;Export Canvas Image&quot;&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的reduce如何工作]]></title>
      <url>%2F2017%2F04%2F07%2FJavaScript%2FJavaScript%E7%9A%84Reduce%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[JavaScript的reduce如何工作 一个简单的问题，你如何来求一个数组的和。123const arr = [29,27,2,23];const sum = arr.reduce((total,amount)=&gt;total+amount);console.log(sum); //81 在这个例子中，reduce接受两个参数，total参数和amount参数。 reduce函数循环遍历数组，像for循环一样。 当循环开始时，total参数是最左边的29，amount参数值是27. 函数会把total的值加上amount的值，然后赋值给total。 然后下次函数total的值为56，amount的值为2，一直向右循环，直到没有数据时函数会把total的值返回。 计算数组的平均值。reduce方法中的函数其余的参数，剩余第一个参数的含义为，数据在数组中的下标（从零开始），最后一个为数组本身。123456789101112const arr = [29,27,2,23];const average = arr.reduce((total,amount,index,array)=&gt;&#123; total+=amount; if(index===array.length-1)&#123; return total/array.length; &#125;else&#123; return total; &#125;&#125;);console.log(average);//20.25``` 如何用reduce方法返回一个数组。上面的例子都是返回一个数值，你也可以返回一个数组，这就需要用到reduce函数的第二个参数。指定reduce方法第一个参数函数的第一个参数。在以前的例子中，我们忽略了它。默认为数组的第一个数据。123456789const arr = [29,27,2,23];const average = arr.reduce((total,amount)=&gt;&#123; //total为29，amount为27 total+=amount; if(index===array.length-1)&#123; return total/array.length; &#125;else&#123; return total; &#125;&#125;); 但如果我们给reduce函数加上了第二个参数如：10，代码如下：这时total为10，amount变成了数组的第一个数据29123456789const arr = [29,27,2,23];const average = arr.reduce((total,amount,index,array)=&gt;&#123; //total为29，amount为27 total+=amount; if(index===array.length-1)&#123; return total/array.length; &#125;else&#123; return total; &#125;&#125;,10); //此时平均值的结果的计算要数组元素加上10，在求平均值22.75 有了上面的知识，我们可以把reduce的第二个参数设置为数组，作为参数传入。就可以返回数组。代码如下(将数组数据乘二返回)：1234567const arr = [2,3,4,5];const doubled = arr.reduce((total,amount)=&gt;&#123; //注意此时的total为[],amount为2 total.push(amount*2); return total;&#125;,[]);console.log(doubled); //[4,6,8,10] 我们也可以在其中添加if判断，过滤掉我们不需要的数据123456789const arr = [2,3,4,5];const doubled = arr.reduce((total,amount)=&gt;&#123; //注意此时的total为[],amount为2 if(amount&gt;3)&#123; total.push(amount*2); &#125; return total;&#125;,[]);console.log(doubled); //[8,10] 上面的方法是map和filter方法被reduce方法重写，或许没有map与filter方法更容易让人理解，但reduce方法的好处是你可以综合使用它们，并且操作大量的数据。 我们再来讨论一个问题，你有一个集合，想知道每一个元素在集合中的数目。我们可以利用reduce来解决123456const basket = ['banana','cherry','apple','banana','cherry','apple','orange'];const count = basket.reduce((total,fruit)=&gt;&#123; total[fruit] = (total[fruit]||0)+1; return total; &#125;,&#123;&#125;);console.log(count); //&#123;banana: 2, cherry: 2, apple: 2, orange: 1&#125; 使用reduce方法也可以将嵌套数组扁（数组里面嵌套数组）平化为一个数组（与嵌套数组意思相反）12345const data = [[2,3,4,5],[6,7,8,9],[11,22,33,44]];const flat = data.reduce((total,amount)=&gt;&#123; return total.concat(amount);&#125;,[]);console.log(flat); 有时候数据嵌套太深，我们该如何处理,获得data数组中每个对象的中的颜色12345678910111213141516171819202122const data = [&#123; a: 'happy', b: 'robin', c: ['blue','green'] &#125;, &#123; a: 'tired', b: 'panther', c: ['blue','green','black','blue'] &#125;, &#123; a: 'sad', b: 'gold', c: ['blue','red'] &#125;, ];const colors = data.reduce((total,amount)=&gt;&#123; amount.c.forEach(color=&gt;&#123; total.push(color); &#125;); return total;&#125;,[]); 那我们如何获取颜色种类呢（去掉重复的颜色，只保留一个）123456789101112131415161718192021222324const data = [&#123; a: 'happy', b: 'robin', c: ['blue','green'] &#125;, &#123; a: 'tired', b: 'panther', c: ['blue','green','black','blue'] &#125;, &#123; a: 'sad', b: 'gold', c: ['blue','red'] &#125;, ];const colors = data.reduce((total,amount)=&gt;&#123; amount.c.forEach(color=&gt;&#123; if(total.indexOf(amount)===-1)&#123; total.push(color); &#125; &#125;); return total;&#125;,[]); reduce的另一个强大之处是他可以处理函数假设我们有一个函数集合，这些函数可以允许我们增加，减少，相乘，折半某一个数字123456789101112function increment(input)&#123; return input+1;&#125;function decrement(input)&#123; return input-1;&#125;function double(input)&#123; return input*2;&#125;function half(input)&#123; return input/2;&#125; 在某种情况下，我们需要对某一个数进行增加，减少，相乘，折半。我们需要写一个函数，返回((input+1)*2-1)/2,我们可以利用reduce函数创造一个管道来解决。 管道是一系列函数把一个初始值转化为最终值的过程 代码如下： 12345var pipeline = [increment,double,decrement,half];const result = pipeline.reduce((total,fun)=&gt;&#123; return fun(total);&#125;,2);console.log(result);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间片轮转与高响应比优先算法]]></title>
      <url>%2F2017%2F04%2F02%2FOS%2F%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E4%B8%8E%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[时间片轮转与高响应比优先算法 轮转调度算法轮转法的基本原理 在轮转(RR)法中，系统根据FCFS策略，将所有的就绪队列排成一个就绪队列，并可设置一定时间间隔（如30ms）产生一次终断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，另其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程），由此，可保证就绪队列中的所有进程在一个确定的时间片内，都能获得一次CPU执行。 进程切换时机 在RR调度算法中，应在何事进行进程的切换，可分为两种情况： 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将他从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序就把他送往就绪队列的尾部。 时间片大小确定 如果选择的时间片小，将有利于短作业，因为它能在该时间片内完成。但时间片小，意味着会进行频繁的进程调度和进程上下文的切换，无疑会增加系统的开销。反之，若时间片选择得太长，且为使每个进程都能在一个时间片内完成。RR算法便会退化成FCFS算法，无法满足短作业和交互式用户的需求。 一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成 高响应比优先调度算法高响应比优先调度算法为每一个作业引入一个动态优先级，即优先级是可以改变的，令他随等待时间延长而增加，这将使长作业的优先级在等待期间不断的增加，等到足够的时间后，必然会有机会获得处理机。该优先级变化规律为： 优先级 = (等待时间+要求服务时间)/要求服务时间 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比Rp。优先级又可表示为： 优先级 = (等待时间+要求服务时间)/要求服务时间 = 响应时间/要求服务时间 由上式可以看出 如果作业的等待时间相同，则要求服务的时间愈短，其优先级愈高，因而类似于SJF算法，有利于短作业。 当要求服务的的时间相同时，作业的优先级又取决于其等待时间，因而又类似于FCFS算法。 对于长作业的优先级，可以随等待时间的增加而增大，当其等待时间足够长时，也可获得处理机。 在每次进行调度前，都需要进行响应比的计算，显然会增加系统开销。 两种算法代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//进程类function Process()&#123;&#125;Process.list = []; //进程列表Process.task_num = 5;//进程数Process.regetRatioAndGetProcess = function(list)&#123; //获得响应比 list.forEach(function(item)&#123; item.ratio = ((Date.parse(new Date()) - item.arriveTime) / item.runTime) +1; //一个进程结束后，重新计算响应比 &#125;); var maxRatio = 0,NO = -1; list.forEach(function(item,index)&#123; //挑选出响应比最大的进程 if(item.ratio&gt;maxRatio)&#123; maxRatio = item.ratio; NO = index; &#125; &#125;); return list.splice(NO,1)[0];&#125;//进程初始化Process.init = function()&#123; Process.list.splice(0,Process.list.length); for(var i = 0;i&lt;Process.task_num;i++)&#123; Process.list.push(&#123; id: i,//进程号 arriveTime: 0, //进程到达时间 ratio: 0, //响应比 runTime: (Math.floor(Math.random()*4)+2)*1000, //运行时间间隔为[2,6]s &#125;); &#125;&#125;//-----------------------------------------------------------//高响应比优先调度算法var HRRN = &#123; list:[], //记录进程响应时间 init_task: function(list,num)&#123; list.forEach(function(item)&#123; item.arriveTime = Date.parse(new Date()); //获得进程到达时间 &#125;); &#125;, //进程运行 run: function(list,num)&#123; for(var i = 0;i&lt;num;i++)&#123; var runItem = Process.regetRatioAndGetProcess(list); //得到响应比最大的进程 console.log(`第$&#123;runItem.id&#125;号进程开始运行：$&#123;new Date()&#125;`); var t = Date.parse(new Date()); var exit = t + runItem.runTime; while(true)&#123; //模拟进程运行 if(Date.parse(new Date()) &gt;=exit)&#123; break; &#125; &#125; console.log(`第$&#123;runItem.id&#125;号进程结束运行：$&#123;new Date()&#125;`); //记录进程的响应时间 ：现在时间-到达时间 HRRN.list.push(&#123; id: runItem.id, responseTime: Date.parse(new Date()) - runItem.arriveTime &#125;); &#125; &#125;, //打印进程响应时间，计算平均响应周期 show:function()&#123; var total = 0; HRRN.list.forEach(function(item)&#123; console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`); total+=Math.floor(item.responseTime); &#125;); console.log(`平均周转周期为$&#123;Math.floor(total/HRRN.list.length)/1000&#125;s`); &#125;&#125;Process.init();HRRN.init_task(Process.list,Process.task_num);HRRN.run(Process.list,Process.task_num);HRRN.show();//---------------------------------------------------------------//时间片轮转算法var RR = &#123; circle_size:4000,//时间片大小 list:[], //记录进程执行时间 init_task:function(list)&#123; //初始化进程 list.forEach(function(item)&#123; item.arriveTime = Date.parse(new Date()); &#125;); &#125;, run:function(list)&#123; while(true)&#123; if(list.length===0) break; //进程全部运行完成后，退出死循环 var item = list.splice(0,1)[0]; //选出队首进程 var runTime = item.runTime; var id = item.id; console.log(`第$&#123;id&#125;号进程开始运行 :$&#123;new Date()&#125;`); if(runTime&lt;RR.circle_size)&#123; //如果能够在本时间片内运行完 var exit = Date.parse(new Date()) + runTime; while((Date.parse(new Date()))&lt; exit); console.log(`第$&#123;id&#125;号进程结束运行,运行时间为$&#123;runTime/1000&#125;s :$&#123;new Date()&#125;`); RR.list.push(&#123; id: item.id, responseTime: Date.parse(new Date()) - item.arriveTime &#125;); &#125;else&#123; //计算下一次需要的运行时间 item.runTime -= RR.circle_size; list.push(item); var exit = Date.parse(new Date()) + RR.circle_size; while((Date.parse(new Date()))&lt; exit); console.log(`$&#123;new Date()&#125;:第$&#123;id&#125;号进程时间片用完，处于等待状态`); &#125; &#125; &#125;, //打印每个进程的响应时间与平均周转周期 show:function()&#123; var total = 0; RR.list.forEach(function(item)&#123; console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`); total+=Math.floor(item.responseTime); &#125;); console.log(`平均周转周期为$&#123;Math.floor(total/RR.list.length)/1000&#125;s`); &#125;&#125;Process.init();RR.init_task(Process.list);RR.run(Process.list);RR.show();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery的Deferred对象详解]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%2Fjquery%E7%9A%84Deferred%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[JQuery的Deferred对象就是Jquery的回调函数的解决方案 在我们开发网站的过程中，我们经常会遇到很长的JavaScript操作。其中，既有异步的操作，如ajax读取服务器的数据，也有异步的操作，如遍历一个大型数组，他们都不是能立即返回结果的。通常的做法是，为他们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。简单地说，Deferred对象就是JQuery的回调函数的解决方案。在英语中，defer的意思是“延迟”，所以Deferred对象的含义是延迟到未来的某个点在执行。 ajax的链式写法123456789$.ajax(&#123; url: 'test.html', success: function()&#123; alert('ok'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); 在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调方法，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果使用的是低于1.5.0版本的JQuery，返回的是XHR对象，没法进行链式操作；如果高于1.5.0版本，返回的是Deferred对象，可以进行链式操作。 1234567$.ajax('text.html').done(function()&#123; alert('ok'); &#125;).fail(function()&#123; alert('fail');&#125;); 指定同一操作的多个回调函数Deferred对象的一大好处是允许你自由添加多个回调函数。还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，还想再运行一个回调函数。代码如下：12345678910$.ajax('test.html').done(function()&#123; alert('ok');&#125;).fail(function()&#123; alert('fail')&#125;).done(function()&#123; alert('第二个回调');&#125;); 回调函数可以添加任意多个，它们按添加顺序执行 为多个操作指定回调函数Deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。此时用到一个新的方法：$.when(): 1234567$.when($.ajax('test1.html'),$.ajax('test2.html')).done(function()&#123; alert('ok') &#125;).fail(function()&#123; alert('fail');&#125;); 这段代码的意思是，先执行两个操作$.ajax()操作，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。 普通函数的回调函数接口（上）Deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作（不管是ajax操作还是本地操作，也不管是异步操作还是同步操作，都可以使用Deferred对象的各种方法，指定回调函数）。 来看一个具体的例子。假如有一个很耗时的操作wait:123456var wait = function()&#123; var tasks = function()&#123; alert('执行完毕'); &#125;; setTimeout(tasks,5000);&#125;; 为它指定回调函数，应该怎么做呢？1234567$.when(wait()).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;); 但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是Deferred对象，所以必须对wait()改写： 123456789var dtd = $.Deferred(); //新建一个Deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert('执行完毕'); dtd.resolve(); &#125;; setTimeout(tasks,5000); return dtd;&#125;; 现在，wait()函数返回的是Deferred对象，这样就可以加上链式操作了。1234567$.when(wait(dtd)).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;); wait()函数运行完，就会自动运行done()方法指定的回调函数。 deferred.resolve()方法和deferred.reject()方法JQuery规定，Deferred对象有三种执行状态:未完成，已完成和已失败。如果执行状态是“已完成”(resolved)，Deferred对象立即调用done()方法指定的回调函数；如果执行状态是“已失败”(rejected)，调用fail()方法指定的回调函数；如果执行状态是“未完成”(pending)，调用progress()方法指定的回调函数。 前面部分的ajax操作，Deferred对象会根据返回结果，自动改变自身的执行状态；但在wait()函数中，这个状态必须有程序员手动指定。dtd.resolve()的意思是，将Deferred对象的执行状态从“未完成”改为“已完成”，从而触发done()方法。类似的，还存在一个deferred.reject()方法，作用是将Deferred对象的执行状态从“未完成”改为“已失败”，从而触发fail()方法。 Deferred对象的promise()方法上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。看如下代码：1234567891011121314151617var dtd = $.Deferred(); //新建一个Deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert('执行完毕'); dtd.resolve(); &#125;; setTimeout(tasks,5000); return dtd;&#125;;$.when(wait(dtd)).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;);dtd.resolve(); 在其尾部添加一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立即执行，先跳出“haha”,然后5秒后在跳出”执行完毕”的提示框。为了避免这种情况，JQuery提供了12345678910111213141516```JavaScript var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); d.resolve(); // 此时，这个语句是无效的 在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定到这个对象上，而不是原来的Deferred对象。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的Deferred对象。 不过最好的写法如下：12345678910111213 var wait = function(dtd)&#123;var dtd = $.Deferred(); // 新建一个Deferred对象 var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); Deferred对象的方法 $.Deferred() 生成一个Deferred对象 deferred.progress() 该方法用于指定deferred对象状态为等待中的回调函数。但是她仅在deferred对象生成了进度通知时才会被调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243 var wait = function() &#123; var dtd = $.Deferred(); // 新建一个deferred对象 var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); return dtd;&#125;;// 绑定回调函数$.when(wait()) .done(function() &#123; alert("执行成功了！"); &#125;) .fail(function() &#123; alert("出错啦！"); &#125;) .progress(function(data) &#123; console.log('执行中,已完成', data); &#125;);// 执行中,已完成 10%// 执行中,已完成 20%// 执行中,已完成 30%// 执行中,已完成 40%// 执行中,已完成 50%// 执行中,已完成 60%// 执行中,已完成 70%// 执行中,已完成 80%// 执行中,已完成 90%// 执行中,已完成 100%// 之后弹出 执行完毕！和 执行成功了！ jQuery3.0以上版本对when方法做了大幅调整。向promise/A+靠齐，上面的写法中notify是触发不了when中的progress回调的，需要使用promise来给对象部署deferred接口或使用$.Deferred()传入函数名。 promise 给一个对象部署Deferred接口 1234567891011121314151617181920212223242526272829303132var dtd = $.Deferred(); // 新建一个deferred对象var wait = function(dtd) &#123; var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); &#125;;// 在wait对象上部署Deferred接口，此后就可以直接在wait上使用deferred对象promise后的方法了dtd.promise(wait);// 在wait对象上使用deferred对象的方法指定回调。wait.done(function() &#123; alert("执行成功了！");&#125;).fail(function() &#123; alert("出错啦！");&#125;).progress(function(data) &#123; console.log('执行中,已完成', data);&#125;);// 执行wait(dtd); 使用$.Deferred传入函数名： 123456789101112131415161718192021222324252627282930var wait = function(dtd) &#123; var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); return dtd;&#125;;// 绑定回调函数$.Deferred(wait) //$.Deferred()的返回值将作为wait函数的参数 .done(function() &#123; alert("执行成功了！"); &#125;) .fail(function() &#123; alert("出错啦！"); &#125;) .progress(function(data) &#123; console.log('执行中,已完成', data); &#125;); deferred.done() 指定操作成功时的回调函数 deferred.fail() 指定操作失败时的回调函数 deferred.promise() 没有参数时，返回一个新的Deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。 deferred.resolve() 手动改变deferred对象的运行状态为“已完成”，从而触发done()方法。 deferred.always() 不管Deferred对象如何，总是执行。 deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将Deferred对象的运行状态变为“已失败”，从而立即触发fail()方法。 $.when() 为多个操作指定回调函数。 deferred.then() 有时为了省事，可以把done()和fail()合写在一起，这就是then()方法。 12$.when($.ajax('test.html')) .then(successFunc,failureFunc); 如果then()有两个参数，那么第一个参数时done()方法的回调函数。如果then()只有一个参数，那么等同于done()。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript函数柯里化]]></title>
      <url>%2F2017%2F03%2F22%2FJavaScript%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
      <content type="text"><![CDATA[什么是函数柯里化 柯里化（Curring）,又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。 柯里化特点 接受单一参数，将更多的参数通过回调函数来解决。 返回一个新的函数，用于处理所有的想要传入的参数。 需要利用call/apply与arguments伪数组收集参数。 返回的函数正是用来处理收集起来的参数。 需要理解JavaScript函数的隐式转换JavaScript是一种弱类型语言，它的隐式转换是非常灵活的。如下： 1234function fn()&#123; return 5;&#125;console.log(fn+10); 试着运行一下你会发现答案为：123function fn()&#123; return 5;&#125;10 接着我们在修改代码为：1234567function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;console.log(fn+10); 你会发现答案为：20，接着我们在进行修改12345678910function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;fn.valueOf = function()&#123; return 20;&#125;console.log(fn+10); 答案为30 当我们使用console.log()或者进行运算时，隐式转换就可能会发生。从上面的例子我们可以得到如下结论： 当我们没有重新定义toString()与valueOf时，函数的隐式转换会调用默认的toString方法，他会将函数的定义内容转化为字符串返回。当我们主动定义了toString()/valueOf时，那么隐式转化的返回结果则由我们自己控制了。其中valueOf的优先级会比toString()高。 需要知道如何利用call/apply封装数组的map方法 map:对数组的每一项运行给定的函数，将每次函数调用返回的结果组成新的数组。 具体实现如下：12345678910111213141516171819Array.prototype._map = function(fn,ctx)&#123; var list = this, temp = []; //用来存储返回的新值 console.log(list); if(typeof fn =='function')&#123; //遍历数组的每一项 list.forEach(function(item,index)&#123; temp.push(fn.call(ctx,item,index)); &#125;); &#125;else&#123; console.err('TypeError:'+fn+' must be a function'); &#125; return temp;&#125;var arr = [2,3,4,5]._map(function(item,index)&#123; return item + index;&#125;);console.log(arr); 理解函数柯里化 考虑实现一个add方法，使结果能够满足如下预期：add(1)(2) = 3add(1,2,3)(4) = 10add(1)(2)(3)(4)(5) = 15 一开始如果只有两个参数，你可能会这样写：12345function add(a)&#123; return function(b)&#123; return a+b; &#125;&#125; 如果有三个的话，可以这样写：1234567function add(a)&#123; return function(b)&#123; return function(c)&#123; return a+b+c; &#125; &#125;&#125; 如果有n个呢，难道要一直嵌套下去，而且2,3种情况也没有覆盖到。所以，要利用函数柯里化，利用闭包的特性，将所有参数，集中到最后的返回函数里进行计算并返回结果。因此，我们在写代码时，要将所有的参数集中起来处理。具体实现如下：12345678910111213141516171819function getSum(rest)&#123; var sum = 0; rest.forEach((item)=&gt;&#123; return sum+=item; &#125;); return sum;&#125;function add (...rest)&#123; var _args = rest; var _adder = function(...rest)&#123; [].push.apply(_args, rest); return _adder; &#125; _adder.toString = function()&#123; return getSum(_args); &#125; return _adder();&#125; 我们再来考虑函数柯里化的例子 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连接起来。我们该怎么做？ 123456var arr = [1,2,3,4,5];Array.prototype.merge = function(chars)&#123; return this.join(chars);&#125;var str = arr.merge('-');console.log(str); 在考虑将数组每一位加一位数在连接起来 12345678var arr = [1,2,3,4];Array.prototype.merge = function(chars,number)&#123; return this.map((item)=&gt;&#123; return item+number; &#125;).join(chars);&#125;var str = arr.merge('-',7);console.log(str); 我们并不知道自己要对数组进行何种处理，所以我们要把对数组的操作封装起来。我们现在只知道需要将他们处理后用字符串连接起来，所以不妨将他们的处理内容保存在函数中，而仅仅固定封装连起来的部分。 12345678910111213141516171819202122232425262728Array.prototype.merge = function(fn,chars)&#123; return this.map(fn).join(chars);&#125;var arr = [1,2,3,4];var add = function(num)&#123; return function(item)&#123; return num + item; &#125;&#125;var reduce = function(num)&#123; return function(item)&#123; return item - num; &#125;&#125;//每一项加2合并var res1 = arr.merge(add(2),'-');//每一项减2合并var res2 = arr.merge(reduce(2),'-');//也可以直接传入回调函数var res3 = arr.merge((function(num)&#123; return function(item)&#123; return item + num; &#125;&#125;)(2),'-'); 柯里化通用式1234567891011121314var currying = function(fn)&#123; var args = [].slice.apply(arguments,[1]); return function()&#123; var _args = args.concat([].slice.apply(arguments)); return fn.apply(null,_args); &#125;&#125;var sum = currying(function()&#123; var list = [].slice.call(arguments); return list.reduce(function(a,b)&#123; return a + b; &#125;);&#125;,10); 柯里化与bind1234567Object.prototype.bind = function(ctx)&#123; var _args = [].slice.call(arguments,1); var fn = this; return function()&#123; fn.apply(ctx,_args.concat([].slice.call(arguments))); &#125;&#125; 参考链接 函数柯里化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript内置函数]]></title>
      <url>%2F2017%2F01%2F05%2FJavaScript%2FJavaScript%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[这篇文章将介绍几个关于JavaScript内置函数的简单算法 将字符串重复一定次数使用while循环1234567function repeat(num,str)&#123; var repeatStr = ''; while(num--)&#123; repeatStr+=str; &#125; return repeatStr;&#125; 使用递归12345678910function repeatStringNumTimes(str,times)&#123; if(times&lt;0)&#123; return ''; &#125; if(times===1)&#123; return str; &#125;else&#123; return str + repeatStringNumTimes(str,times-1); &#125;&#125; 使用es6的repeat123function repeatStringNumTimes(str,times)&#123; return times&lt;0?'':str.repeat(times);&#125; 检查某一字符串是否已特定字符串结束利用substr函数123function confirmEnding(str,target)&#123; return str.substr(-target.length)===target? true:false;&#125; 使用内置函数123function confirmEnding(str,target)&#123; return str.endsWith(target);&#125; 翻转字符串使用split(),reverse(),join()123function reverseStr(str)&#123; return str.split('').reserve().join('');&#125; 使用for循环12345678function reverseStr(str)&#123; var newStr = ''; var len = str.length; for(let i = len-1;i&gt;=0;i--)&#123; newStr+=str[i]; &#125; return newStr;&#125; 使用递归123456function reverseStr(str)&#123; if(str==='')&#123; return ''; &#125; return str.charAt(0)+reverseStr(str.substr(1));&#125; 将一个句子的每个单词首字母大写，其余小写使用for循环12345678function titleCase(str)&#123; var list = str.toLowerCase().split(' '); var len = list.length; for(let i = 0 ;i&lt;len;i++)&#123; list[i] = list[i].charAt(0).toUpperCase() + list[i].substr(1); &#125; return list.join(' ');&#125; 使用map方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.charAt(0).toUpperCase()+ word.slice(1); &#125;).join('');&#125; 使用replace方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.replace(word[0],word[0].toUpperCase()); &#125;).join('');&#125;]]></content>
    </entry>

    
  
  
</search>
