<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript函数柯里化]]></title>
      <url>%2F2017%2F03%2F22%2FJavaScript%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
      <content type="text"><![CDATA[参考链接 函数柯里化 什么是函数柯里化柯里化（Curring）,又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。 柯里化特点 接受单一参数，将更多的参数通过回调函数来解决。 返回一个新的函数，用于处理所有的想要传入的参数。 需要利用call/apply与arguments伪数组收集参数。 返回的函数正是用来处理收集起来的参数。 需要理解JavaScript函数的隐式转换JavaScript是一种弱类型语言，它的隐式转换是非常灵活的。如下： 1234function fn()&#123; return 5;&#125;console.log(fn+10); 试着运行一下你会发现答案为：123function fn()&#123; return 5;&#125;10 接着我们在修改代码为：1234567function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;console.log(fn+10); 你会发现答案为：20，接着我们在进行修改12345678910function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;fn.valueOf = function()&#123; return 20;&#125;console.log(fn+10); 答案为30 当我们使用console.log()或者进行运算时，隐式转换就可能会发生。从上面的例子我们可以得到如下结论： 当我们没有重新定义toString()与valueOf时，函数的隐式转换会调用默认的toString方法，他会将函数的定义内容转化为字符串返回。当我们主动定义了toString()/valueOf时，那么隐式转化的返回结果则由我们自己控制了。其中valueOf的优先级会比toString()高。 需要知道如何利用call/apply封装数组的map方法 map:对数组的每一项运行给定的函数，将每次函数调用返回的结果组成新的数组。 具体实现如下：12345678910111213141516171819Array.prototype._map = function(fn,ctx)&#123; var list = this, temp = []; //用来存储返回的新值 console.log(list); if(typeof fn =='function')&#123; //遍历数组的每一项 list.forEach(function(item,index)&#123; temp.push(fn.call(ctx,item,index)); &#125;); &#125;else&#123; console.err('TypeError:'+fn+' must be a function'); &#125; return temp;&#125;var arr = [2,3,4,5]._map(function(item,index)&#123; return item + index;&#125;);console.log(arr); 理解函数柯里化 考虑实现一个add方法，使结果能够满足如下预期：add(1)(2) = 3add(1,2,3)(4) = 10add(1)(2)(3)(4)(5) = 15 一开始如果只有两个参数，你可能会这样写：12345function add(a)&#123; return function(b)&#123; return a+b; &#125;&#125; 如果有三个的话，可以这样写：1234567function add(a)&#123; return function(b)&#123; return function(c)&#123; return a+b+c; &#125; &#125;&#125; 如果有n个呢，难道要一直嵌套下去，而且2,3种情况也没有覆盖到。所以，要利用函数柯里化，利用闭包的特性，将所有参数，集中到最后的返回函数里进行计算并返回结果。因此，我们在写代码时，要将所有的参数集中起来处理。具体实现如下：12345678910111213141516171819function getSum(rest)&#123; var sum = 0; rest.forEach((item)=&gt;&#123; return sum+=item; &#125;); return sum;&#125;function add (...rest)&#123; var _args = rest; var _adder = function(...rest)&#123; [].push.apply(_args, rest); return _adder; &#125; _adder.toString = function()&#123; return getSum(_args); &#125; return _adder();&#125; 我们再来考虑函数柯里化的例子 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连接起来。我们该怎么做？ 123456var arr = [1,2,3,4,5];Array.prototype.merge = function(chars)&#123; return this.join(chars);&#125;var str = arr.merge('-');console.log(str); 在考虑将数组每一位加一位数在连接起来 12345678var arr = [1,2,3,4];Array.prototype.merge = function(chars,number)&#123; return this.map((item)=&gt;&#123; return item+number; &#125;).join(chars);&#125;var str = arr.merge('-',7);console.log(str); 我们并不知道自己要对数组进行何种处理，所以我们要把对数组的操作封装起来。我们现在只知道需要将他们处理后用字符串连接起来，所以不妨将他们的处理内容保存在函数中，而仅仅固定封装连起来的部分。 12345678910111213141516171819202122232425262728Array.prototype.merge = function(fn,chars)&#123; return this.map(fn).join(chars);&#125;var arr = [1,2,3,4];var add = function(num)&#123; return function(item)&#123; return num + item; &#125;&#125;var reduce = function(num)&#123; return function(item)&#123; return item - num; &#125;&#125;//每一项加2合并var res1 = arr.merge(add(2),'-');//每一项减2合并var res2 = arr.merge(reduce(2),'-');//也可以直接传入回调函数var res3 = arr.merge((function(num)&#123; return function(item)&#123; return item + num; &#125;&#125;)(2),'-'); 柯里化通用式1234567891011121314var currying = function(fn)&#123; var args = [].slice.apply(arguments,[1]); return function()&#123; var _args = args.concat([].slice.apply(arguments)); return fn.apply(null,_args); &#125;&#125;var sum = currying(function()&#123; var list = [].slice.call(arguments); return list.reduce(function(a,b)&#123; return a + b; &#125;);&#125;,10); 柯里化与bind1234567Object.prototype.bind = function(ctx)&#123; var _args = [].slice.call(arguments,1); var fn = this; return function()&#123; fn.apply(ctx,_args.concat([].slice.call(arguments))); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript内置函数]]></title>
      <url>%2F2017%2F01%2F05%2FJavaScript%2FJavaScript%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[这篇文章将介绍几个关于JavaScript内置函数的简单算法 一、将字符串重复一定次数1. 使用while循环1234567function repeat(num,str)&#123; var repeatStr = ''; while(num--)&#123; repeatStr+=str; &#125; return repeatStr;&#125; 2. 使用递归12345678910function repeatStringNumTimes(str,times)&#123; if(times&lt;0)&#123; return ''; &#125; if(times===1)&#123; return str; &#125;else&#123; return str + repeatStringNumTimes(str,times-1); &#125;&#125; 3. 使用es6的repeat123function repeatStringNumTimes(str,times)&#123; return times&lt;0?'':str.repeat(times);&#125; 二、检查某一字符串是否已特定字符串结束1. 利用substr函数123function confirmEnding(str,target)&#123; return str.substr(-target.length)===target? true:false;&#125; 2. 使用内置函数123function confirmEnding(str,target)&#123; return str.endsWith(target);&#125; 三、翻转字符串1. 使用split(),reverse(),join()123function reverseStr(str)&#123; return str.split('').reserve().join('');&#125; 2.使用for循环12345678function reverseStr(str)&#123; var newStr = ''; var len = str.length; for(let i = len-1;i&gt;=0;i--)&#123; newStr+=str[i]; &#125; return newStr;&#125; 3. 使用递归123456function reverseStr(str)&#123; if(str==='')&#123; return ''; &#125; return str.charAt(0)+reverseStr(str.substr(1));&#125; 四、将一个句子的每个单词首字母大写，其余小写1. 使用for循环12345678function titleCase(str)&#123; var list = str.toLowerCase().split(' '); var len = list.length; for(let i = 0 ;i&lt;len;i++)&#123; list[i] = list[i].charAt(0).toUpperCase() + list[i].substr(1); &#125; return list.join(' ');&#125; 2. 使用map方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.charAt(0).toUpperCase()+ word.slice(1); &#125;).join('');&#125; 2. 使用replace方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.replace(word[0],word[0].toUpperCase()); &#125;).join('');&#125;]]></content>
    </entry>

    
  
  
</search>
