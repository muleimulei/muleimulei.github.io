<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[时间片轮转与高响应比优先算法]]></title>
      <url>%2F2017%2F04%2F02%2FOS%2F%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E4%B8%8E%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[时间片轮转与高响应比优先算法 轮转调度算法轮转法的基本原理 在轮转(RR)法中，系统根据FCFS策略，将所有的就绪队列排成一个就绪队列，并可设置一定时间间隔（如30ms）产生一次终断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，另其执行。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程（或新到达的紧迫进程），由此，可保证就绪队列中的所有进程在一个确定的时间片内，都能获得一次CPU执行。 进程切换时机 在RR调度算法中，应在何事进行进程的切换，可分为两种情况： 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将他从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序就把他送往就绪队列的尾部。 时间片大小确定 如果选择的时间片小，将有利于短作业，因为它能在该时间片内完成。但时间片小，意味着会进行频繁的进程调度和进程上下文的切换，无疑会增加系统的开销。反之，若时间片选择得太长，且为使每个进程都能在一个时间片内完成。RR算法便会退化成FCFS算法，无法满足短作业和交互式用户的需求。 一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成 高响应比优先调度算法高响应比优先调度算法为每一个作业引入一个动态优先级，即优先级是可以改变的，令他随等待时间延长而增加，这将使长作业的优先级在等待期间不断的增加，等到足够的时间后，必然会有机会获得处理机。该优先级变化规律为： 优先级 = (等待时间+要求服务时间)/要求服务时间 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比Rp。优先级又可表示为： 优先级 = (等待时间+要求服务时间)/要求服务时间 = 响应时间/要求服务时间 由上式可以看出 如果作业的等待时间相同，则要求服务的时间愈短，其优先级愈高，因而类似于SJF算法，有利于短作业。 当要求服务的的时间相同时，作业的优先级又取决于其等待时间，因而又类似于FCFS算法。 对于长作业的优先级，可以随等待时间的增加而增大，当其等待时间足够长时，也可获得处理机。 在每次进行调度前，都需要进行响应比的计算，显然会增加系统开销。 两种算法代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//进程类function Process()&#123;&#125;Process.list = []; //进程列表Process.task_num = 5;//进程数Process.regetRatioAndGetProcess = function(list)&#123; //获得响应比 list.forEach(function(item)&#123; item.ratio = ((Date.parse(new Date()) - item.arriveTime) / item.runTime) +1; &#125;); var maxRatio = 0,NO = -1; list.forEach(function(item,index)&#123; if(item.ratio&gt;maxRatio)&#123; maxRatio = item.ratio; NO = index; &#125; &#125;); return list.splice(NO,1)[0];&#125;Process.init = function()&#123; Process.list.splice(0,Process.list.length); for(var i = 0;i&lt;Process.task_num;i++)&#123; Process.list.push(&#123; id: i,//进程号 arriveTime: 0, //进程到达时间 ratio: 0, //响应比 runTime: (Math.floor(Math.random()*4)+2)*1000, //运行时间间隔为[2,6]s &#125;); &#125;&#125;//-----------------------------------------------------------//高响应比优先调度算法var HRRN = &#123; list:[], //记录进程响应时间 init_task: function(list,num)&#123; list.forEach(function(item)&#123; item.arriveTime = Date.parse(new Date()); &#125;); &#125;, run: function(list,num)&#123; for(var i = 0;i&lt;num;i++)&#123; var runItem = Process.regetRatioAndGetProcess(list); console.log(`第$&#123;runItem.id&#125;号进程开始运行：$&#123;new Date()&#125;`); var t = Date.parse(new Date()); var exit = t + runItem.runTime; while(true)&#123; if(Date.parse(new Date()) &gt;=exit)&#123; break; &#125; &#125; console.log(`第$&#123;runItem.id&#125;号进程结束运行：$&#123;new Date()&#125;`); HRRN.list.push(&#123; id: runItem.id, responseTime: Date.parse(new Date()) - runItem.arriveTime &#125;); &#125; &#125;, show:function()&#123; var total = 0; HRRN.list.forEach(function(item)&#123; console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`); total+=Math.floor(item.responseTime); &#125;); console.log(`平均周转周期为$&#123;Math.floor(total/HRRN.list.length)/1000&#125;s`); &#125;&#125;Process.init();HRRN.init_task(Process.list,Process.task_num);HRRN.run(Process.list,Process.task_num);HRRN.show();//---------------------------------------------------------------//时间片轮转算法var RR = &#123; circle_size:4000,//时间片大小 list:[], //记录进程执行时间 init_task:function(list)&#123; list.forEach(function(item)&#123; item.arriveTime = Date.parse(new Date()); &#125;); &#125;, run:function(list)&#123; while(true)&#123; if(list.length===0) break; var item = list.splice(0,1)[0]; var runTime = item.runTime; var id = item.id; console.log(`第$&#123;id&#125;号进程开始运行 :$&#123;new Date()&#125;`); if(runTime&lt;RR.circle_size)&#123; //如果能够在本时间片内运行完 var exit = Date.parse(new Date()) + runTime; while((Date.parse(new Date()))&lt; exit); console.log(`第$&#123;id&#125;号进程结束运行,运行时间为$&#123;runTime/1000&#125;s :$&#123;new Date()&#125;`); RR.list.push(&#123; id: item.id, responseTime: Date.parse(new Date()) - item.arriveTime &#125;); &#125;else&#123; item.runTime -= RR.circle_size; list.push(item); var exit = Date.parse(new Date()) + RR.circle_size; while((Date.parse(new Date()))&lt; exit); console.log(`$&#123;new Date()&#125;:第$&#123;id&#125;号进程时间片用完，处于等待状态`); &#125; &#125; &#125;, show:function()&#123; var total = 0; RR.list.forEach(function(item)&#123; console.log(`$&#123;item.id&#125;的响应时间为$&#123;Math.floor(item.responseTime)&#125;`); total+=Math.floor(item.responseTime); &#125;); console.log(`平均周转周期为$&#123;Math.floor(total/RR.list.length)/1000&#125;s`); &#125;&#125;Process.init();RR.init_task(Process.list);RR.run(Process.list);RR.show();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery的Deferred对象详解]]></title>
      <url>%2F2017%2F04%2F02%2FJavaScript%2Fjquery%E7%9A%84Deferred%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[JQuery的Deferred对象就是Jquery的回调函数的解决方案 在我们开发网站的过程中，我们经常会遇到很长的JavaScript操作。其中，既有异步的操作，如ajax读取服务器的数据，也有异步的操作，如遍历一个大型数组，他们都不是能立即返回结果的。通常的做法是，为他们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。简单地说，Deferred对象就是JQuery的回调函数的解决方案。在英语中，defer的意思是“延迟”，所以Deferred对象的含义是延迟到未来的某个点在执行。 ajax的链式写法123456789$.ajax(&#123; url: 'test.html', success: function()&#123; alert('ok'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); 在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调方法，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果使用的是低于1.5.0版本的JQuery，返回的是XHR对象，没法进行链式操作；如果高于1.5.0版本，返回的是Deferred对象，可以进行链式操作。 1234567$.ajax('text.html').done(function()&#123; alert('ok'); &#125;).fail(function()&#123; alert('fail');&#125;); 指定同一操作的多个回调函数Deferred对象的一大好处是允许你自由添加多个回调函数。还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，还想再运行一个回调函数。代码如下：12345678910$.ajax('test.html').done(function()&#123; alert('ok');&#125;).fail(function()&#123; alert('fail')&#125;).done(function()&#123; alert('第二个回调');&#125;); 回调函数可以添加任意多个，它们按添加顺序执行 为多个操作指定回调函数Deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。此时用到一个新的方法：$.when(): 1234567$.when($.ajax('test1.html'),$.ajax('test2.html')).done(function()&#123; alert('ok') &#125;).fail(function()&#123; alert('fail');&#125;); 这段代码的意思是，先执行两个操作$.ajax()操作，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。 普通函数的回调函数接口（上）Deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作（不管是ajax操作还是本地操作，也不管是异步操作还是同步操作，都可以使用Deferred对象的各种方法，指定回调函数）。 来看一个具体的例子。假如有一个很耗时的操作wait:123456var wait = function()&#123; var tasks = function()&#123; alert('执行完毕'); &#125;; setTimeout(tasks,5000);&#125;; 为它指定回调函数，应该怎么做呢？1234567$.when(wait()).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;); 但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是Deferred对象，所以必须对wait()改写： 123456789var dtd = $.Deferred(); //新建一个Deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert('执行完毕'); dtd.resolve(); &#125;; setTimeout(tasks,5000); return dtd;&#125;; 现在，wait()函数返回的是Deferred对象，这样就可以加上链式操作了。1234567$.when(wait(dtd)).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;); wait()函数运行完，就会自动运行done()方法指定的回调函数。 deferred.resolve()方法和deferred.reject()方法JQuery规定，Deferred对象有三种执行状态:未完成，已完成和已失败。如果执行状态是“已完成”(resolved)，Deferred对象立即调用done()方法指定的回调函数；如果执行状态是“已失败”(rejected)，调用fail()方法指定的回调函数；如果执行状态是“未完成”(pending)，调用progress()方法指定的回调函数。 前面部分的ajax操作，Deferred对象会根据返回结果，自动改变自身的执行状态；但在wait()函数中，这个状态必须有程序员手动指定。dtd.resolve()的意思是，将Deferred对象的执行状态从“未完成”改为“已完成”，从而触发done()方法。类似的，还存在一个deferred.reject()方法，作用是将Deferred对象的执行状态从“未完成”改为“已失败”，从而触发fail()方法。 Deferred对象的promise()方法上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。看如下代码：1234567891011121314151617var dtd = $.Deferred(); //新建一个Deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert('执行完毕'); dtd.resolve(); &#125;; setTimeout(tasks,5000); return dtd;&#125;;$.when(wait(dtd)).done(function()&#123; alert('haha');&#125;).fail(function()&#123; alert('fail');&#125;);dtd.resolve(); 在其尾部添加一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立即执行，先跳出“haha”,然后5秒后在跳出”执行完毕”的提示框。为了避免这种情况，JQuery提供了12345678910111213141516```JavaScript var dtd = $.Deferred(); // 新建一个Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); d.resolve(); // 此时，这个语句是无效的 在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定到这个对象上，而不是原来的Deferred对象。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的Deferred对象。 不过最好的写法如下：12345678910111213 var wait = function(dtd)&#123;var dtd = $.Deferred(); // 新建一个Deferred对象 var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 &#125;; var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作 $.when(d) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); Deferred对象的方法 $.Deferred() 生成一个Deferred对象 deferred.progress() 该方法用于指定deferred对象状态为等待中的回调函数。但是她仅在deferred对象生成了进度通知时才会被调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243 var wait = function() &#123; var dtd = $.Deferred(); // 新建一个deferred对象 var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); return dtd;&#125;;// 绑定回调函数$.when(wait()) .done(function() &#123; alert("执行成功了！"); &#125;) .fail(function() &#123; alert("出错啦！"); &#125;) .progress(function(data) &#123; console.log('执行中,已完成', data); &#125;);// 执行中,已完成 10%// 执行中,已完成 20%// 执行中,已完成 30%// 执行中,已完成 40%// 执行中,已完成 50%// 执行中,已完成 60%// 执行中,已完成 70%// 执行中,已完成 80%// 执行中,已完成 90%// 执行中,已完成 100%// 之后弹出 执行完毕！和 执行成功了！ jQuery3.0以上版本对when方法做了大幅调整。向promise/A+靠齐，上面的写法中notify是触发不了when中的progress回调的，需要使用promise来给对象部署deferred接口或使用$.Deferred()传入函数名。 promise 给一个对象部署Deferred接口 1234567891011121314151617181920212223242526272829303132var dtd = $.Deferred(); // 新建一个deferred对象var wait = function(dtd) &#123; var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); &#125;;// 在wait对象上部署Deferred接口，此后就可以直接在wait上使用deferred对象promise后的方法了dtd.promise(wait);// 在wait对象上使用deferred对象的方法指定回调。wait.done(function() &#123; alert("执行成功了！");&#125;).fail(function() &#123; alert("出错啦！");&#125;).progress(function(data) &#123; console.log('执行中,已完成', data);&#125;);// 执行wait(dtd); 使用$.Deferred传入函数名： 123456789101112131415161718192021222324252627282930var wait = function(dtd) &#123; var i = 1, timer, percent; // 记录进度 var tasks = function() &#123; if (i == 11) &#123; alert("执行完毕！"); dtd.resolve(); // 此操作完成后改变deferred对象的执行状态 &#125; else &#123; percent = (i * 500) / 5000 * 100 + '%'; dtd.notify(percent); // 调用progress回调 i++; setTimeout(tasks, 500); &#125; &#125;; setTimeout(tasks, 1000); return dtd;&#125;;// 绑定回调函数$.Deferred(wait) //$.Deferred()的返回值将作为wait函数的参数 .done(function() &#123; alert("执行成功了！"); &#125;) .fail(function() &#123; alert("出错啦！"); &#125;) .progress(function(data) &#123; console.log('执行中,已完成', data); &#125;); deferred.done() 指定操作成功时的回调函数 deferred.fail() 指定操作失败时的回调函数 deferred.promise() 没有参数时，返回一个新的Deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。 deferred.resolve() 手动改变deferred对象的运行状态为“已完成”，从而触发done()方法。 deferred.always() 不管Deferred对象如何，总是执行。 deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将Deferred对象的运行状态变为“已失败”，从而立即触发fail()方法。 $.when() 为多个操作指定回调函数。 deferred.then() 有时为了省事，可以把done()和fail()合写在一起，这就是then()方法。 12$.when($.ajax('test.html')) .then(successFunc,failureFunc); 如果then()有两个参数，那么第一个参数时done()方法的回调函数。如果then()只有一个参数，那么等同于done()。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript函数柯里化]]></title>
      <url>%2F2017%2F03%2F22%2FJavaScript%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
      <content type="text"><![CDATA[什么是函数柯里化 柯里化（Curring）,又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。 柯里化特点 接受单一参数，将更多的参数通过回调函数来解决。 返回一个新的函数，用于处理所有的想要传入的参数。 需要利用call/apply与arguments伪数组收集参数。 返回的函数正是用来处理收集起来的参数。 需要理解JavaScript函数的隐式转换JavaScript是一种弱类型语言，它的隐式转换是非常灵活的。如下： 1234function fn()&#123; return 5;&#125;console.log(fn+10); 试着运行一下你会发现答案为：123function fn()&#123; return 5;&#125;10 接着我们在修改代码为：1234567function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;console.log(fn+10); 你会发现答案为：20，接着我们在进行修改12345678910function fn()&#123; return 5;&#125;fn.toString = function()&#123; return 10;&#125;fn.valueOf = function()&#123; return 20;&#125;console.log(fn+10); 答案为30 当我们使用console.log()或者进行运算时，隐式转换就可能会发生。从上面的例子我们可以得到如下结论： 当我们没有重新定义toString()与valueOf时，函数的隐式转换会调用默认的toString方法，他会将函数的定义内容转化为字符串返回。当我们主动定义了toString()/valueOf时，那么隐式转化的返回结果则由我们自己控制了。其中valueOf的优先级会比toString()高。 需要知道如何利用call/apply封装数组的map方法 map:对数组的每一项运行给定的函数，将每次函数调用返回的结果组成新的数组。 具体实现如下：12345678910111213141516171819Array.prototype._map = function(fn,ctx)&#123; var list = this, temp = []; //用来存储返回的新值 console.log(list); if(typeof fn =='function')&#123; //遍历数组的每一项 list.forEach(function(item,index)&#123; temp.push(fn.call(ctx,item,index)); &#125;); &#125;else&#123; console.err('TypeError:'+fn+' must be a function'); &#125; return temp;&#125;var arr = [2,3,4,5]._map(function(item,index)&#123; return item + index;&#125;);console.log(arr); 理解函数柯里化 考虑实现一个add方法，使结果能够满足如下预期：add(1)(2) = 3add(1,2,3)(4) = 10add(1)(2)(3)(4)(5) = 15 一开始如果只有两个参数，你可能会这样写：12345function add(a)&#123; return function(b)&#123; return a+b; &#125;&#125; 如果有三个的话，可以这样写：1234567function add(a)&#123; return function(b)&#123; return function(c)&#123; return a+b+c; &#125; &#125;&#125; 如果有n个呢，难道要一直嵌套下去，而且2,3种情况也没有覆盖到。所以，要利用函数柯里化，利用闭包的特性，将所有参数，集中到最后的返回函数里进行计算并返回结果。因此，我们在写代码时，要将所有的参数集中起来处理。具体实现如下：12345678910111213141516171819function getSum(rest)&#123; var sum = 0; rest.forEach((item)=&gt;&#123; return sum+=item; &#125;); return sum;&#125;function add (...rest)&#123; var _args = rest; var _adder = function(...rest)&#123; [].push.apply(_args, rest); return _adder; &#125; _adder.toString = function()&#123; return getSum(_args); &#125; return _adder();&#125; 我们再来考虑函数柯里化的例子 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连接起来。我们该怎么做？ 123456var arr = [1,2,3,4,5];Array.prototype.merge = function(chars)&#123; return this.join(chars);&#125;var str = arr.merge('-');console.log(str); 在考虑将数组每一位加一位数在连接起来 12345678var arr = [1,2,3,4];Array.prototype.merge = function(chars,number)&#123; return this.map((item)=&gt;&#123; return item+number; &#125;).join(chars);&#125;var str = arr.merge('-',7);console.log(str); 我们并不知道自己要对数组进行何种处理，所以我们要把对数组的操作封装起来。我们现在只知道需要将他们处理后用字符串连接起来，所以不妨将他们的处理内容保存在函数中，而仅仅固定封装连起来的部分。 12345678910111213141516171819202122232425262728Array.prototype.merge = function(fn,chars)&#123; return this.map(fn).join(chars);&#125;var arr = [1,2,3,4];var add = function(num)&#123; return function(item)&#123; return num + item; &#125;&#125;var reduce = function(num)&#123; return function(item)&#123; return item - num; &#125;&#125;//每一项加2合并var res1 = arr.merge(add(2),'-');//每一项减2合并var res2 = arr.merge(reduce(2),'-');//也可以直接传入回调函数var res3 = arr.merge((function(num)&#123; return function(item)&#123; return item + num; &#125;&#125;)(2),'-'); 柯里化通用式1234567891011121314var currying = function(fn)&#123; var args = [].slice.apply(arguments,[1]); return function()&#123; var _args = args.concat([].slice.apply(arguments)); return fn.apply(null,_args); &#125;&#125;var sum = currying(function()&#123; var list = [].slice.call(arguments); return list.reduce(function(a,b)&#123; return a + b; &#125;);&#125;,10); 柯里化与bind1234567Object.prototype.bind = function(ctx)&#123; var _args = [].slice.call(arguments,1); var fn = this; return function()&#123; fn.apply(ctx,_args.concat([].slice.call(arguments))); &#125;&#125; 参考链接 函数柯里化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript内置函数]]></title>
      <url>%2F2017%2F01%2F05%2FJavaScript%2FJavaScript%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[这篇文章将介绍几个关于JavaScript内置函数的简单算法 一、将字符串重复一定次数1. 使用while循环1234567function repeat(num,str)&#123; var repeatStr = ''; while(num--)&#123; repeatStr+=str; &#125; return repeatStr;&#125; 2. 使用递归12345678910function repeatStringNumTimes(str,times)&#123; if(times&lt;0)&#123; return ''; &#125; if(times===1)&#123; return str; &#125;else&#123; return str + repeatStringNumTimes(str,times-1); &#125;&#125; 3. 使用es6的repeat123function repeatStringNumTimes(str,times)&#123; return times&lt;0?'':str.repeat(times);&#125; 二、检查某一字符串是否已特定字符串结束1. 利用substr函数123function confirmEnding(str,target)&#123; return str.substr(-target.length)===target? true:false;&#125; 2. 使用内置函数123function confirmEnding(str,target)&#123; return str.endsWith(target);&#125; 三、翻转字符串1. 使用split(),reverse(),join()123function reverseStr(str)&#123; return str.split('').reserve().join('');&#125; 2.使用for循环12345678function reverseStr(str)&#123; var newStr = ''; var len = str.length; for(let i = len-1;i&gt;=0;i--)&#123; newStr+=str[i]; &#125; return newStr;&#125; 3. 使用递归123456function reverseStr(str)&#123; if(str==='')&#123; return ''; &#125; return str.charAt(0)+reverseStr(str.substr(1));&#125; 四、将一个句子的每个单词首字母大写，其余小写1. 使用for循环12345678function titleCase(str)&#123; var list = str.toLowerCase().split(' '); var len = list.length; for(let i = 0 ;i&lt;len;i++)&#123; list[i] = list[i].charAt(0).toUpperCase() + list[i].substr(1); &#125; return list.join(' ');&#125; 2. 使用map方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.charAt(0).toUpperCase()+ word.slice(1); &#125;).join('');&#125; 2. 使用replace方法12345function titleCase(str)&#123; return str.toLowerCase().split(' ').map(function(word)&#123; return word.replace(word[0],word[0].toUpperCase()); &#125;).join('');&#125;]]></content>
    </entry>

    
  
  
</search>
